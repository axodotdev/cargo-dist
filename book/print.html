<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js oranda-dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dist</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <link rel="stylesheet" href="oranda-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "oranda-dark" : "oranda-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('orandamdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('orandamdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('orandamdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('oranda-dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">2.</strong> Install</a></li><li class="chapter-item expanded "><a href="quickstart/index.html"><strong aria-hidden="true">3.</strong> Quickstart</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quickstart/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a></li><li class="chapter-item expanded "><a href="quickstart/javascript.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a></li><li class="chapter-item expanded "><a href="quickstart/everyone-else.html"><strong aria-hidden="true">3.3.</strong> Everyone Else</a></li></ol></li><li class="chapter-item expanded "><a href="updating.html"><strong aria-hidden="true">4.</strong> Updating</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">5.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="custom-builds.html"><strong aria-hidden="true">6.</strong> Custom Builds</a></li><li class="chapter-item expanded "><a href="supplychain-security/index.html"><strong aria-hidden="true">7.</strong> Supplychain Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="supplychain-security/signing/windows.html"><strong aria-hidden="true">7.1.</strong> Windows Signing</a></li><li class="chapter-item expanded "><a href="supplychain-security/attestations/github.html"><strong aria-hidden="true">7.2.</strong> GitHub Attestations</a></li></ol></li><li class="chapter-item expanded "><a href="installers/index.html"><strong aria-hidden="true">8.</strong> Installers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installers/shell.html"><strong aria-hidden="true">8.1.</strong> shell</a></li><li class="chapter-item expanded "><a href="installers/powershell.html"><strong aria-hidden="true">8.2.</strong> powershell</a></li><li class="chapter-item expanded "><a href="installers/npm.html"><strong aria-hidden="true">8.3.</strong> npm</a></li><li class="chapter-item expanded "><a href="installers/homebrew.html"><strong aria-hidden="true">8.4.</strong> homebrew</a></li><li class="chapter-item expanded "><a href="installers/msi.html"><strong aria-hidden="true">8.5.</strong> msi</a></li><li class="chapter-item expanded "><a href="installers/updater.html"><strong aria-hidden="true">8.6.</strong> updater</a></li><li class="chapter-item expanded "><a href="installers/usage.html"><strong aria-hidden="true">8.7.</strong> Usage</a></li></ol></li><li class="chapter-item expanded "><a href="artifacts/index.html"><strong aria-hidden="true">9.</strong> Artifacts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="artifacts/archives.html"><strong aria-hidden="true">9.1.</strong> archives</a></li><li class="chapter-item expanded "><a href="artifacts/checksums.html"><strong aria-hidden="true">9.2.</strong> checksums</a></li><li class="chapter-item expanded "><a href="artifacts/symbols.html"><strong aria-hidden="true">9.3.</strong> symbols</a></li></ol></li><li class="chapter-item expanded "><a href="ci/index.html"><strong aria-hidden="true">10.</strong> CI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ci/customizing.html"><strong aria-hidden="true">10.1.</strong> Customizing</a></li></ol></li><li class="chapter-item expanded "><a href="workspaces/index.html"><strong aria-hidden="true">11.</strong> Workspaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="workspaces/structure.html"><strong aria-hidden="true">11.1.</strong> Structure</a></li><li class="chapter-item expanded "><a href="workspaces/simple-guide.html"><strong aria-hidden="true">11.2.</strong> A Simple Application</a></li><li class="chapter-item expanded "><a href="workspaces/workspace-guide.html"><strong aria-hidden="true">11.3.</strong> More Complex Workspaces</a></li><li class="chapter-item expanded "><a href="workspaces/cargo-release-guide.html"><strong aria-hidden="true">11.4.</strong> Using cargo-release</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">12.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/concepts.html"><strong aria-hidden="true">12.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="reference/artifact-url.html"><strong aria-hidden="true">12.2.</strong> Artifact URLs</a></li><li class="chapter-item expanded "><a href="reference/config.html"><strong aria-hidden="true">12.3.</strong> Config</a></li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">12.4.</strong> CLI Manual</a></li><li class="chapter-item expanded "><a href="reference/schema.html"><strong aria-hidden="true">12.5.</strong> dist-manifest.json</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-dark">Axo Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-light">Axo Light</button></li>

                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">dist</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/axodotdev/cargo-dist" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><em>dist distributes your binaries</em></p>
<p>The TL;DR is that with dist setup, just doing this:</p>
<pre><code class="language-sh">git commit -am "release: 0.2.0"
git tag "v0.2.0"
git push
git push --tags
</code></pre>
<p>Will make <a href="https://github.com/axodotdev/axolotlsay/releases/tag/v0.2.0">this Github Release</a>:</p>
<p><img src="./img/simple-github-release.png" alt="A Github Release for &quot;axolotlsay 0.2.0&quot; with several installers and prebuilt binaries" /></p>
<p>Or if you're using <a href="https://axodotdev.github.io/oranda/">oranda</a>, you'll get <a href="https://axodotdev.github.io/axolotlsay/">this website</a>:</p>
<p><img src="./img/simple-oranda.png" alt="A website for &quot;axolotlsay&quot; that has a widget that detects the user&#39;s platform and suggests installation methods" /></p>
<h2 id="plan-build-host-publish-announce"><a class="header" href="#plan-build-host-publish-announce">Plan, Build, Host, Publish, Announce</a></h2>
<p>Cutting releases of your apps and distributing binaries for them has a lot of steps, and dist is quickly growing to try to cover them all!</p>
<p>To accomplish this, dist functionality can be broken up into two parts:</p>
<ul>
<li>building (<strong>planning</strong> the release; <strong>building</strong> binaries and installers)</li>
<li>distributing (<strong>hosting</strong> artifacts; <strong>publishing</strong> packages; <strong>announcing</strong> releases)</li>
</ul>
<p>The build functionality can be used on its own if you just want some tarballs and installers, but everything really comes together when you use the distribution functionality too.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>As a build tool, dist can do the following:</p>
<ul>
<li>Pick good build flags for "shippable binaries"</li>
<li>Make <a href="./artifacts/archives.html">tarballs</a> and <a href="./installers/index.html">installers</a> for the resulting binaries</li>
<li>Generate <a href="./reference/schema.html">machine-readable manifests</a> so other tools can understand the results</li>
</ul>
<p>That's a short list because "we make <a href="./installers/index.html">installers</a>" is doing a lot of heavy lifting. Each installer could be (and sometimes is!) an entire standalone tool with its own documentation and ecosystem.</p>
<h2 id="distributing"><a class="header" href="#distributing">Distributing</a></h2>
<p>As a distribution tool, dist gets to flex its biggest superpower: <strong>it generates <a href="./ci/index.html">its own CI scripts</a></strong>. For instance, enabling <a href="./ci/index.html">GitHub CI</a> with <code>dist init</code> will generate release.yml, which implements the full pipeline of plan, build, host, publish, announce:</p>
<ul>
<li>Plan
<ul>
<li>Waits for you to push a git tag for a new version (v1.0.0, my-app-1.0.0...)</li>
<li>Selects what apps in your workspace to announce new releases for based on that tag</li>
<li>Generates <a href="./reference/schema.html">a machine-readable manifest</a> with changelogs and build plans</li>
</ul>
</li>
<li>Build
<ul>
<li>Spins up machines for each platform you support</li>
<li>Builds your <a href="./artifacts/archives.html">binaries and tarballs</a></li>
<li>Builds <a href="./installers/index.html">installers</a> for your binaries</li>
</ul>
</li>
<li>Publish:
<ul>
<li>Uploads to package managers</li>
</ul>
</li>
<li>Host + Announce:
<ul>
<li>Creates (or edits and undrafts) a GitHub Release</li>
<li>Uploads build artifacts to the Release</li>
<li>Adds relevant release notes from your RELEASES/CHANGELOG</li>
</ul>
</li>
</ul>
<p>(Ideally "host" would come cleanly before "publish", but GitHub Releases doesn't really properly support this kind of staging, so we're forced to race the steps a bit here. Future work may provide a more robust release process.)</p>
<p>Most of the scripts roughly amount to "install dist", "run it exactly once", "upload the artifacts it reported". <strong>We want you to be able to copy that one dist invocation CI did, run it on your machine, and get the same results without any fuss</strong> (not to bit-level precision, but to the kinds of precision normal people expect from cargo builds). No setting up docker, no weird linux-only shell scripts that assume a bunch of tools were setup in earlier CI steps.</p>
<p>Of course even if we perfectly achieve this ideal, "you <em>can</em> run it locally" and "you <em>want to</em> run it locally" are different statements.</p>
<h2 id="check-your-release-process-early-and-often"><a class="header" href="#check-your-release-process-early-and-often">Check Your Release Process Early And Often</a></h2>
<p>To that point, <strong>release.yml can now run partially in pull-requests</strong>. The default is to only run the "plan" step, which includes many integrity checks to help prevent "oops the release process is broken and we only found out when we tried to cut a release".</p>
<p><img src="./img/pr-fail.png" alt="A GitHub PR for &quot;chore: innocently update the Cargo.toml (to cause problems)&quot;, with the Release / plan PR check failing as a result" /></p>
<p>You can also crank the pull-request mode up to include the "build" step, in which case the PR Workflow Summary will include an artifacts.zip containing all the build results. We don't recommend keeping this on all the time (it's slow and wasteful), but it can be useful to temporarily turn on while testing a PR.</p>
<p><img src="./img/workflow-artifacts.png" alt="A GitHub Workflow Summary from running dist&#39;s release.yml with an &quot;artifacts&quot; download link at the bottom" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install"><a class="header" href="#install">Install</a></h1>
<ul>
<li><a href="install.html#pre-built-binaries">Pre-built binaries</a>
<ul>
<li><a href="install.html#installer-scripts">Installer scripts</a>
<ul>
<li><a href="install.html#macos-and-linux-not-nixos">macOS and Linux (not NixOS):</a></li>
<li><a href="install.html#windows-powershell">Windows PowerShell:</a></li>
</ul>
</li>
<li><a href="install.html#package-managers">Package managers</a>
<ul>
<li><a href="install.html#homebrew">Homebrew</a></li>
<li><a href="install.html#pacman-arch-linux">Pacman (Arch Linux)</a></li>
<li><a href="install.html#nix-nixos-macos">Nix (NixOS, macOS)</a></li>
</ul>
</li>
<li><a href="install.html#other-options">Other Options</a>
<ul>
<li><a href="install.html#cargo-binstall">cargo-binstall</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="install.html#build-from-source">Build From Source</a></li>
</ul>
<p>Surprise! The tool for prebuilt shippable binaries has way too many ways to install it!
Whichever way you choose to install it, it should be invocable as <code>dist ...</code>.</p>
<h2 id="pre-built-binaries"><a class="header" href="#pre-built-binaries">Pre-built binaries</a></h2>
<p>We provide several options to access pre-built binaries for a variety of platforms. If you would like to manually download a pre-built binary, checkout <a href="https://github.com/axodotdev/cargo-dist/releases/latest">the latest release on GitHub</a>.</p>
<p>The package names all currently use the original name, <code>cargo-dist</code>. In the future, some or all of these packages will be renamed to just <code>dist</code>.</p>
<h3 id="installer-scripts"><a class="header" href="#installer-scripts">Installer scripts</a></h3>
<h4 id="macos-and-linux-not-nixos"><a class="header" href="#macos-and-linux-not-nixos">macOS and Linux (not NixOS):</a></h4>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh
</code></pre>
<h4 id="windows-powershell"><a class="header" href="#windows-powershell">Windows PowerShell:</a></h4>
<pre><code class="language-sh">powershell -c "irm https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.ps1 | iex"
</code></pre>
<h3 id="package-managers"><a class="header" href="#package-managers">Package managers</a></h3>
<h4 id="homebrew"><a class="header" href="#homebrew">Homebrew</a></h4>
<pre><code class="language-sh">brew install axodotdev/tap/cargo-dist
</code></pre>
<h4 id="pacman-arch-linux"><a class="header" href="#pacman-arch-linux">Pacman (Arch Linux)</a></h4>
<p>Arch Linux users can install the <code>cargo-dist</code> package from the <a href="https://archlinux.org/packages/extra/x86_64/cargo-dist/">extra repository</a> using <a href="https://wiki.archlinux.org/title/Pacman">pacman</a>:</p>
<pre><code class="language-sh">pacman -S cargo-dist
</code></pre>
<h4 id="nix-nixos-macos"><a class="header" href="#nix-nixos-macos">Nix (NixOS, macOS)</a></h4>
<p>Nix users can install <code>cargo-dist</code> from the main nixpkgs repository:</p>
<pre><code class="language-sh">nix-env -i cargo-dist
</code></pre>
<h3 id="other-options"><a class="header" href="#other-options">Other Options</a></h3>
<h4 id="cargo-binstall"><a class="header" href="#cargo-binstall">cargo-binstall</a></h4>
<pre><code class="language-sh">cargo binstall cargo-dist
</code></pre>
<h2 id="build-from-source"><a class="header" href="#build-from-source">Build From Source</a></h2>
<p>For users who need to install dist on platforms that we do not yet provide pre-built binaries for, you will need to build from source.
<code>dist</code> is written in <a href="https://rust-lang.org">Rust</a> and uses <a href="https://doc.rust-lang.org/cargo/index.html">cargo</a> to build. Once you've <a href="https://rustup.rs/">installed the Rust toolchain (<code>rustup</code>)</a>, run:</p>
<pre><code class="language-sh">cargo install cargo-dist --locked
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>What you need to do to setup your project with dist depends on the language your project is written in, so choose your own adventure!</p>
<ul>
<li><a href="quickstart/./rust.html">Rust Quickstart</a></li>
<li><a href="quickstart/./javascript.html">JavaScript Quickstart</a></li>
<li><a href="quickstart/./everyone-else.html">Everyone Else Quickstart</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-quickstart"><a class="header" href="#rust-quickstart">Rust Quickstart</a></h1>
<ul>
<li><a href="quickstart/rust.html#setup">Setup</a>
<ul>
<li><a href="quickstart/rust.html#initial-setup">Initial Setup</a></li>
<li><a href="quickstart/rust.html#adding-installers">Adding Installers</a></li>
</ul>
</li>
<li><a href="quickstart/rust.html#test-it-out">Test It Out</a>
<ul>
<li><a href="quickstart/rust.html#build-for-the-current-platform">Build For The Current Platform</a></li>
<li><a href="quickstart/rust.html#check-what-ci-will-build">Check What CI Will Build</a></li>
<li><a href="quickstart/rust.html#check-the-release-process-on-pull-requests">Check The Release Process On Pull-Requests</a></li>
</ul>
</li>
<li><a href="quickstart/rust.html#cut-a-release-trigger-github-ci">Cut A Release (Trigger Github CI)</a></li>
</ul>
<blockquote>
<p>TLDR: dist is a souped up version of <code>cargo build</code> which handles building <a href="quickstart/../artifacts/archives.html">tarballs</a> and <a href="quickstart/../installers/index.html">installers</a>. It also knows how to generate Github CI for orchestrating itself and uploading its output to a new GitHub Release.</p>
<p>This quickstart is a bit <em>too</em> quick because there's some important nuances to "announcing and building releases" that depend on the way you like to structure and version your workspace. We will blatantly ignore those nuances and show you the Happiest Happy Path (a workspace with one crate that defines a binary). Checkout <a href="quickstart/../workspaces/index.html">the workspace guide</a> for more details on what you should <em>actually</em> do.</p>
</blockquote>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Setting up just requires you to <a href="quickstart/../install.html">install dist</a> and then run <code>dist init</code> in your <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo workspace</a>. This command interactively walks you through configuration options, <strong>and should be run again whenever you want to change your settings or want to update dist</strong>.</p>
<p>Just to really emphasize that: <a href="quickstart/../updating.html"><code>dist init</code> is designed to be rerun over and over, and will preserve your settings while handling any necessary updates and migrations. Always Be Initing</a>.</p>
<h3 id="initial-setup"><a class="header" href="#initial-setup">Initial Setup</a></h3>
<p>Since this is a quickstart, we'll pass <code>--yes</code> to auto-accept all defaults on our first setup!</p>
<pre><code class="language-sh"># setup dist in your project (--yes to accept defaults)
dist init --yes
git add .
git commit -am 'chore: wow shiny new dist CI!'
</code></pre>
<p><strong>It's very common for <code>dist init</code> to return an error about the "repository" URLs set in your Cargo.toml. If this happens, no work will be lost.</strong> You can just follow the instructions in the error and rerun <code>dist init</code> again and it will pick up where you left off.**</p>
<p>This one-time setup will:</p>
<ul>
<li>create your dist config in <code>Cargo.toml</code></li>
<li>add a shippable build profile to your <code>Cargo.toml</code></li>
<li>generate CI for orchestrating itself in <code>.github/workflows/release.yml</code></li>
</ul>
<h3 id="adding-installers"><a class="header" href="#adding-installers">Adding Installers</a></h3>
<p>The most common reason to update dist or mess with its config is to add a new <a href="quickstart/../installers/index.html">installer</a>, which is basically our blanket term for anything more fancy than <a href="quickstart/../artifacts/archives.html">tarballs</a> (curl-sh scripts, npm packages, msi installers, ...).</p>
<p>You can skip this step for now and just test out the basics the initial setup gives you. Each individual <a href="quickstart/../installers/index.html">installer</a> should have a guide that assumes you did the initial setup.</p>
<p>The tl;dr of those guides is "run <code>dist init</code> again, select the installer you want to add, and fill in any extra details that are needed".</p>
<h2 id="test-it-out"><a class="header" href="#test-it-out">Test It Out</a></h2>
<p>There are a several ways to test out dist before committing to running a proper release:</p>
<ol>
<li>build for the current platform (<code>dist build</code>)</li>
<li>check what CI will build (<code>dist plan</code>)</li>
<li>check the release process on pull-requests</li>
</ol>
<h3 id="build-for-the-current-platform"><a class="header" href="#build-for-the-current-platform">Build For The Current Platform</a></h3>
<pre><code class="language-sh">dist build
</code></pre>
<p><img src="quickstart/../img/quickstart-build.png" alt="Running &quot;dist build&quot; on a project, resulting in the application getting built and bundled into a .zip, and an &quot;installer.ps1&quot; script getting generated. Paths to these files are printed along with some metadata." /></p>
<p>The <a href="quickstart/../reference/cli.html#dist-build">build command</a> will by default try to build things for the computer you're running it on. So if you run it on linux you might get a <code>tar.xz</code> containing your binary and an installer.sh, but if you run it on windows you might get a <code>zip</code> and an installer.ps1.</p>
<p>dist will then spit out paths to the files it created, so you can inspect their contents and try running them (<strong>note that installer scripts probably won't be locally runnable, because they will try to fetch their binaries from GitHub</strong>).</p>
<h3 id="check-what-ci-will-build"><a class="header" href="#check-what-ci-will-build">Check What CI Will Build</a></h3>
<pre><code class="language-sh">dist plan
</code></pre>
<p><img src="quickstart/../img/quickstart-plan.png" alt="Running &quot;dist plan&quot; on a project, producing a full printout of the tarballs/zips that will be produced for all platforms (mac, linux, windows), and all installers (shell, powershell)" /></p>
<p>The <a href="quickstart/../reference/cli.html#dist-plan">plan command</a> should be running the exact same logic that dist's generated CI will run, but without actually building anything. This lets you quickly check what cutting a new release will produce. It will also try to catch any inconsistencies that could make the CI error out.</p>
<h3 id="check-the-release-process-on-pull-requests"><a class="header" href="#check-the-release-process-on-pull-requests">Check The Release Process On Pull-Requests</a></h3>
<p>By default we run the "plan" step of your release CI on every pull-request so that we can catch breakage to your release process as early as possible. This will work even for a pull-request that sets up dist for the first time, so you can be confident you're landing something that works.</p>
<p>You can also crank this up by setting <code>pr-run-mode = "upload"</code>, which will run all the build steps as well, and upload the results to the PR's Workflow Summary as an "artifacts.zip". This is great for making sure the windows build works even if you only have a linux machine, or vice-versa. Although you should probably only keep it on temporarily, as it's very slow and wasteful to build all those shippable artifacts for every PR.</p>
<h2 id="cut-a-release-trigger-github-ci"><a class="header" href="#cut-a-release-trigger-github-ci">Cut A Release (Trigger Github CI)</a></h2>
<p>dist largely doesn't care about the details of how you prepare your release, and doesn't yet provide tools to streamline it. All it cares about is you getting your release branch into the state you want, and then pushing a properly formatted git tag like "v0.1.0". Here's a super bare-bones release process where we're releasing by just pushing a bunch of stuff to main branch (but it would work just as well with PRs and release branches):</p>
<pre><code class="language-sh"># &lt;manually update the version of your crate, run tests, etc&gt;

# commit and push to main (can be done with a PR)
git commit -am "release: version 0.1.0"
git push

# actually push the tag up (this triggers dist's CI)
git tag v0.1.0
git push --tags

# publish to crates.io (optional)
cargo publish
</code></pre>
<p>The important parts are that you update the crates you want to release/announce to the desired version and push a git tag with that version.</p>
<p>At this point you're done! The generated CI script should pick up the ball and create a Github Release with all your builds over the next few minutes!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-quickstart"><a class="header" href="#javascript-quickstart">JavaScript Quickstart</a></h1>
<ul>
<li><a href="quickstart/javascript.html#initial-dist-setup">Initial dist Setup</a>
<ul>
<li><a href="quickstart/javascript.html#preparing-your-js-project">Preparing Your JS Project</a>
<ul>
<li><a href="quickstart/javascript.html#adding-bun-as-a-dev-dependency">Adding Bun As A Dev Dependency</a></li>
<li><a href="quickstart/javascript.html#adding-a-dist-script">Adding A dist Script</a></li>
<li><a href="quickstart/javascript.html#adding-dist-workspacetoml">Adding dist-workspace.toml</a></li>
</ul>
</li>
<li><a href="quickstart/javascript.html#first-init">First Init</a></li>
<li><a href="quickstart/javascript.html#adding-installers">Adding Installers</a></li>
</ul>
</li>
<li><a href="quickstart/javascript.html#test-it-out">Test It Out</a>
<ul>
<li><a href="quickstart/javascript.html#build-for-the-current-platform">Build For The Current Platform</a></li>
<li><a href="quickstart/javascript.html#check-what-ci-will-build">Check What CI Will Build</a></li>
<li><a href="quickstart/javascript.html#check-the-release-process-on-pull-requests">Check The Release Process On Pull-Requests</a></li>
</ul>
</li>
<li><a href="quickstart/javascript.html#cut-a-release-trigger-github-ci">Cut A Release (Trigger Github CI)</a></li>
</ul>
<p>So you've written a JavaScript CLI application and you'd like to distribute standalone executables so your users don't need to install nodejs or npm, without having to write your own CI or installers? Well, good news, dist can do just that! This guide will help you get up and running as quickly as possible.</p>
<h2 id="initial-dist-setup"><a class="header" href="#initial-dist-setup">Initial dist Setup</a></h2>
<p>ðŸ”§ This feature requires some extra setup that will be builtin in the future, please let us know if it doesn't work for you!</p>
<p>This is based on the <a href="https://github.com/axodotdev/axolotlsay-bun">axolotlsay-bun example project</a>.</p>
<h3 id="preparing-your-js-project"><a class="header" href="#preparing-your-js-project">Preparing Your JS Project</a></h3>
<p>We will be using <a href="https://bun.sh/docs/bundler/executables">bun build --compile</a> to generate standalone executables for an npm project. In the future this will be more builtin, but for now we're going to need to teach your npm package to install bun and build itself. To do this we're going to add bun as a dev-dependency of our application and add a "dist" <a href="https://docs.npmjs.com/cli/v10/using-npm/scripts">npm script</a> that runs <code>bun build</code> on itself.</p>
<p><a href="https://github.com/axodotdev/axolotlsay-bun/commit/8aeebf8dfd91527352b5d9afe0146cd752028f19">Here's what the changes look like in axolotlsay-bun</a>.</p>
<h4 id="adding-bun-as-a-dev-dependency"><a class="header" href="#adding-bun-as-a-dev-dependency">Adding Bun As A Dev Dependency</a></h4>
<p>To make it easy for anyone working on our package to get the Right version of bun and use it, we can install it as an npm dev-dependency like so:</p>
<pre><code class="language-sh">npm i bun --save-dev
</code></pre>
<p>Your package.json should now have something like this:</p>
<pre><code class="language-json">  "devDependencies": {
    "bun": "^1.x.x"
  }
</code></pre>
<h4 id="adding-a-dist-script"><a class="header" href="#adding-a-dist-script">Adding A dist Script</a></h4>
<p>We want it to be easy for anyone to run our bun build on any platform, so add <a href="https://docs.npmjs.com/cli/v10/using-npm/scripts">a script called "dist" to our package.json</a>:</p>
<pre><code class="language-json">  "scripts": {
    "predist": "npm install",
    "dist": "node dist.js"
  },
</code></pre>
<p>We run <code>npm install</code> in "predist" to ensure dev-dependencies like bun are installed for anyone who runs the "dist" script. The name "dist" here is important, as dist will be looking for it. However the file it runs can have any name/location. Here we're calling it "dist.js", and it contains the following:</p>
<pre><code class="language-js">// you might need to change this path to your package.json
const { bin } = require("./package.json");
const execSync = require('child_process').execSync;

// Compute the target we're building for
const bunTargets = {
    "x86_64-pc-windows-msvc": "bun-windows-x64",
    "aarch64-apple-darwin": "bun-darwin-arm64",
    "x86_64-apple-darwin": "bun-darwin-x64",
    "aarch64-unknown-linux-gnu": "bun-linux-arm64",
    "x86_64-unknown-linux-gnu": "bun-linux-x64"
}
const distTarget = process.env.CARGO_DIST_TARGET || process.env.DIST_TARGET;
if (!distTarget) {
    throw "DIST_TARGET isn't set, so we don't know what platform to build!"
}
const bunTarget = bunTargets[distTarget];
if (!bunTarget) {
    throw `To the the best of our knowledge, bun does not support building for ${distTarget}`;
}
const binExt = distTarget.includes("windows") ? ".exe" : "";

// setup bun
execSync("bun install");

// for each binary, run bun
for (binName of Object.keys(bin)) {
    const binScript = bin[binName];
    const binPath = `${binName}${binExt}`;
    execSync(`bun build ${binScript} --compile --target ${bunTarget} --outfile ${binPath}`);
}
</code></pre>
<p>Ideally you won't have to customize this script at all (except maybe the relative path to package.json on the first line), because it reads your package.json and determines what to do for you. In particular it requires you to have <a href="https://docs.npmjs.com/cli/v10/configuring-npm/package-json#bin">a "bin" field in your package.json</a>:</p>
<pre><code class="language-json">  "bin": {
    "axolotlsay-bun": "index.js"
  },
</code></pre>
<p>While you're here, you should also make sure you've set required fields like:</p>
<ul>
<li>"name"</li>
<li>"version"</li>
<li>"repository" set</li>
</ul>
<p>So your package.json should at a minimum look something like this:</p>
<pre><code class="language-json">{
  "name": "axolotlsay-bun",
  "version": "0.4.0",
  "repository": "github:axodotdev/axolotlsay-hybrid",
  "bin": {
    "axolotlsay-bun": "index.js"
  },
  "scripts": {
    "predist": "npm install",
    "dist": "node dist.js"
  },
  "devDependencies": {
    "bun": "^1.x.x"
  }
}
</code></pre>
<h4 id="adding-dist-workspacetoml"><a class="header" href="#adding-dist-workspacetoml">Adding dist-workspace.toml</a></h4>
<p>dist uses a custom configuration format called <code>dist-workspace.toml</code>, written in the <a href="https://toml.io/en/">TOML</a> format. dist can manage most of your settings for you, or find them in your package.json, but we need to tell it that we're making a JS project.</p>
<p>Create a file named <code>dist-workspace.toml</code> in the root of your repository. These are the entire contents of the file (you supply the path):</p>
<pre><code class="language-toml">[workspace]
members = ["npm:relative/path/to/your/package/"]
</code></pre>
<p>(If your project is in the root, this may just be <code>members = ["npm:./"]</code>)</p>
<h3 id="first-init"><a class="header" href="#first-init">First Init</a></h3>
<p>Once you've done that and also <a href="quickstart/../install.html">installed dist</a>, we can ask dist to generate the rest of its configuration for us: just run <code>dist init</code>, and answer all the questions it asks you. This command interactively walks you through configuration options, <strong>and should be run again whenever you want to change your settings or want to update dist</strong>.</p>
<p>Just to really emphasize that: <a href="quickstart/../updating.html"><code>dist init</code> is designed to be rerun over and over, and will preserve your settings while handling any necessary updates and migrations. Always Be Initing</a>.</p>
<p>Since this is a quickstart, we'll pass <code>--yes</code> to auto-accept all defaults on our first setup!</p>
<pre><code class="language-sh"># setup dist in your project (--yes to accept defaults)
dist init --yes
git add .
git commit -am 'chore: wow shiny new dist CI!'
</code></pre>
<p><strong>It's very common for <code>dist init</code> to return an error about the "repository" URLs set in your package.json. If this happens, no work will be lost.</strong> You can just follow the instructions in the error and rerun <code>dist init</code> again and it will pick up where you left off.**</p>
<p>This one-time setup will:</p>
<ul>
<li>create your dist config in <code>dist-workspace.toml</code></li>
<li>generate CI for orchestrating itself in <code>.github/workflows/release.yml</code></li>
</ul>
<h3 id="adding-installers-1"><a class="header" href="#adding-installers-1">Adding Installers</a></h3>
<blockquote>
<p>ðŸš¨ðŸš¨ðŸš¨ VERY IMPORTANT ðŸš¨ðŸš¨ðŸš¨</p>
<p>dist supports "npm installers" and "npm publishes" but these refer to a feature that wraps your prebuilt binaries in an npm package that fetches them, and is <a href="https://github.com/axodotdev/cargo-dist/issues/1169">not (YET) a thing for actual native javascript projects</a>!</p>
</blockquote>
<p>The most common reason to update dist or mess with its config is to add a new <a href="quickstart/../installers/index.html">installer</a>, which is basically our blanket term for anything more fancy than <a href="quickstart/../artifacts/archives.html">tarballs</a> (curl-sh scripts, npm packages, msi installers, ...).</p>
<p>You can skip this step for now and just test out the basics the initial setup gives you. Each individual <a href="quickstart/../installers/index.html">installer</a> should have a guide that assumes you did the initial setup.</p>
<p>The tl;dr of those guides is "run <code>dist init</code> again, select the installer you want to add, and fill in any extra details that are needed".</p>
<h2 id="test-it-out-1"><a class="header" href="#test-it-out-1">Test It Out</a></h2>
<p>There are a several ways to test out dist before committing to running a proper release:</p>
<ol>
<li>build for the current platform (<code>dist build</code>)</li>
<li>check what CI will build (<code>dist plan</code>)</li>
<li>check the release process on pull-requests</li>
</ol>
<h3 id="build-for-the-current-platform-1"><a class="header" href="#build-for-the-current-platform-1">Build For The Current Platform</a></h3>
<pre><code class="language-sh">dist build
</code></pre>
<p><img src="quickstart/../img/quickstart-build.png" alt="Running &quot;dist build&quot; on a project, resulting in the application getting built and bundled into a .zip, and an &quot;installer.ps1&quot; script getting generated. Paths to these files are printed along with some metadata." /></p>
<p>The <a href="quickstart/../reference/cli.html#dist-build">build command</a> will by default try to build things for the computer you're running it on. So if you run it on linux you might get a <code>tar.xz</code> containing your binary and an installer.sh, but if you run it on windows you might get a <code>zip</code> and an installer.ps1.</p>
<p>dist will then spit out paths to the files it created, so you can inspect their contents and try running them (<strong>note that installer scripts probably won't be locally runnable, because they will try to fetch their binaries from GitHub</strong>).</p>
<h3 id="check-what-ci-will-build-1"><a class="header" href="#check-what-ci-will-build-1">Check What CI Will Build</a></h3>
<pre><code class="language-sh">dist plan
</code></pre>
<p><img src="quickstart/../img/quickstart-plan.png" alt="Running &quot;dist plan&quot; on a project, producing a full printout of the tarballs/zips that will be produced for all platforms (mac, linux, windows), and all installers (shell, powershell)" /></p>
<p>The <a href="quickstart/../reference/cli.html#dist-plan">plan command</a> should be running the exact same logic that dist's generated CI will run, but without actually building anything. This lets you quickly check what cutting a new release will produce. It will also try to catch any inconsistencies that could make the CI error out.</p>
<h3 id="check-the-release-process-on-pull-requests-1"><a class="header" href="#check-the-release-process-on-pull-requests-1">Check The Release Process On Pull-Requests</a></h3>
<p>By default we run the "plan" step of your release CI on every pull-request so that we can catch breakage to your release process as early as possible. This will work even for a pull-request that sets up dist for the first time, so you can be confident you're landing something that works.</p>
<p>You can also crank this up by setting <code>pr-run-mode = "upload"</code>, which will run all the build steps as well, and upload the results to the PR's Workflow Summary as an "artifacts.zip". This is great for making sure the windows build works even if you only have a linux machine, or vice-versa. Although you should probably only keep it on temporarily, as it's very slow and wasteful to build all those shippable artifacts for every PR.</p>
<h2 id="cut-a-release-trigger-github-ci-1"><a class="header" href="#cut-a-release-trigger-github-ci-1">Cut A Release (Trigger Github CI)</a></h2>
<p>dist largely doesn't care about the details of how you prepare your release, and doesn't yet provide tools to streamline it. All it cares about is you getting your release branch into the state you want, and then pushing a properly formatted git tag like "v0.1.0". Here's a super bare-bones release process where we're releasing by just pushing a bunch of stuff to main branch (but it would work just as well with PRs and release branches):</p>
<pre><code class="language-sh"># &lt;manually update the version of your package, run tests, etc&gt;

# commit and push to main (can be done with a PR)
git commit -am "release: version 0.1.0"
git push

# actually push the tag up (this triggers dist's CI)
git tag v0.1.0
git push --tags
</code></pre>
<p>The important parts are that you update the packages you want to release/announce to the desired version and push a git tag with that version.</p>
<p>At this point you're done! The generated CI script should pick up the ball and create a Github Release with all your builds over the next few minutes!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="everyone-else-quickstart"><a class="header" href="#everyone-else-quickstart">Everyone Else Quickstart</a></h1>
<ul>
<li><a href="quickstart/everyone-else.html#setup">Setup</a>
<ul>
<li><a href="quickstart/everyone-else.html#initial-setup">Initial Setup</a></li>
<li><a href="quickstart/everyone-else.html#adding-installers">Adding Installers</a></li>
</ul>
</li>
<li><a href="quickstart/everyone-else.html#test-it-out">Test It Out</a>
<ul>
<li><a href="quickstart/everyone-else.html#build-for-the-current-platform">Build For The Current Platform</a></li>
<li><a href="quickstart/everyone-else.html#check-what-ci-will-build">Check What CI Will Build</a></li>
<li><a href="quickstart/everyone-else.html#check-the-release-process-on-pull-requests">Check The Release Process On Pull-Requests</a></li>
</ul>
</li>
<li><a href="quickstart/everyone-else.html#cut-a-release-trigger-github-ci">Cut A Release (Trigger Github CI)</a></li>
<li><a href="quickstart/everyone-else.html#more-details">More details</a></li>
</ul>
<p>So you've written a piece of software and you'd like to distribute it, but managing CI and installers is hard. dist's generic build support lets you access all the same building and distribution features you get from Cargo-based builds in any language. This guide will help you get up and running as quickly as possible.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Once you've <a href="quickstart/../install.html">installed dist</a>, you're ready to get started. Prepping your app for dist requires just a little bit of configuration.</p>
<p>dist uses a custom configuration format called <code>dist.toml</code>, written in the <a href="https://toml.io/en/">TOML</a> format. dist can manage most of your settings for you, but we'll need to write a little bit of information to tell dist about your software and what it needs to expect.</p>
<p>To start, create a file named <code>dist.toml</code> in the root of your repository. The top of the file needs a field named <code>[package]</code> containing some basic metadata about your project, which looks like this:</p>
<pre><code class="language-toml">[package]
# The name of your package; dist will use this in your installers and announcements
name = "quickstart-example"
# (Optional) Descriptive text about your package; some installers will present this to users
description = "This is a description of your package"
# The current version of your package - you'll update this with every release
version = "1.0.0"
# (Optional) Your package's license
license = "GPL-3.0-only"
# The URL to package's git repository
repository = "https://github.com/example/example"
# A list of all binaries your package will build and install
binaries = ["quickstart-example"]
# A command dist should run that will build your project
build-command = ["make"]
</code></pre>
<p>Once you've created this file, we can ask dist to generate the rest of its configuration for us: just run <code>dist init</code>, and answer all the questions it asks you. This command interactively walks you through configuration options, <strong>and should be run again whenever you want to change your settings or want to update dist</strong>.</p>
<p>Just to really emphasize that: <a href="quickstart/../updating.html"><code>dist init</code> is designed to be rerun over and over, and will preserve your settings while handling any necessary updates and migrations. Always Be Initing</a>.</p>
<h3 id="initial-setup-1"><a class="header" href="#initial-setup-1">Initial Setup</a></h3>
<p>Since this is a quickstart, we'll pass <code>--yes</code> to auto-accept all defaults on our first setup!</p>
<pre><code class="language-sh"># setup dist in your project (--yes to accept defaults)
dist init --yes
git add .
git commit -am 'chore: wow shiny new dist CI!'
</code></pre>
<p><strong>It's very common for <code>dist init</code> to return an error about the "repository" URLs set in your Cargo.toml. If this happens, no work will be lost.</strong> You can just follow the instructions in the error and rerun <code>dist init</code> again and it will pick up where you left off.**</p>
<p>This one-time setup will:</p>
<ul>
<li>create your dist config in <code>dist.toml</code></li>
<li>generate CI for orchestrating itself in <code>.github/workflows/release.yml</code></li>
</ul>
<p>Once you've run <code>init</code>, check your <code>dist.toml</code>: dist has added a bunch of new settings with all the choices you made. If you chose to turn on GitHub CI, you'll also see that it's created a <code>.github/workflows/release.yml</code> for you: this will be run every time you create a release of your software.</p>
<h3 id="adding-installers-2"><a class="header" href="#adding-installers-2">Adding Installers</a></h3>
<p>The most common reason to update dist or mess with its config is to add a new <a href="quickstart/../installers/index.html">installer</a>, which is basically our blanket term for anything more fancy than <a href="quickstart/../artifacts/archives.html">tarballs</a> (curl-sh scripts, npm packages, msi installers, ...).</p>
<p>You can skip this step for now and just test out the basics the initial setup gives you. Each individual <a href="quickstart/../installers/index.html">installer</a> should have a guide that assumes you did the initial setup.</p>
<p>The tl;dr of those guides is "run <code>dist init</code> again, select the installer you want to add, and fill in any extra details that are needed".</p>
<h2 id="test-it-out-2"><a class="header" href="#test-it-out-2">Test It Out</a></h2>
<p>There are a several ways to test out dist before committing to running a proper release:</p>
<ol>
<li>build for the current platform (<code>dist build</code>)</li>
<li>check what CI will build (<code>dist plan</code>)</li>
<li>check the release process on pull-requests</li>
</ol>
<h3 id="build-for-the-current-platform-2"><a class="header" href="#build-for-the-current-platform-2">Build For The Current Platform</a></h3>
<pre><code class="language-sh">dist build
</code></pre>
<p><img src="quickstart/../img/quickstart-build.png" alt="Running &quot;dist build&quot; on a project, resulting in the application getting built and bundled into a .zip, and an &quot;installer.ps1&quot; script getting generated. Paths to these files are printed along with some metadata." /></p>
<p>The <a href="quickstart/../reference/cli.html#dist-build">build command</a> will by default try to build things for the computer you're running it on. So if you run it on linux you might get a <code>tar.xz</code> containing your binary and an installer.sh, but if you run it on windows you might get a <code>zip</code> and an installer.ps1.</p>
<p>dist will then spit out paths to the files it created, so you can inspect their contents and try running them (<strong>note that installer scripts probably won't be locally runnable, because they will try to fetch their binaries from GitHub</strong>).</p>
<h3 id="check-what-ci-will-build-2"><a class="header" href="#check-what-ci-will-build-2">Check What CI Will Build</a></h3>
<pre><code class="language-sh">dist plan
</code></pre>
<p><img src="quickstart/../img/quickstart-plan.png" alt="Running &quot;dist plan&quot; on a project, producing a full printout of the tarballs/zips that will be produced for all platforms (mac, linux, windows), and all installers (shell, powershell)" /></p>
<p>The <a href="quickstart/../reference/cli.html#dist-plan">plan command</a> should be running the exact same logic that dist's generated CI will run, but without actually building anything. This lets you quickly check what cutting a new release will produce. It will also try to catch any inconsistencies that could make the CI error out.</p>
<h3 id="check-the-release-process-on-pull-requests-2"><a class="header" href="#check-the-release-process-on-pull-requests-2">Check The Release Process On Pull-Requests</a></h3>
<p>By default we run the "plan" step of your release CI on every pull-request so that we can catch breakage to your release process as early as possible. This will work even for a pull-request that sets up dist for the first time, so you can be confident you're landing something that works.</p>
<p>You can also crank this up by setting <code>pr-run-mode = "upload"</code>, which will run all the build steps as well, and upload the results to the PR's Workflow Summary as an "artifacts.zip". This is great for making sure the windows build works even if you only have a linux machine, or vice-versa. Although you should probably only keep it on temporarily, as it's very slow and wasteful to build all those shippable artifacts for every PR.</p>
<h2 id="cut-a-release-trigger-github-ci-2"><a class="header" href="#cut-a-release-trigger-github-ci-2">Cut A Release (Trigger Github CI)</a></h2>
<p>dist largely doesn't care about the details of how you prepare your release, and doesn't yet provide tools to streamline it. All it cares about is you getting your release branch into the state you want, updating the version number in <code>dist.toml</code>, and then pushing a properly formatted git tag like "v0.1.0". Here's a super bare-bones release process where we're releasing by just pushing a bunch of stuff to main branch (but it would work just as well with PRs and release branches):</p>
<pre><code class="language-sh"># &lt;manually update the version of your package, run tests, etc&gt;
# &lt;make sure to set the package version in dist.toml, too&gt;

# commit and push to main (can be done with a PR)
git commit -am "release: version 0.1.0"
git push

# actually push the tag up (this triggers dist's CI)
git tag v0.1.0
git push --tags
</code></pre>
<p>The important parts are that you update the crates you want to release/announce to the desired version and push a git tag with that version.</p>
<p>At this point you're done! The generated CI script should pick up the ball and create a Github Release with all your builds over the next few minutes!</p>
<h2 id="more-details"><a class="header" href="#more-details">More details</a></h2>
<p>For more details on configuring builds and other advanced features, see the <a href="quickstart/../custom-builds.html">custom builds</a> page. For more details on all of the supported fields in <code>dist.toml</code>, see the <a href="quickstart/../reference/config.html#the-package-section">config</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating"><a class="header" href="#updating">Updating</a></h1>
<p>Just</p>
<p><code>dist init</code></p>
<p>That's it!</p>
<p>Rerun init as much as you want, it should always preserve your old settings, and should never break anything (if it does, it's a bug!).</p>
<p>If you have a project with dist setup on it, and want to upgrade to a new version, all you should ever need to do is locally install the new version of dist and run <code>dist init</code>.</p>
<p>If you're simply adjusting your dist config, you should also rerun <code>dist init</code> to potentially get informed of new features/constraints your change runs into. It also ensures that things like your ci.yml are updated to reflect your new config. Basically every other dist command should error out if you <em>have</em> to rerun init, so you won't get far if you don't.</p>
<p>We recommend running without <code>-y</code> for reruns, because this is the chance dist has to tell you about new features, or additional configuration that pairs with any adjustments you may have made. It will take that chance to ask you if you want to enable the feature or change the default value.</p>
<p>In general the init command is designed to do incremental updates to your installation, and "first setup" is just a special case of this, where every incremental update is applicable.</p>
<p>The command usually uses the absence of a setting in your config to determine if a feature has been setup before. As such, even though dist <em>generally</em> has default values for every piece of config, init will aggressively write the default back to your config to let future invocations know they don't need to ask about it.</p>
<p>Which also means if you missed a prompt or want to reconfigure a feature, deleting the relevant setting from your config and rerunning <code>init</code> should work.</p>
<p>There are two settings that init will always prompt you for:</p>
<ul>
<li>what platforms do you want to build for</li>
<li>what installers do you want to have</li>
</ul>
<p>So if you ever want to add a new platform or installer, rerunning <code>dist init</code> is a great way to do that -- and then it can ask followup questions if you turn on a new installer!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>Having an issue with dist? Here's some of the common issues and solutions!</p>
<ul>
<li><a href="troubleshooting.html#what-we-would-usually-do">What We Would Usually Do</a></li>
<li><a href="troubleshooting.html#nothing-to-release--missing-packages--too-many-packages">Nothing To Release / Missing Packages / Too Many Packages</a></li>
<li><a href="troubleshooting.html#recovering-failed-ci-jobs">Recovering Failed CI Jobs</a>
<ul>
<li><a href="troubleshooting.html#failed-ci-spurious">Failed CI: Spurious</a></li>
<li><a href="troubleshooting.html#failed-ci-busted-builds">Failed CI: Busted Builds</a></li>
</ul>
</li>
<li><a href="troubleshooting.html#oops-my-changelog">Oops, My Changelog!</a></li>
<li><a href="troubleshooting.html#repository-urls--source-hosts--hosting-providers">Repository URLs / Source Hosts / Hosting Providers</a></li>
<li><a href="troubleshooting.html#the-protip-zone">The Protip Zone</a></li>
</ul>
<h2 id="what-we-would-usually-do"><a class="header" href="#what-we-would-usually-do">What We Would Usually Do</a></h2>
<p>Regardless of the issue, these are the "default" troubleshooting steps that are good to keep in mind:</p>
<ol>
<li>diagnose: <a href="./quickstart/rust.html#check-what-ci-will-build">run <code>dist plan</code></a></li>
<li>update and repair: <a href="./updating.html">run <code>dist init</code> again</a></li>
<li>test your process: <a href="./ci/customizing.html#build-and-upload-artifacts-on-every-pull-request">try <code>pr-run-mode = "upload"</code></a></li>
</ol>
<p>These are also great steps to follow proactively, if you're updating your dist config.</p>
<h2 id="nothing-to-release--missing-packages--too-many-packages"><a class="header" href="#nothing-to-release--missing-packages--too-many-packages">Nothing To Release / Missing Packages / Too Many Packages</a></h2>
<p>dist tries to support as many release workflows as possible, and that means it needs you to tell it what you're interested in releasing. There are several ways to opt things in and out of being released; the most important are:</p>
<ul>
<li><a href="./workspaces/workspace-guide.html#announcement-tags">git tag formats</a>
<ul>
<li>git tags select which packages you're interested in doing a release for</li>
<li>do all the packages you want to publish have the same version as your git tag?</li>
<li>are you prefixing the tag with something that looks like a package name?</li>
</ul>
</li>
<li><a href="./reference/config.html#publish"><code>[package].publish</code></a>
<ul>
<li>tells cargo whether the package should be published to crates.io</li>
<li>dist assumes you don't want to release <code>publish = false</code> packages (since they're probably for testing)</li>
</ul>
</li>
<li><a href="./reference/config.html#dist"><code>[package.metadata.dist].dist</code></a>
<ul>
<li>overrides <code>publish</code> for dist releases, either to force a package on or off</li>
</ul>
</li>
</ul>
<h2 id="recovering-failed-ci-jobs"><a class="header" href="#recovering-failed-ci-jobs">Recovering Failed CI Jobs</a></h2>
<p>Sometimes CI fails, and that's ok! The steps to follow depend on what went wrong. There's little that can't be recovered, you've got this.</p>
<h3 id="failed-ci-spurious"><a class="header" href="#failed-ci-spurious">Failed CI: Spurious</a></h3>
<p>If you believe the failure was spurious (Github CI flaking out, some networked service being temporarily down, a SECRET not being set...), then good news: it's totally safe to "retry failed jobs" in the Github CI interface! We should pick up your release process from where it left off.</p>
<p>We <em>DO NOT</em> recommend "retry all jobs". Either it's redundant or it can cause problems with trying to repeat side-effects like publishing a package.</p>
<h3 id="failed-ci-busted-builds"><a class="header" href="#failed-ci-busted-builds">Failed CI: Busted Builds</a></h3>
<p>If you believe something was busted in your release process, and the commit you tried to release from isn't suitable, that's generally ok! Usually this will occur because some part of your build is broken, perhaps only when releasing with dist, or only on a particular platform.</p>
<p>If this is the case then presumably your release process errored out before the the "host" step where we actually uploaded anything, so good news: no side effects need to be rolled back!</p>
<p>Well, one side-effect needs to be dealt with, but it's the one you did to kick off the release: <a href="https://stackoverflow.com/questions/5480258/how-can-i-delete-a-remote-tag">delete the git tag from github and your local machine</a>, get your build sorted out, and then tag the new release commit.</p>
<p>"Get your build sorted out" is of course, eliding a lot of details. If the issue appears to be exclusive to dist CI, we recommend opening a PR against your project with <a href="./ci/customizing.html#build-and-upload-artifacts-on-every-pull-request"><code>pr-run-mode = "upload"</code></a> temporarily enabled. This will run all of the build steps for your release process without you needing to push a git tag, so you're free to experiment and rapidly iterate without <em>any</em> risk of side-effects.</p>
<h2 id="oops-my-changelog"><a class="header" href="#oops-my-changelog">Oops, My Changelog!</a></h2>
<p>Changelogs are arguably the most important and challenging part of a release process. Although dist currently has no way to Do Changelogs For You, it does have several features for Using Your Changelogs:</p>
<ul>
<li><a href="./workspaces/simple-guide.html#release-notes">Having dist parse your RELEASES or CHANGELOG file</a></li>
<li><a href="./ci/customizing.html#bring-your-own-release">Telling dist you're bringing your own changelogs with tools like release-drafter</a></li>
</ul>
<p>The latter will just have dist not clobber the changelogs you upload to Github Releases, and is therefore easy to fix: just hand-edit your Github Release more.</p>
<p>The former is more challenging to fix, and is a place we're trying to improve. dist will natively understand your changelogs and bake them into a few different things:</p>
<ul>
<li>The changelog will be sent to your release hosting providers (github and/or axo) as part of the announcement</li>
<li>The changelog will be stored in the dist-manifest.json
<ul>
<li>Which will in turn <a href="https://github.com/axodotdev/oranda">get used by oranda, if you're using that</a></li>
</ul>
</li>
</ul>
<p>This is to say, trying to hand-edit your way out of this situation requires you to find and fix a lot of data if you Really Want A Perfect Changelog. In some cases we've found it simpler to just redo the whole release process (either by deleting a Github Release or bumping the version number).</p>
<h2 id="repository-urls--source-hosts--hosting-providers"><a class="header" href="#repository-urls--source-hosts--hosting-providers">Repository URLs / Source Hosts / Hosting Providers</a></h2>
<p><a href="./reference/artifact-url.html">Many features</a> of dist depend on the ability to know where your project is hosted, and where the build results will get uploaded. The most common issue users encounter here is not having a defined <a href="./reference/artifact-url.html#source-hosts">Source Host</a>, which basically just means you need to audit the <code>[package].repository</code> values you set in your Cargo.tomls and make sure they consistently point to your GitHub repo. <a href="./reference/artifact-url.html#source-hosts">See the Source Host docs for details</a>.</p>
<h2 id="the-protip-zone"><a class="header" href="#the-protip-zone">The Protip Zone</a></h2>
<p>Sometimes users run into issues that are quickly resolved by "I had no idea Rust let you do that", so here's some quick pointers to useful Rust/Cargo/Rustup features (and a promise that we handle them properly):</p>
<ul>
<li><a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rust-toolchain.toml exists to tell rustup your project should be built with a specific version of Rust</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">the <code>[[bin]]</code> section of a Cargo.toml lets a single package have multiple binaries, or to rename the only binary</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field"><code>publish = false</code> lets you tell Cargo not to publish a package</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table">Cargo packages can inherit keys from the workspace package to keep things in sync</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-builds"><a class="header" href="#custom-builds">Custom Builds</a></h1>
<blockquote>
<p>since 0.5.0</p>
</blockquote>
<p>When releasing software in languages other than Rust or JavaScript, you'll need to tell dist how to build it â€” there are more buildsystems than stars in the sky, and dist can't know how to run all of them (or how to figure out what to release from them).</p>
<p>This guide assumes you've already initialized the dist config; check the <a href="./quickstart/everyone-else.html">quickstart guide</a> for how to get started.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li><a href="https://github.com/axodotdev/axolotlsay-js">example npm project</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist-c-example">example C project</a></li>
</ul>
<h3 id="understanding-build-commands"><a class="header" href="#understanding-build-commands">Understanding build commands</a></h3>
<p>Build commands are the core difference between these builds and Rust builds. Since we don't have Cargo to rely on to tell us how to build your package, it's up to you to tell us how instead.</p>
<p>As an example, let's imagine a C program with a simple makefile-based buildsystem. Its <code>dist.toml</code> looks something like this:</p>
<pre><code class="language-toml">[package]
# Your app's name
name = "my_app"
# The current version; make sure to keep this up to date!
version = "0.1.0"
# The URL to the git repository; this is used for publishing releases
repository = "https://github.com/example/example"
# The executables produced by your app
binaries = ["main"]
# The build command dist runs to produce those binaries
build-command = ["make"]
</code></pre>
<p>All you need to run to build this program is <code>make</code>, so we specified <code>build-command = ["make"]</code>. If your app has a more complex build that will require multiple commands to run, it may be easier for you to add a build script to your repository. In that case, <code>build-command</code> can simply be a reference to executing it:</p>
<pre><code class="language-toml">build-command = ["./build.sh"]
</code></pre>
<p>We expose a special environment variable called <code>CARGO_DIST_TARGET</code> into your build. It contains a <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">Rust-style target triple</a> for the platform we expect your build to build for. Depending on the language of the software you're building, you may need to use this to set appropriate cross-compilation flags. For example, when dist is building for an Apple Silicon Mac, we'll set <code>aarch64-apple-darwin</code> in order to allow your build to know when it should build for aarch64 even if the host is x86_64.</p>
<p>On macOS, we expose several additional environment variables to help your buildsystem find dependencies. In the future, we may add more environment variables on all platforms.</p>
<ul>
<li><code>CFLAGS</code>/<code>CPPFLAGS</code>: Flags used by the C preprocessor and C compiler while building.</li>
<li><code>LDFLAGS</code>: Flags used by the C linker.</li>
<li><code>PKG_CONFIG_PATH</code>/<code>PKG_CONFIG_LIBDIR</code>: Paths for <code>pkg-config</code> to help it locate packages.</li>
<li><code>CMAKE_INCLUDE_PATH</code>/<code>CMAKE_LIBRARY_PATH</code>: Paths for <code>cmake</code> to help it locate packages' configuration files.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supply-chain-security"><a class="header" href="#supply-chain-security">Supply-chain security</a></h1>
<p>As software supplychain security concerns and requirements grow, <code>dist</code> is
committed to making compliance with policies and regulations as turnkey as possible.</p>
<p>If you have an integration you are looking for <a href="https://github.com/axodotdev/cargo-dist/issues/new">file an issue</a> or
<a href="https://discord.gg/ry3f3HZXWN">join our Discord</a>.</p>
<h2 id="signing"><a class="header" href="#signing">Signing</a></h2>
<ul>
<li><a href="supplychain-security/./signing/windows.html">Windows Codesigning</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/1121">ðŸ”œ macOS Codesigning</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/120">ðŸ”œ Linux Codesigning</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/120">ðŸ”œ Sigstore Signing</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/1122">ðŸ”œ Windows Trusted Signing</a></li>
</ul>
<h2 id="attestation"><a class="header" href="#attestation">Attestation</a></h2>
<ul>
<li><a href="supplychain-security/./attestations/github.html">GitHub Attestation</a></li>
</ul>
<h2 id="sboms-and-dependency-managers"><a class="header" href="#sboms-and-dependency-managers">SBOMs and Dependency Managers</a></h2>
<h3 id="cargo-cyclonedx"><a class="header" href="#cargo-cyclonedx">cargo-cyclonedx</a></h3>
<p>dist can optionally generate a <a href="https://cyclonedx.org">CycloneDX</a>-format Software Bill of Materials (SBOM) for Rust projects using the <a href="https://cyclonedx.org">cargo-cyclonedx</a> tool. This data is stored as a standalone <code>bom.xml</code> file which is distributed alongside your binaries in your tarballs. Users can validate that SBOM file using <a href="https://cyclonedx.org/tool-center/">any compatible CycloneDX tool</a>. For more information about using this feature, see <a href="supplychain-security/../reference/config.html#cargo-cyclonedx">the config documentation</a>.</p>
<h3 id="cargo-auditable"><a class="header" href="#cargo-auditable">cargo-auditable</a></h3>
<p><a href="https://github.com/rust-secure-code/cargo-auditable">cargo-auditable</a> can optionally be used to embed dependency information into your Rust binaries, making it possible for users to check your binaries for the full dependency tree they were built from along with their precise versions. This information can then be checked later to scan your binary for any known vulnerabilities using the <a href="https://github.com/rustsec/rustsec/tree/main/cargo-audit#cargo-audit-bin-subcommand">cargo-audit</a> tool. For more information about using this feature, see <a href="supplychain-security/../reference/config.html#cargo-auditable">the config documentation</a>.</p>
<h2 id="software-identification"><a class="header" href="#software-identification">Software identification</a></h2>
<p>dist can optionally generate an <a href="https://omnibor.io">OmniBOR artifact ID</a> for software artifacts using the <a href="https://github.com/omnibor/omnibor-rs/tree/main/omnibor-cli">omnibor-cli</a> tool. These identifiers are reproducible and unique to a specific version of your software. For more information about using this feature, see <a href="supplychain-security/../reference/config.html#omnibor">the config documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-artifact-signing-with-sslcom-certificates"><a class="header" href="#windows-artifact-signing-with-sslcom-certificates">Windows Artifact Signing with SSL.com Certificates</a></h1>
<blockquote>
<p>since 0.15.0</p>
</blockquote>
<p>dist can automatically codesign Windows EXEs and <a href="supplychain-security/signing/../../installers/msi.html">MSIs</a> using SSL.com's <a href="https://www.ssl.com/esigner/">eSigner cloud signing service</a>.</p>
<p>Although there are many ways to do code signing, this process is specifically concerned with ensuring <a href="https://learn.microsoft.com/en-us/windows/security/operating-system-security/virus-and-threat-protection/microsoft-defender-smartscreen/">Windows SmartScreen</a> recognizes the authenticity of the signatures and doesn't prevent your users from running the application. Otherwise, any user who <a href="https://en.wikipedia.org/wiki/Mark_of_the_Web">downloads your application with a web browser</a> will get a popup warning them against running it. (Alternative methods of downloading and installing, such as <a href="supplychain-security/signing/../../installers/powershell.html">dist's powershell installers</a> do not trigger SmartScreen.)</p>
<p>Windows code signing is done using essentially the same certificate infrastructure as HTTPS, just with stricter requirements on issuance and management of the private keys. In principle this means you can go to your favourite SSL/TLS Certificate vendor and ask for an EV Code Signing Certificate and follow the same process regardless of which vendor you picked. <strong>However <a href="https://knowledge.digicert.com/alerts/code-signing-changes-in-2023">as of July 2023</a>, all the relevant kinds of code signing certificates can only be issued via hardware security modules (HSMs) like Yubikeys.</strong> This poses a significant challenge for CI/CD pipelines, because you can't just plug a USB key into GitHub CI.</p>
<p>Although this will hopefully improve in the future, for now this has resulted in a fragmented system where each certificate vendor has its own cloud signing service where they host the HSMs and you send them the things you want signed. As a result it's no longer possible to provide a reasonable <em>generic</em> Windows code signing workflow, so for now we've made ours specific to one vendor: <a href="https://www.ssl.com/">SSL.com</a>.</p>
<p>Want support for another vendor? <a href="mailto:hello@axo.dev">Drop us a line</a> or <a href="https://github.com/axodotdev/cargo-dist/issues">file an issue</a>.</p>
<h2 id="quickstart-1"><a class="header" href="#quickstart-1">Quickstart</a></h2>
<h3 id="part-1-create-an-sslcom-certificate-real-or-sandbox"><a class="header" href="#part-1-create-an-sslcom-certificate-real-or-sandbox">Part 1: Create an SSL.com certificate (real or sandbox)</a></h3>
<ol>
<li>
<p><strong>Make an account and order your certificate</strong></p>
<p>Go to https://ssl.com/ (or https://sandbox.ssl.com for the testing sandbox) and log into your account. Then go to "Dashboard &gt; developer tools", and order "ESIGNER EV CODE SIGNING (360)".</p>
<p>If you are using a sandbox account, you may need to email support several times to have your test certificate validated <em>and</em> issued. The resulting certificate and signatures won't be trusted by Windows, but you can at least test things before buying a certificate.</p>
</li>
<li>
<p><strong>Enroll in eSigner Cloud Signing</strong></p>
<p>Go to "Orders &gt; documents &gt; certificate details": You should see a prompt to a enter and confirm a PIN to setup an OTP login.</p>
<p><strong>BE SURE TO SAVE THE TOTP SECRET CODE THAT APPEARS UNDER THE QR CODE FOR YOUR OTP APP, YOUR CI WILL NEED THIS.</strong></p>
<p><img src="supplychain-security/signing/../../img/signing-totp.png" alt="" /></p>
</li>
<li>
<p><strong>Get your credential ID</strong></p>
<p>On the same page as the previous step open "signing credentials" and copy the "eSigner credential ID". The credential ID will be used in CI to identify which certificate to use.</p>
<p><img src="supplychain-security/signing/../../img/signing-cred-id.png" alt="" /></p>
</li>
<li>
<p><strong>(optional) Disable malware blocker</strong></p>
<p>In the same "signing credentials" section as the previous step, you may want to disable the "malware blocker".</p>
<p>SSL.com's cloud signing provides an <a href="https://www.ssl.com/guide/how-to-use-pre-signing-malware-scan-with-ssl-com-esigner/">optional malware checking service</a> which you may want to disable in your account settings. The purpose of this feature is to mitigate the risk of your infrastructure being compromised and being used to sign malware, by essentially giving SSL.com permission to refuse to sign suspicious-looking binaries.</p>
<p>When publishing from environments like GitHub CI, there isn't much room for such a compromise to occur that wouldn't just compromise your SSL.com account anyway, so the benefits are unclear compared to the risk of your releases randomly failing due to a false positive.</p>
</li>
<li>
<p><strong>Add <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">GitHub Secrets</a> to your repository</strong></p>
<ul>
<li><code>SSLDOTCOM_USERNAME</code>: the username of your ssl.com account</li>
<li><code>SSLDOTCOM_PASSWORD</code>: the password to your ssl.com account</li>
<li><code>SSLDOTCOM_TOTP_SECRET</code>: this is the totp "secret code" from Step 2</li>
<li><code>SSLDOTCOM_CREDENTIAL_ID</code>: this is the "credential id" from Step 3</li>
</ul>
<p>For reference, the <a href="https://www.ssl.com/how-to/cloud-code-signing-integration-with-github-actions/">SSL.com documentation for their official GitHub Action</a> uses the names: ES_USERNAME, ES_PASSWORD, ES_TOTP_SECRET, and CREDENTIAL_ID for these values. The â€œESâ€ stands for â€œesignâ€. We renamed these variables to make them more specific and clear.</p>
</li>
</ol>
<h3 id="part-2-enable-sslcom-signing-with-dist"><a class="header" href="#part-2-enable-sslcom-signing-with-dist">Part 2: Enable SSL.com signing with dist</a></h3>
<ol>
<li>
<p><strong>Configure dist to codesign</strong></p>
<p>Add the following to your <code>Cargo.toml</code> or <code>dist.toml</code>:</p>
<pre><code class="language-toml">[workspace.metadata.dist]
ssldotcom-windows-sign = "prod"  # or "test" if you are using a sandbox account
</code></pre>
</li>
<li>
<p><strong>Run <code>dist init</code> on your project</strong></p>
<p>You've already fully configured the feature, we're just ensuring your config changes are applied and checked.</p>
</li>
<li>
<p><strong>You're done!</strong></p>
<p>The simplest way to test your signing out is to cut a (pre)release, but <a href="https://axodotdev.github.io/cargo-dist/book/ci/github.html#build-and-upload-artifacts-on-every-pull-request">you can also build the artifacts in a pull request</a>.</p>
<p>If everything worked, all windows binaries and MSIs should now be signed with your certificate. If you used real certificates, you can test this by downloading the windows .zip for your app with your browser and double-clicking it in your file explorer. If you get no message that "Windows protected your PC", it worked!</p>
<p>If you used a sandbox (test) certificate, SmartScreen won't acknowledge the code signing at all, but you should be able to see a "Digital Signatures" entry in the properties of the file:</p>
<p><img src="supplychain-security/signing/../../img/signing-properties.png" alt="" /></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-artifact-attestations"><a class="header" href="#github-artifact-attestations">GitHub Artifact Attestations</a></h1>
<p>GitHub's <a href="https://github.blog/2024-05-02-introducing-artifact-attestations-now-in-public-beta/">Artifact Attestations</a> feature - currently in public beta - allows for the creation of a tamper-proof, unforgeable paper trail linking build artifacts to the process which created it. Artifact Attestations is powered by <a href="https://www.sigstore.dev/">Sigstore</a>, an open source project for signing and verifying software artifacts.</p>
<p>Artifact Attestations is disabled by default in <code>dist</code>, and can be enabled by <a href="supplychain-security/attestations/../../reference/config.html#github-attestations">setting <code>github-attestations = true</code></a></p>
<p>Note that GitHub's Artifact Attestations only supports public repositories and private repositories of an organization with the GitHub Enterprise plan. In the case of public repositories, attestations generated by GitHub Actions will be written to the Sigstore Public Good Instance and end up on <a href="https://docs.sigstore.dev/logging/overview/">Rekor</a>, Sigstore's immutable ledger, for public verification.</p>
<p>Currently, verification of GitHub Artifact Attestations is only supported via GitHub CLI with <a href="https://cli.github.com/manual/gh_attestation_verify"><code>gh attestation verify</code></a>.</p>
<p>The phase in which attestations occur can be configured using the <a href="supplychain-security/attestations/../../reference/config.html#github-attestations-phase"><code>github-attestations-phase</code> setting</a>. By default, attestations occur during the <code>build-local-artifacts</code> phase. This can be changed to the <code>host</code> or <code>announce</code> phase, which is particularly useful when <code>build-local-artifacts</code> is set to <code>false</code>.</p>
<p>When performing attestations in the <code>host</code> or <code>announce</code> phase, you can control what gets attested by using the <a href="supplychain-security/attestations/../../reference/config.html#github-attestations-filters"><code>github-attestations-filters</code> setting</a>.</p>
<p>This setting yields the following attestation step by default:</p>
<pre><code class="language-yaml">- name: Attest
  uses: actions/attest-build-provenance@v2
  with:
    subject-path: |
      artifacts/*
</code></pre>
<p>When set to a different set of values such as <code>github-attestations-filters = ["*.json", "*.sh", "*.ps1", "*.zip", "*.tar.gz"]</code> it yields:</p>
<pre><code class="language-yaml">- name: Attest
  uses: actions/attest-build-provenance@v2
  with:
    subject-path: |
      artifacts/*.json
      artifacts/*.sh
      artifacts/*.ps1
      artifacts/*.zip
      artifacts/*.tar.gz
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installers"><a class="header" href="#installers">Installers</a></h1>
<p>The core functionality of dist is to build your binaries and produce <a href="installers/../artifacts/archives.html">tarballs / zips</a> containing them. Basically every other kind of output it produces is considered an "installer" that helps download/install/run those binaries.</p>
<p>Note that we use the term "installer" very loosely -- if it's fancier than a tarball, it's an installer to us!</p>
<h2 id="supported-installers"><a class="header" href="#supported-installers">Supported Installers</a></h2>
<p>Currently supported installers include:</p>
<ul>
<li><a href="installers/./shell.html">shell</a>: a shell script that fetches and installs executables (for <code>curl | sh</code>)</li>
<li><a href="installers/./powershell.html">powershell</a>: a powershell script that fetches and installs executables (for <code>irm | iex</code>)</li>
<li><a href="installers/./npm.html">npm</a>: an npm project that fetches and runs executables (for <code>npx</code>)</li>
<li><a href="installers/./homebrew.html">homebrew</a>: a Homebrew formula that fetches and installs executables</li>
<li><a href="installers/./msi.html">msi</a>: a Windows msi that bundles and installs executables</li>
</ul>
<p>These keys can be specified via <a href="installers/../reference/config.html#installers"><code>installer</code> in your dist config</a>. The <a href="installers/../reference/cli.html#dist-init"><code>dist init</code> command</a> provides an interactive UI for enabling/disabling them.</p>
<p>The above installers can have one of two strategies: <em>fetching</em> and <em>bundling</em> (defined below). Currently each installer is hardcoded to one particular strategy, but in the future <a href="https://github.com/axodotdev/cargo-dist/issues/450">we may make it configurable</a>.</p>
<h2 id="future-installers"><a class="header" href="#future-installers">Future Installers</a></h2>
<p>The following installers have been requested, and we're open to supporting them, but we have no specific timeline for when they will be implemented. Providing additional info/feedback on them helps us prioritize the work:</p>
<ul>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/365">linux docker image containing binaries</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/25">linux flatpak</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/309">macOS cask</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/24">macOS dmg / app</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/86">pypi package</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/87">windows winget package</a></li>
</ul>
<h2 id="fetching-installers"><a class="header" href="#fetching-installers">Fetching Installers</a></h2>
<p>Fetching installers are thin wrappers which detect the user's current platform and download and unpack the appropriate <a href="installers/../artifacts/archives.html">archive</a> from a server.</p>
<p>In exchange for requiring <a href="installers/../reference/artifact-url.html">a well-defined Artifact URL</a> and an internet connection at install-time, this strategy gives you a simple and efficient way to host prebuilt binaries and make sure that all users get the same binaries regardless of how the installed your application.</p>
<p>Fetching installers are also easy to make "universal" (cross-platform), so your installing users don't need to care about the OS or CPU they're using -- the installer will handle that for them.</p>
<p>Installers which support fetching:</p>
<ul>
<li><a href="installers/./shell.html">shell</a>: a shell script that fetches and installs executables (for <code>curl | sh</code>)</li>
<li><a href="installers/./powershell.html">powershell</a>: a powershell script that fetches and installs executables (for <code>irm | iex</code>)</li>
<li><a href="installers/./npm.html">npm</a>: an npm project that fetches and runs executables (for <code>npx</code>)</li>
<li><a href="installers/./homebrew.html">homebrew</a>: a Homebrew formula that fetches and installs executables</li>
</ul>
<h2 id="bundling-installers"><a class="header" href="#bundling-installers">Bundling Installers</a></h2>
<p>Bundling installers contain the actual binaries they will install on the user's system.</p>
<p>These installers can work without any internet connection, which some users will demand or appreciate.</p>
<p>Bundling requires a fundamental compromise when it comes to "universal" (cross-platform) installers, as any installer that wants to support e.g. <a href="https://github.com/axodotdev/cargo-dist/issues/77">Intel macOS and Apple Silicon macOS</a> will need to include both binaries, even if only one will ever be used.</p>
<p>For this reason all bundling installers are currently single-platform, requiring the installing user to know what platform they're on.</p>
<p>Installers which support bundling:</p>
<ul>
<li><a href="installers/./msi.html">msi</a>: a Windows msi that bundles and installs executables</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Our installers are meant to be usable as-is, without requiring any special options or configuration from the user. We do offer some optional configuration options for end users; see the <a href="installers/./usage.html">usage</a> documentation for a description of all supported options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-script-installer"><a class="header" href="#shell-script-installer">Shell Script Installer</a></h1>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>The "shell" installer provides a shell script (my-app-installer.sh) which detects the current platform, fetches the best possible <a href="installers/../artifacts/archives.html">archive</a> from your <a href="installers/../reference/artifact-url.html">Artifact URL</a>, copies the binary into your <a href="installers/../reference/config.html#install-path">install-path</a>, and attempts to add that path to the user's PATH (see the next section for details).</p>
<p>This kind of installer is ideal for bootstrapping setup on a fairly bare-bones system.</p>
<p>An "installer hint" will be provided that shows how to install via <code>curl | sh</code>, like so:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.sh | sh
</code></pre>
<p>Limitations/Caveats:</p>
<ul>
<li>Requires a well-defined <a href="installers/../reference/artifact-url.html">Artifact URL</a></li>
<li>Currently only really designed for "linux" and "macOS", and won't detect other platforms properly (and certainly won't play nice with things like nixOS).</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">Cannot detect situations where musl-based builds are appropriate</a> (static or dynamic)</li>
<li>Relies on the user's installation of <code>tar</code> and <code>unzip</code> to unpack the files</li>
<li>Relies on the the user's installation of <code>curl</code> or <code>wget</code> to fetch the files</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/307">Will throw out all files except for the binary, so the binary can't rely on assets included in the archive</a></li>
<li>Cannot run any kind of custom install logic</li>
</ul>
<p>In an ideal world all of these caveats improve (except for maybe relying on tar/unzip/curl/wget, that's kinda fundamental).</p>
<h2 id="adding-things-to-path"><a class="header" href="#adding-things-to-path">Adding things to PATH</a></h2>
<p>Here is a more fleshed out description of how the shell installer attempts to add the <a href="installers/../reference/config.html#install-path">install-path</a> to the user's PATH, and the limitations of that process.</p>
<p>The most fundamental limitation is that installers fundamentally cannot edit the PATH of the currently running shell (it's a parent process). Only an explicit <code>source some_file</code> (or the more portable <code>. some_file</code>) can do that. As such, it benefits an installer to try to install to a directory that will already be on PATH (such as <a href="https://doc.rust-lang.org/cargo/guide/cargo-home.html">CARGO_HOME</a>). Otherwise all we can do is prompt the user to run <code>source</code> themselves after the installer has run (or restart their shell to freshly source rcfiles).</p>
<p>The process we use to add <a href="installers/../reference/config.html#install-path">install-path</a> to the user's PATH is roughly the same process that rustup uses (hopefully making us harmonious with running rustup before/after one of our installer scripts). In the following description we will use <code>$install-path</code> as a placeholder for the path computed at install-time where the binaries get installed. Its actual value will likely look something like <code>$HOME/.myapp</code> or <code>$HOME/.cargo/bin</code>.</p>
<ul>
<li>we generate a shell script and write it to <code>$install-path/env</code> (let's call this <code>$env-path</code>)
<ul>
<li>the script checks if <code>$install-path</code> is in PATH already, and prepends it if not</li>
<li>prepending is used to ideally override system-installed binaries, as that is assumed to be desired when explicitly installing with not-your-system-package-manager</li>
<li>the <code>env</code> script will only be added if it doesn't already exist</li>
<li>if <code>install-path = "CARGO_HOME"</code>, then <code>$env-path</code> will actually be in the parent directory, mirroring the behaviour of rustup</li>
</ul>
</li>
<li>we add <code>. $env-path</code> to <code>$HOME/.profile</code>
<ul>
<li>this is just a more portable version of <code>source $install-path/env</code></li>
<li>this line will only be added if it doesn't exist (we also check for the <code>source</code> equivalent)</li>
<li>the file is created if it doesn't exist</li>
<li><a href="https://github.com/rust-lang/rustup/blob/bcfac6278c7c2f16a41294f7533aeee2f7f88d07/src/cli/self_update/shell.rs#L70-L76">rustup shotgun blasts this line into many more files like .bashrc and .zshenv</a>, while still <a href="https://github.com/rust-lang/rustup/issues/478">lacking proper support for fish</a> and other more obscure shells -- we opted to start conservative with just .profile</li>
</ul>
</li>
<li>if <code>$HOME/.profile</code> was edited, we prompt the user to <code>source "$env-path"</code> or restart their shell
<ul>
<li>although this is less portable than <code>. "$env-path"</code>, it's very easy to misread/miscopy the portable version (not as much of a concern for an rcfile, but an issue for humans)</li>
<li>hopefully folks on platforms where this matters are aware of this issue (or they can restart their shell)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="powershell-script-installer"><a class="header" href="#powershell-script-installer">PowerShell Script Installer</a></h1>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>This provides a powershell script (my-app-installer.ps1) which detects the current platform, fetches the best possible <a href="installers/../artifacts/archives.html">archive</a> from your <a href="installers/../reference/artifact-url.html">Artifact URL</a>, copies the binary into your <a href="installers/../reference/config.html#install-path">install-path</a>, and attempts to add that path to the user's PATH (see the next section for details).</p>
<p>This kind of installer is ideal for bootstrapping setup on a fairly bare-bones system.</p>
<p>An "installer hint" will be provided that shows how to install via <code>irm | iex</code> (the windows equivalent of <code>curl | sh</code>), like so:</p>
<pre><code class="language-sh">powershell -c "irm https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.ps1 | iex"
</code></pre>
<p>Limitations/Caveats:</p>
<ul>
<li>Requires a well-defined <a href="installers/../reference/artifact-url.html">Artifact URL</a></li>
<li>Currently only really designed for "native windows", and won't detect other platforms properly</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">Cannot detect situations where musl-based builds are appropriate</a> (static or dynamic)</li>
<li>Relies on the user's installation of <code>tar</code> and <code>Expand-Archive</code> to unpack the files</li>
<li>Relies on the the user's installation of <code>Net.Webclient</code> to fetch the files</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/307">Will throw out all files except for the binary, so the binary can't rely on assets included in the archive</a></li>
<li>Cannot run any kind of custom install logic</li>
</ul>
<p>On the scale of Windows (where many people are still running Windows 7) commands like "Expand-Archive" and "tar" are in fact relatively new innovations. Any system that predates 2016 (PowerShell 5.0) certainly has no hope of working. I believe that someone running Windows 10 is basically guaranteed to work, and anything before that gets sketchier.</p>
<p>In an ideal world most of these caveats improve (except for maybe the requirement of PowerShell &gt;= 5.0 which is not pleasant to push past).</p>
<h2 id="adding-things-to-path-1"><a class="header" href="#adding-things-to-path-1">Adding things to PATH</a></h2>
<p>Here is a more fleshed out description of how the powershell installer attempts to add the <a href="installers/../reference/config.html#install-path">install-path</a> to the user's PATH, and the limitations of that process.</p>
<p>The most fundamental limitation is that installers fundamentally cannot edit the PATH of the currently running shell (it's a parent process). Powershell does not have an equivalent of <code>source</code>, so to the best of our knowledge restarting the shell is the only option (which if using Windows Terminal seems to mean opening a whole new window, tabs aren't good enough). As such, it benefits an installer to try to install to a directory that will already be on PATH (such as <a href="https://doc.rust-lang.org/cargo/guide/cargo-home.html">CARGO_HOME</a>).</p>
<p>The process we use to add <a href="installers/../reference/config.html#install-path">install-path</a> to the user's PATH is roughly the same process that rustup uses (hopefully making us harmonious with running rustup before/after one of our installer scripts). In the following description we will use <code>$install-path</code> as a placeholder for the path computed at install-time where the binaries get installed. Its actual value will likely look something like <code>C:\Users\axo\.myapp</code> or <code>C:\Users\.cargo\bin</code>.</p>
<ul>
<li>we load from the registry <code>HKCU:\Environment</code>'s "Path" Item</li>
<li>we check if <code>$install-path</code> is contained within it already</li>
<li>if not, we prepend it and write the value back
<ul>
<li>prepending is used to ideally override system-installed binaries, as that is assumed to be desired when explicitly installing with not-your-system-package-manager</li>
<li>the value is written back with a <code>REG_EXPAND_SZ</code> data type, which enables PATH expansion</li>
</ul>
</li>
<li>if we edited the registry, we prompt the user to restart their shell
<ul>
<li>we additionally broadcast <code>WM_SETTINGCHANGE</code> to running programs to ensure that environment updates are propagated. This ensures you only need to restart your shell, rather than your entire machine, for the "Path" update to be recognized.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="npm-installer"><a class="header" href="#npm-installer">npm Installer</a></h1>
<blockquote>
<p>since 0.0.6</p>
</blockquote>
<p>dist can automatically build and publish <a href="https://www.npmjs.com/">npm</a> packages for your applications. Users can install your application with an expression like <code>npm install -g @axodotdev/axolotlsay</code>, or immediately run it with <code>npx @axodotdev/axolotlsay</code>.</p>
<p>The npm package will <a href="installers/../reference/artifact-url.html">fetch</a> your prebuilt <a href="installers/../artifacts/archives.html">archives</a> and install your binaries to node_modules, exposing them as commands ("bins") of the package.
If the package <a href="https://docs.npmjs.com/cli/v7/commands/npx#description">unambiguously has one true command</a>, then the package can be run without specifying one.</p>
<p>Note that this is <em>not</em> (yet) a feature for publishing an npm package in your workspace. The package described here is generated as part of your release process.</p>
<p>An "installer hint" will be provided that shows how to install via <code>npm</code> like so:</p>
<pre><code class="language-sh">npm install @axodotdev/cargodisttest@0.2.0
</code></pre>
<h2 id="quickstart-2"><a class="header" href="#quickstart-2">Quickstart</a></h2>
<p>To setup your npm installer you need to create an npm access token and enable the installer. This is broken up into parts because a project administrator may need to be involved in part 1, while part 2 can be done by anyone.</p>
<h3 id="part-1-creating-an-npm-account-and-optional-scope-and-authenticating-github-actions"><a class="header" href="#part-1-creating-an-npm-account-and-optional-scope-and-authenticating-github-actions">Part 1: Creating an npm account and optional scope and authenticating GitHub Actions</a></h3>
<ol>
<li>
<p>Create an account on <a href="https://www.npmjs.com/signup">npmjs.com</a>.</p>
</li>
<li>
<p>(Optionally) If you would like to publish a "scoped" package (aka <code>@mycorp/pkg</code>) you'll need to <a href="https://www.npmjs.com/org/create">create an npm organization</a>.</p>
</li>
<li>
<p>Go to your npm account settings and create a granular access token:</p>
<ul>
<li>Expiration: The default is 30 days. You can pick what works for you and your team. (NOTE: If you really want a token that does not expire you can use a Classic Token but we expect that option to eventually be fully deprecated in the near future.)</li>
<li>Packages and scopes: Read and write
<ul>
<li>Select packages: All packages (NOTE: because the package does not yet exist, you must pick this. However, you can (and probably should!) update this to scope the token to a single package after publish. This is sadly a limitation of the npm token system.)</li>
</ul>
</li>
<li>Organizations: No access</li>
</ul>
</li>
<li>
<p>Add the token as a <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">GitHub Actions Secret</a> called <code>NPM_TOKEN</code> to the repository your are publishing from.</p>
</li>
</ol>
<h3 id="part-2-enabling-the-npm-installer"><a class="header" href="#part-2-enabling-the-npm-installer">Part 2: Enabling The npm Installer</a></h3>
<ol>
<li>run <code>dist init</code> on your project</li>
<li>when prompted to pick installers, enable "npm"</li>
<li>this should trigger a prompt for your optional scope (<code>@axodotdev</code>)</li>
</ol>
<p>...that's it! If this worked, your config should now contain the following entries:</p>
<pre><code class="language-toml">[workspace.metadata.dist]
# "..." indicates other installers you may have selected
installers = ["...", "npm", "..."]
# if you did not provide a scope, this won't be present
npm-scope = "@axodotdev"
publish-jobs = ["npm"]
</code></pre>
<p>Next make sure that <code>description</code> and <code>homepage</code> are set in your Cargo.toml. These
fields are optional but make for better npm packages.</p>
<pre><code class="language-toml">[package]
description = "a CLI for learning to distribute CLIs in rust"
homepage = "https://github.com/axodotdev/axolotlsay"
</code></pre>
<h2 id="renaming-npm-packages"><a class="header" href="#renaming-npm-packages">Renaming npm packages</a></h2>
<blockquote>
<p>since 0.14.0</p>
</blockquote>
<p>By default the name of the npm package will be the name of the package that defines it (your Cargo package). If for whatever reason you don't want that to be the case, then you can change it with the <a href="installers/../reference/config.html#npm-package">npm-package setting</a>.</p>
<p>So with these settings:</p>
<pre><code class="language-toml">[package]
name = "axolotlsay"

[package.metadata.dist]
npm-scope = "@axodotdev"
npm-package = "cli"
</code></pre>
<p>You'll end up publish the binaries in "axolotlsay" to an npm package called "@axodotdev/cli".</p>
<h2 id="locked-dependencies"><a class="header" href="#locked-dependencies">Locked dependencies</a></h2>
<blockquote>
<p>since 0.31.0</p>
</blockquote>
<p>The npm package has a few module dependencies which are used to fetch your binary after the package itself is installed. By default, these dependencies are locked via an <code>npm-shrinkwrap.json</code>, so your end users will use the exact versions used by dist at the time the package was generated. If you prefer, you can disable <code>npm-shrinkwrap.json</code> so that your end users may end up using newer versions of these packages instead. For example:</p>
<pre><code class="language-toml">[package]
name = "axolotlsay"

[package.metadata.dist]
npm-shrinkwrap = false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="homebrew-installer"><a class="header" href="#homebrew-installer">Homebrew Installer</a></h1>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>dist can automatically build and publish <a href="https://brew.sh">Homebrew</a> formulae (packages) for your application. Users can install your application with an expression like <code>brew install axodotdev/tap/axolotlsay</code> and automatically get updates whenever they update their Homebrew packages.</p>
<p>The homebrew package will <a href="installers/../reference/artifact-url.html">fetch</a> your prebuilt <a href="installers/../artifacts/archives.html">archives</a>, and install the contents in the traditional homebrew directory structure.</p>
<p><em>Building</em> a formula is pretty straight-forward, but publishing it requires you to create a your own <a href="https://docs.brew.sh/Taps">Homebrew tap</a> (package repository), because <a href="https://github.com/Homebrew/homebrew-core">the core Homebrew tap</a> does not accept prebuilt binaries from third parties. This sounds hard, but surprisingly it's not: you need to make a repository named "homebrew-tap" under your GitHub org or user, and get a GitHub API token to push to it. dist will manage the contents of the repo for you.</p>
<h2 id="quickstart-3"><a class="header" href="#quickstart-3">Quickstart</a></h2>
<p>To setup your homebrew installer you need to create a custom tap and enable the installer. This is broken up into parts because a project administrator may need to be involved in part 1, while part 2 can be done by anyone.</p>
<h3 id="part-1-creating-a-custom-homebrew-tap"><a class="header" href="#part-1-creating-a-custom-homebrew-tap">Part 1: Creating A Custom Homebrew Tap</a></h3>
<ol>
<li>Create a GitHub repository called "homebrew-tap" (<code>axodotdev/homebrew-tap</code>)</li>
<li>Create a GitHub <a href="https://github.com/settings/tokens/new?scopes=repo">personal access token</a> with the <code>repo</code> scope</li>
<li>Add the token as a <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">GitHub Secret</a> called <code>HOMEBREW_TAP_TOKEN</code> to the repository you want to publish <strong>from</strong> (<code>axodotdev/axolotlsay</code>)</li>
</ol>
<p>We recommend initializing the repository with a README, but otherwise the directory structure will be managed by dist, and many separate repos can publish to the same tap without issue.</p>
<p>A Homebrew Tap is just a GitHub repository that starts with <code>homebrew-</code>. Many homebrew features allow that prefix to be elided, so the package <code>axolotlsay</code> published in <code>axodotdev/homebrew-tap</code>, can be installed as <code>axodotdev/tap/axolotlsay</code>. Your users don't need to "register" anything to use it, custom taps are just that builtin to Homebrew.</p>
<h3 id="part-2-enabling-the-homebrew-installer"><a class="header" href="#part-2-enabling-the-homebrew-installer">Part 2: Enabling The Homebrew Installer</a></h3>
<ol>
<li>run <code>dist init</code> on your project</li>
<li>when prompted to pick installers, enable "homebrew"</li>
<li>this should trigger a prompt for your tap (<code>axodotdev/homebrew-tap</code>)</li>
</ol>
<p>...that's it! Assuming you already setup your custom tap, as described in the previous section. If this worked, your config should now contain the following entries:</p>
<pre><code class="language-toml">[workspace.metadata.dist]
# "..." indicates other installers you may have selected
installers = ["...", "homebrew", "..."]
tap = "axodotdev/homebrew-tap"
publish-jobs = ["homebrew"]
</code></pre>
<p>Next make sure that <code>description</code> and <code>homepage</code> are set in your Cargo.toml. These
fields are optional but make for better formula definitions.</p>
<pre><code class="language-toml">[package]
description = "a CLI for learning to distribute CLIs in rust"
homepage = "https://github.com/axodotdev/axolotlsay"
</code></pre>
<h2 id="renaming-formulae"><a class="header" href="#renaming-formulae">Renaming Formulae</a></h2>
<blockquote>
<p>since 0.11.0</p>
</blockquote>
<p>By default, your formula will be named using the app name (in Rust, this is the crate
name). If you are overriding the bin name, you may want to make your Homebrew formula
match <a href="installers/../reference/config.html#formula">with the <code>formula</code> setting</a>:</p>
<pre><code class="language-toml">[package]
name = "legacyname"

[[bin]]
name = "coolname"
path = "src/main.rs"

[package.metadata.dist]
formula = "coolname"
</code></pre>
<h2 id="adding-binary-aliases"><a class="header" href="#adding-binary-aliases">Adding Binary Aliases</a></h2>
<blockquote>
<p>since 0.14.0</p>
</blockquote>
<p>If you want to install symlinked aliases for your binaries, you can do so with the <a href="installers/../reference/config.html#bin-aliases">bin-aliases setting</a>.</p>
<h2 id="linuxbrew"><a class="header" href="#linuxbrew">Linuxbrew</a></h2>
<blockquote>
<p>since 0.6.0</p>
</blockquote>
<p>The formulae dist builds automatically support Linux and macOS, as long as you release your application for the relevant targets.</p>
<h2 id="limitations--caveats"><a class="header" href="#limitations--caveats">Limitations / Caveats</a></h2>
<h3 id="there-is-only-one-version"><a class="header" href="#there-is-only-one-version">There Is Only One Version</a></h3>
<p><strong>Homebrew fundamentally does not support the notion of a package having multiple published versions.</strong> There is <em>only</em> the latest version. <strong>If you publish a new version of a package, it will always replace the current one.</strong> This is why <a href="installers/../reference/config.html#publish-prereleases">the <code>publish-prereleases</code> setting is disabled by default</a>: otherwise publishing 2.0.0-prerelease.1 would completely obliterate 1.0.0, which presumably you'd prefer users installing.</p>
<p>Unfortunately if you have any kind of non-linear version history (such as doing a patch release for 1.0 after already releasing 2.0), the published Homebrew package will randomly contain whichever one you released last. The releases are just git commits though, so you can manually revert a release if you want.</p>
<h3 id="unsupported-formats"><a class="header" href="#unsupported-formats">Unsupported Formats</a></h3>
<ul>
<li>Does not support creating a formula which builds from source</li>
<li>Does not support <a href="https://github.com/axodotdev/cargo-dist/issues/309">Cask</a> for more convenient GUI app installation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msi-installer"><a class="header" href="#msi-installer">msi Installer</a></h1>
<blockquote>
<p>Since 0.3.0</p>
</blockquote>
<ul>
<li><a href="installers/msi.html#setup">Setup</a>
<ul>
<li><a href="installers/msi.html#setup-step-1-set-authors-in-your-cargotoml">Setup Step 1: set "authors" in your Cargo.toml</a></li>
<li><a href="installers/msi.html#setup-step-2-run-init-and-enable-msi">Setup Step 2: run init and enable "msi"</a></li>
<li><a href="installers/msi.html#setup-step-3-youre-done-time-to-test">Setup Step 3: you're done! (time to test)</a></li>
</ul>
</li>
<li><a href="installers/msi.html#how-it-works">How It Works</a></li>
<li><a href="installers/msi.html#advanced-usage">Advanced Usage</a>
<ul>
<li><a href="installers/msi.html#managed-advanced-usage">Managed Advanced Usage</a></li>
<li><a href="installers/msi.html#unmanaged-advanced-usage">Unmanaged Advanced Usage</a></li>
</ul>
</li>
</ul>
<p>This guide will walk you through setting up a <a href="installers/./index.html#bundling-installers">bundling</a> Windows msi installer. It assumes you've already done initial setup of dist, as described in <a href="installers/../quickstart/index.html">the way-too-quickstart</a>, and now want to add an msi to your release process.</p>
<p>(Just a bit of a warning, this stuff works but there's a few rough edges, please let us know if you run into any issues!)</p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<p>We'll start with the bare-minimum and then explain what we did and how to modify it afterwards.</p>
<h3 id="setup-step-1-set-authors-in-your-cargotoml"><a class="header" href="#setup-step-1-set-authors-in-your-cargotoml">Setup Step 1: set "authors" in your Cargo.toml</a></h3>
<p>msi requires you to specify a "manufacturer" for you application, which is by default sourced from the "authors" field in you Cargo.toml. <strong>If you donâ€™t have that field set, the next step will error out.</strong> If you have an authors entry like <code>My Cool Company &lt;support@mycoolcompany.org&gt;</code> then the manufacturer will be "My Cool Company".</p>
<h3 id="setup-step-2-run-init-and-enable-msi"><a class="header" href="#setup-step-2-run-init-and-enable-msi">Setup Step 2: run init and enable "msi"</a></h3>
<p>Rerun <code>dist init</code> and when it prompts you to choose installers, enable "msi".</p>
<p>Once init completes, some changes will be made to your project, <strong>check all of them in</strong>:</p>
<ol>
<li><code>installers = ["msi"]</code> will be added to <code>[workspace.metadata.dist]</code></li>
<li><code>[package.metadata.wix]</code> will be added to your packages with distable binaries. This is your msi-specific config. For now don't worry about it.</li>
<li><code>wix/main.wxs</code> will be created for each of your packages with distable binaries. This is a template for your msi. For now assume this file is completely managed by dist, and can't be hand-edited.</li>
</ol>
<h3 id="setup-step-3-youre-done-time-to-test"><a class="header" href="#setup-step-3-youre-done-time-to-test">Setup Step 3: you're done! (time to test)</a></h3>
<p>See <a href="installers/../quickstart/rust.html#test-it-out">the quickstart's testing guide</a> for the various testing options.</p>
<p>If the above steps worked, <code>dist plan</code> should now include an msi for each Windows platform you support.</p>
<p><code>dist build</code> is a bit trickier. Not only do you have to be on Windows to get an msi built, you also need to have the <a href="https://wixtoolset.org/docs/wix3/">WiX v3 toolchain</a> installed (WiX v4 isn't yet supported). If you don't the build will just error out. In GitHub CI the WiX v3 toolchain is pre-installed, so using PR testing is recommended.</p>
<p>The resulting msi should include the following functionality:</p>
<ul>
<li>(optional) EULA dialog</li>
<li>A menu that lets you choose where to install and whether to add it to PATH
<ul>
<li>Default install location is <code>%ProgramFiles%\{app_name}\</code> (e.g. <code>C:\Program Files\axolotlsay\</code>)</li>
<li>Default is to add the install location to PATH</li>
<li>Currently the only files that will be included are the app's binaries in a <code>bin</code> subdir</li>
</ul>
</li>
<li>If rerun, you will get an uninstall/reinstall menu</li>
<li>If a newer version is run, it will automatically uninstall the old version</li>
<li>If an older version is run, it will report that a newer version is installed and exit</li>
<li>The application will appear in the Windows "Add or remove programs" menu and can be uninstalled from there</li>
</ul>
<p>Certain licenses in your Cargo.toml like "Apache" or "MIT" (but <em>not</em> dual MIT/Apache) will get an auto-generated EULA that's just agreeing to the software license -- we know, that's not how software licenses work, but people seem to like to do it. See the section on advanced usage for how to set a more useful EULA.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>As you may suspect from the setup, we rely on the industry standard <a href="https://wixtoolset.org/docs/wix3/">WiX v3 toolchain</a> to generate your msi installers (WiX v4 isn't yet supported). The <code>main.wxs</code> format is its xml-based templating system. Some of the information about your app is baked into this template (binaries, descriptions, licenses...), while other information is sourced at build time (mostly the version).</p>
<p>If the template ever desyncs from the values it was generated from, commands like <code>dist plan</code> (and therefore your pull request CI) will error out and ask you to rerun <code>dist init</code> to regenerate it.</p>
<p>The values we added to <code>[package.metadata.wix]</code> are:</p>
<ul>
<li><code>upgrade-guid = "SOME-RANDOM-GUID"</code> (since 0.3.0)</li>
<li><code>path-guid = "SOME-OTHER-RANDOM-GUID"</code> (since 0.3.0)</li>
<li><code>license = false</code> (since 0.5.0)</li>
<li><code>eula = false</code> (since 0.5.0)</li>
</ul>
<p>The two GUIDs are used by Windows to determine that two MSIs with different versions refer to the same application and install location, which is required for it to properly handle things like upgrades. They are persisted in your Cargo.toml to keep them stable across regenerations of <code>main.wxs</code>.</p>
<p>The license/EULA settings are there to disable the auto-license/EULA feature of cargo-wix. That feature <em>would</em> look at your package's license and potentially turn it into a EULA agreement. While this is a thing some folks want, most of our users aren't interested in getting their end-users to "agree to the MIT License". You can opt back into auto-EULAs by setting both of those to <code>true</code> (if you just delete the keys dist will keep adding them back as <code>false</code>).</p>
<p><strong>All of the logic for generating wxs files is part of <a href="https://volks73.github.io/cargo-wix/cargo_wix/">cargo-wix</a>, which dist includes as a library.</strong> It's a great project we happily contribute to, although some TLC is still needed to make the integration perfect (some of its warnings/errors may mention its own CLI's flags, and those sure won't work if you pass them to dist). The <code>[package.metadata.wix]</code> config is purely cargo-wix's, see <a href="https://volks73.github.io/cargo-wix/cargo_wix/">their docs for all the knobs it exposes</a>.</p>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<p>There are two paths for advanced usage: managed and unmanaged. We recommend the managed approach, but the unmanaged approach is there for true power users.</p>
<h3 id="managed-advanced-usage"><a class="header" href="#managed-advanced-usage">Managed Advanced Usage</a></h3>
<p>If you want dist to be able to keep your <code>main.wxs</code> consistent with the definitions in your Cargo.tomls, then all you have available is the knobs exposed in <code>[package.metadata.wix]</code> -- see <a href="https://volks73.github.io/cargo-wix/cargo_wix/">cargo-wix's docs for details</a>.</p>
<h3 id="unmanaged-advanced-usage"><a class="header" href="#unmanaged-advanced-usage">Unmanaged Advanced Usage</a></h3>
<p>If you're not worried about keeping <code>main.wxs</code> consistent, then you can choose to dive deep into the full power of <a href="https://wixtoolset.org/docs/wix3/">WiX v3</a> by adding <code>allow-dirty = ["msi"]</code> to your dist config. Once you do this dist will stop trying to update it, and won't check if it's out of date.</p>
<p>At that point you can make whatever hand-edits you want to main.wxs, as long as you still use the variables that cargo-wix injects into the template at build-time for things like versions and binary paths.</p>
<p>See <a href="https://wixtoolset.org/docs/wix3/">WiX v3's docs</a> for all the things their format supports.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-updater"><a class="header" href="#self-updater">Self-updater</a></h1>
<blockquote>
<p>since 0.12.0</p>
</blockquote>
<p>NOTE: This feature is currently experimental.</p>
<p>Ordinarily, your users will need to visit your website and download an installer for the latest release in order to upgrade. Users who installed your software via a package manager, like Homebrew and npm, can use that package manager to upgrade to the latest release. For users of the <a href="installers/./shell.html">shell</a> and <a href="installers/./powershell.html">PowerShell</a> installers, you can provide your users with a standalone installation program to upgrade more conveniently.</p>
<p>If you add <code>install-updater = true</code> to your <code>Cargo.toml</code>, dist's shell and PowerShell installers will include an updater program alongside your program itself. This standalone program will be installed as the name <code>yourpackage-update</code>, and users can simply run it to poll for new releases and have them installed. The source code for this program is open source in the <a href="https://github.com/axodotdev/axoupdater">axoupdater</a> repository.</p>
<p>Users will interact with this updater by running the <code>yourpackage-update</code> command. It takes no options or arguments, and will automatically perform an upgrade without further input from the user. If your program supports custom external subcommands via the executable naming structure, like <code>git</code> and <code>cargo</code> do, then your user can also run <code>yourpackage update</code>. Here's a sample <code>axolotlsay-update</code> session as a demonstration of what your users will experience:</p>
<pre><code>$ axolotlsay-update
Checking for updates...
downloading axolotlsay 0.2.114 aarch64-apple-darwin
installing to /Users/mistydemeo/.cargo/bin
  axolotlsay
  axolotlsay-update
everything's installed!
New release installed!
</code></pre>
<p>If you would prefer to handle polling for updates yourself, for example in order to incorporate it as an internal subcommand of your own software, axoupdater is available as a <a href="https://crates.io/crates/axoupdater">crate</a> which can be used as a library within your program. More information about how to use axoupdater as a library in your own program can be found in its README and in its <a href="https://docs.rs/axoupdater/">API documentation</a>.</p>
<h2 id="minimum-supported-version-checking"><a class="header" href="#minimum-supported-version-checking">Minimum supported version checking</a></h2>
<p>While dist will always fetch up to date versions of the updater when building your software, if you use axoupdater as a library then it's important to make sure that it's kept up to date to ensure compatibility. To help you test this, dist will attempt to check if the packages it's disting use axoupdater as a dependency; if it detects an unsupported, too-old version of axoupdater is in use, it will then refuse to continue to build in order to avoid distributing a package that's unsafe to update.</p>
<h2 id="github-actions-and-rate-limits-in-ci"><a class="header" href="#github-actions-and-rate-limits-in-ci">GitHub Actions and Rate Limits in CI</a></h2>
<p>By default, axoupdater uses unauthenticated GitHub API calls when fetching release information. This is reliable in normal use, but it's much more likely to run into rate limits in the highly artificial environment of a CI test. If you're testing the standalone updater in your CI configuration, we recommend setting the <code>AXOUPDATER_GITHUB_TOKEN</code> environment variable to the value of the <code>GITHUB_TOKEN</code> secret that GitHub Action defines automatically.</p>
<pre><code class="language-yaml">env:
  AXOUPDATER_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</code></pre>
<p>A sample in dist's CI configuration can be found <a href="https://github.com/axodotdev/cargo-dist/blob/80f2e19e5aa79b7b1f64beb62ceb07aa71566707/.github/workflows/ci.yml#L82-L85">here</a>.</p>
<p>If you use the axoupdater crate to implement the updater yourself, instructions for opting into a token in CI can be found <a href="https://github.com/axodotdev/axoupdater?tab=readme-ov-file#github-actions-and-rate-limits-in-ci">here</a>.</p>
<h2 id="releases-with-issues-surrounding-the-standalone-updater"><a class="header" href="#releases-with-issues-surrounding-the-standalone-updater">Releases with issues surrounding the standalone updater</a></h2>
<p>dist versions 0.21.1, 0.22.0 and 0.22.1 contain a bug which prevents the shell installer from installing the standalone updater alongside your binaries. This bug doesn't affect the PowerShell installer. Users of installers created with these releases will have had your software installed as normal, but won't have received an updater. Users whose first installation came via one of these installers will need to upgrade manually using a new shell installer.</p>
<p>Users who first installed with an installer created with an older dist will still have their updater from their original installation, and so they will be able to update as normal.</p>
<p>This issue was resolved in dist 0.23.0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-1"><a class="header" href="#usage-1">Usage</a></h1>
<p>axo's installers are designed to require no end user input - however, in many
cases, end users like the ability to tailor their installation experience. For
these users, our installers allow several inputs which give the user more
control over their installation experience via configuration. Most of these are
implemented using environment variables, however several are also available as
arguments to the installer scripts themselves.</p>
<p>This documentation is targeted at developers using <code>dist</code> to distribute their apps. If you expect your users to be interested in any of these features, we recommend incorporating the relevant information into your own installation documentation. If there's any additional documentation you'd find helpful here, please feel free to <a href="https://github.com/axodotdev/cargo-dist/issues/new">open an issue</a>!</p>
<p>Several of these options were available in earlier releases of <code>dist</code>, but they
are formally stabilized as of <code>0.23.0</code>.</p>
<h2 id="install-location"><a class="header" href="#install-location">Install location</a></h2>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>One of the most important jobs of an installer is to place the necessary
artifacts in the correct location on the target machine. <code>dist</code> allows you to
configure this for your particular needs. Depending on your setup, the following
options are available for end users to further configure this location:</p>
<ul>
<li>
<p><code>${app name}_INSTALL_DIR</code></p>
<blockquote>
<p>Replace <code>{app name}</code> with the name of the application. To transform the
app name to the env var, replace any spaces or hyphens with an underscore
and then put it in all caps. You can double check this transform by
comparing the <code>install_dir_env_var</code> value in your <code>dist-manifest.json</code>.</p>
</blockquote>
<p>This environment variable tells the installer what to use as the "base"
directory for the installation task. This may not necessarily be the exact
directory your binaries are installed to based on your install layout. For
example, this directory may have <code>./bin</code> appended to it.</p>
<p>This environment variable is also known as <code>CARGO_DIST_FORCE_INSTALL_DIR</code>.</p>
</li>
<li>
<p><code>$HOME</code></p>
<p>This environment variable is sourced if you use the <code>CARGO_HOME</code> or
<code>~/sub/dir</code> install location options. For more information, see the <a href="installers/../reference/config.html#install-path">documentation for this feature</a>.</p>
</li>
<li>
<p><code>${custom env var}</code></p>
<p>You can use a custom environment variable to specify your install
location. If you do, that variable will be sourced during the install task. For more information, see the <a href="installers/../reference/config.html#install-path">documentation for this feature</a>.</p>
</li>
<li>
<p><code>$CARGO_HOME</code></p>
<p>This environment variable is sourced if you use the <code>CARGO_HOME</code> install
location. For more information, see the <a href="installers/../reference/config.html#install-path">documentation for this feature</a>.</p>
</li>
</ul>
<h2 id="path"><a class="header" href="#path"><code>$PATH</code></a></h2>
<blockquote>
<p>since 0.1.0, path modification options updated in 0.23.0</p>
</blockquote>
<p><code>$PATH</code> is an environment variable that pre-exists on nearly all systems and
lists locations to look for executables in. This is what allows you to call a
program by its name instead of needing to call it by it's specific location on
the file system.</p>
<p>When you use axo installers, we do the heavy lifting of ensuring that your
application is available "on PATH" to your end users. On Linux and macOS, we do this by editing shell dotfiles; on Windows, we do this by editing the <code>Environment.Path</code> registry key. However, there are
circumstances where this is not desirable, and so we provide the ability to
skip this setup step.</p>
<ul>
<li>
<h3 id="path-1"><a class="header" href="#path-1"><code>$PATH</code></a></h3>
<p>This environment variable is both sourced and modified in the standard mode
of an installation. We source this variable to see if the installation
location is already on PATH and we will modify it if it is not.</p>
</li>
<li>
<h3 id="path-modification"><a class="header" href="#path-modification"><code>$PATH</code> modification</a></h3>
<p>If you do not want your PATH to be modified you can use the <code>INSTALLER_NO_MODIFY_PATH</code> environment variable to configure your installation experience.</p>
</li>
<li>
<h3 id="github_path"><a class="header" href="#github_path"><code>$GITHUB_PATH</code></a></h3>
<p>If an installer detects the presence of this environment variable
(signalling that it is running in a GitHub Actions context) our installers
will modify this environment variable to ensure that all installed
applications are immediately available on PATH.</p>
</li>
</ul>
<h2 id="artifact-location"><a class="header" href="#artifact-location">Artifact location</a></h2>
<blockquote>
<p>since 0.25.0</p>
</blockquote>
<p>Some folks, particularly those working in security-sensitive business environments,
may need to mirror artifacts within a private network. <code>dist</code> enables this usecase
by allowing end users to customize the URL that artifacts are fetched from:</p>
<ul>
<li><code>${app name}_INSTALLER_GITHUB_BASE_URL</code></li>
<li><code>${app name}_INSTALLER_GHE_BASE_URL</code></li>
</ul>
<blockquote>
<p>Replace <code>{app name}</code> with the name of the application. To transform the
app name to the env var, replace any spaces or hyphens with an underscore
and then put it in all caps. You can double check this transform by
comparing the <code>install_dir_env_var</code> value in your <code>dist-manifest.json</code>.</p>
</blockquote>
<p>These environment variables enable you to specify both a base URL and a URL
structure to the installer and updater of a project that distributes with <code>dist</code>.
When set, installers will fetch from URL constructed based on the value you set
here.</p>
<p>When setting up your mirror you'll need to both mirror the artifacts <em>and</em> provide
an endpoint that indexes the available releases (so that the updater can work).</p>
<p>To minimize complexity for both us and our end users, we have standardized our
requested API structure expectations to match either:</p>
<ul>
<li>Github.com, or
<ul>
<li>Public artifact URLs: https://{CUSTOM}/owner/repo/releases/download/version/artifact-name</li>
<li>Releases API: https://api.{CUSTOM}/repos/owner/repo/releases/latest (<a href="https://docs.github.com/en/rest/releases/releases?apiVersion=2022-11-28">docs</a>)</li>
</ul>
</li>
<li>Github Enterprise
<ul>
<li>Public artifact URLs: https://{CUSTOM}/owner/repo/releases/download/version/artifact-name</li>
<li>Releases API: https://{CUSTOM}/api/v3/repos/owner/repo/releases/latest (<a href="https://docs.github.com/en/enterprise-server@3.14/rest/releases/releases?apiVersion=2022-11-28">docs</a>)</li>
</ul>
</li>
</ul>
<p>Users can also override the entire URL for the artifact by specifying <code>${app name}_DOWNLOAD_URL</code> (available since 0.30.0).</p>
<p><code>dist</code> is eager to support enterprise level features like this- so if you have questions
or related feature requests, please join our <a href="https://discord.gg/ry3f3HZXWN">Discord</a>.</p>
<h2 id="github-bearer-token"><a class="header" href="#github-bearer-token">GitHub bearer token</a></h2>
<blockquote>
<p>since 0.29.0</p>
</blockquote>
<p>By default, the installer fetches archives without using any form of authentication. This is fine for public repos, but users with private projects (or who run into GitHub rate limits) may wish to provide their own tokens when downloading. If set, this will be used when fetching GitHub artifacts.</p>
<ul>
<li><code>${app name}_GITHUB_TOKEN</code></li>
</ul>
<h2 id="proxy"><a class="header" href="#proxy">Proxy</a></h2>
<blockquote>
<p>since 0.1.0 (shell), 0.30.0 (powershell)</p>
</blockquote>
<p>Users who need to fetch artifacts via a proxy can set the <code>HTTPS_PROXY</code> or <code>ALL_PROXY</code> environment variables. This is compatible with the syntax used by cURL; for more information, see <a href="https://everything.curl.dev/usingcurl/proxies/env.html">cURL's documentation</a>.</p>
<h2 id="verbosity"><a class="header" href="#verbosity">Verbosity</a></h2>
<blockquote>
<p>since 0.30.0</p>
</blockquote>
<p>Users can customize the verbosity of the shell installer by specifying one of two environment variables:</p>
<ul>
<li><code>${app name}_PRINT_QUIET</code> (also available as <code>--quiet</code> on the commandline)</li>
<li><code>${app name}_PRINT_VERBOSE</code> (also available as <code>--verbose</code> on the commandline)</li>
</ul>
<p><code>${app name}_PRINT_QUIET</code> will suppress warnings and error messages, while <code>${app name}_PRINT_VERBOSE</code> will print some extra debugging messages.</p>
<h2 id="receipt"><a class="header" href="#receipt">Receipt</a></h2>
<blockquote>
<p>since 0.9.0</p>
</blockquote>
<p>When you use axo to distribute your application, in addition to installers, you
may also enable an updater - either integrated into your application using a
library or as a standalone binary shipped alongside your application.</p>
<p>The updater functionality relies on knowing how your application was originally
installed and where. To keep track of this information, the installer writes a
receipt that is read by the the updater.</p>
<p>You can configure this receipt writing using the following options:</p>
<ul>
<li>Shell: The <code>$HOME</code> environment variable is sourced to write the receipt to
<code>$HOME/.config/{app name}</code>.</li>
<li>PowerShell: The <code>$LOCALAPPDATA</code> environment variable is sourced to write the
receipt to <code>$LOCALAPPDATA/{app name}</code>.</li>
</ul>
<h2 id="unmanaged-mode"><a class="header" href="#unmanaged-mode">Unmanaged mode</a></h2>
<blockquote>
<p>since 0.23.0</p>
</blockquote>
<p>This is intended for users installing in ephemeral environments such as CI and disables several features that are unneeded in those environments. To use it, set the <code>${app name}_UNMANAGED_INSTALL</code> environment variable to the desired installation path.</p>
<blockquote>
<p>Replace <code>{app name}</code> with the name of the application. To transform the
app name to the env var, replace any spaces or hyphens with an underscore
and then put it in all caps. You can double check this transform by
comparing the <code>install_dir_env_var</code> value in your <code>dist-manifest.json</code>.</p>
</blockquote>
<p>Enabling this mode does the following things:</p>
<ul>
<li>Disables updater-related tooling, including install receipt creation</li>
<li>Disables modification of the user's <code>PATH</code>, including modification of dotfiles</li>
<li>Forces a flat installation layout, installing all files into a single directory</li>
</ul>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>As you work with axo's installers, you will, despite everyone's best efforts,
find yourself debugging an issue. You can use the following options:</p>
<ul>
<li>
<h3 id="message-level"><a class="header" href="#message-level">Message level</a></h3>
<ul>
<li>Shell: <code>$INSTALLER_PRINT_VERBOSE</code>, <code>-v, --verbose</code> and <code>$INSTALLER_PRINT_QUIET</code>, `-q, --quiet``</li>
<li>PowerShell: <code>-Verbose</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifacts"><a class="header" href="#artifacts">Artifacts</a></h1>
<p>dist exists to help you distribute your binaries, which involves generating a lot of different files which we call <em>Artifacts</em>. Archives are the baseline artifacts that contain your binaries, and installers are the fancy artifacts that make it easy to install or run the binaries.</p>
<ul>
<li><a href="artifacts/./archives.html">Archives</a>: tarballs/zips containing your binaries</li>
<li><a href="artifacts/../installers/index.html">Installers</a>: things that help fetch/install archives</li>
<li><a href="artifacts/./checksums.html">Checksums</a>: hashes of other artifacts</li>
<li><a href="artifacts/./symbols.html">Symbols</a>: debuginfo/symbols/sourcemaps of your binaries</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archives"><a class="header" href="#archives">Archives</a></h1>
<p>Archives are the primary output of dist: a single file (zip or tarball) containing prebuilt executables/binaries for an app, along with additional static files like READMEs, LICENSEs, and CHANGELOGs. The docs previously referred to these as "executable-zips", so if you ever see that term floating around, this is what's being talked about.</p>
<p>When you <a href="artifacts/../reference/concepts.html#defining-your-apps">tell us to build an app</a> for <a href="artifacts/../reference/config.html#targets">a platform</a> we will always make an archive for it.</p>
<p><a href="artifacts/../installers/index.html#fetching-installers">Fetching installers</a> will fetch and unpack archives from wherever you <a href="artifacts/../reference/artifact-url.html">uploaded them</a>. <a href="artifacts/../installers/index.html#bundling-installers">Bundling installers</a> will use an exact copy of the binary stored in the archive, but may differ on other included files.</p>
<h2 id="auto-detected-files"><a class="header" href="#auto-detected-files">Auto-Detected Files</a></h2>
<p>We will always auto-detect READMEs, LICENSES, and CHANGELOGs with the following logic (described more below):</p>
<ul>
<li>README: <a href="artifacts/../reference/config.html#readme">package.readme</a>, or find <code>README*</code></li>
<li>LICENSE: <a href="artifacts/../reference/config.html#license-file">package.license-file</a>, or find <code>LICENSE*</code>/<code>UNLICENSE*</code></li>
<li>CHANGELOG: find <code>CHANGELOG*</code>/<code>RELEASES*</code></li>
</ul>
<p>"Find <code>XYZ*</code>" means we will look for a file whose name starts with "XYZ" in the same directory as the Cargo.toml for a package that defines the app. If no such file is found, we will also search for it in the same directory as the workspace's Cargo.toml (so packages "inherit" these files from the workspace).</p>
<p>It is generally assumed that a directory only contains one of each kind of file. If multiple possible matches are in the same directory we will arbitrarily pick the first one we saw, so don't rely on that.</p>
<p>Auto-detected files are first and foremost <a href="artifacts/archives.html#archive-contents">auto-included into the archive</a>, however they can also be used for other things. For instance, the autodetected CHANGELOG is fed into our CHANGELOG features.</p>
<h2 id="archive-contents"><a class="header" href="#archive-contents">Archive Contents</a></h2>
<p>The "root" of an archive is either the actual root directory of the archive (zips); or a directory with the same name as the archive, but without the extension (tarballs). This difference is for compatibility/legacy reasons, and can be smoothed away by unpacking tarballs with tar's <code>--strip-components=1</code>.</p>
<p>An app's archive always includes its binaries at the root.</p>
<p>By default <a href="artifacts/archives.html#auto-detected-files">auto-detected files</a> for a package are auto-included into its archives at the root of the package. The <a href="artifacts/../reference/config.html#auto-includes">auto-includes</a> config controls this behaviour.</p>
<p>The <a href="artifacts/../reference/config.html#include">include</a> can be used to manually add specific files/directories to the root of the archive.</p>
<h2 id="archive-formats"><a class="header" href="#archive-formats">Archive Formats</a></h2>
<p>Archives can be zips or tarballs (gz, xz, or zstd).</p>
<p>By default we make .zip on windows and .tar.xz elsewhere, but this can be configured with <a href="artifacts/../reference/config.html#windows-archive">windows-archive</a> and <a href="artifacts/../reference/config.html#unix-archive">unix-archive</a> features.</p>
<h2 id="build-flags"><a class="header" href="#build-flags">Build Flags</a></h2>
<p>We currently <a href="artifacts/../workspaces/simple-guide.html#the-dist-profile">always build with <code>--profile=dist</code></a></p>
<p>By default we build with <code>--workspace</code> <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/about/index.html#what-are-workspace-hack-crates">to keep things consistent</a>, but this can be configured with the <a href="artifacts/../reference/config.html#precise-builds">precise-builds config</a> (see those docs for details on when precise-builds will be force-enabled).</p>
<p>By default we build your packages with default features, but this can be configured with the <a href="artifacts/../reference/config.html#features">features</a>, <a href="artifacts/../reference/config.html#default-features">default-features</a>, and <a href="artifacts/../reference/config.html#all-features">all-features</a> configs.</p>
<p>When targeting windows-msvc we will unconditionally <a href="https://rust-lang.github.io/rfcs/1721-crt-static.html">append "-Ctarget-feature=+crt-static"</a> to your RUSTFLAGS, which should just be the default for rustc but isn't for legacy reasons.</p>
<h2 id="code-signing"><a class="header" href="#code-signing">Code Signing</a></h2>
<p>"Code Signing" is a very overloaded term, with wildly varying implementations that accomplish different goals. For instance, Linux users are currently very big on <a href="https://github.com/axodotdev/cargo-dist/issues/120">sigstore</a> as a fairly turn-key code signing solution, but <a href="https://github.com/axodotdev/cargo-dist/issues/21">neither Windows nor macOS</a> acknowledge its existence (and likely never will, as the benefits of sigstore completely defeat the stated purpose of code signing requirements on those platforms).</p>
<p>Roughly speaking, codesigning can be broken up into "Is this app made by the developer?" and "Can I trust apps made by this developer?". Tools like sigstore are focused on the former, while Windows/macOS only care about the latter. They want you to pay some money and jump through administrative hoops. They also expect you to pay completely different groups and go through completely different hoops, so each platform requires a completely different solution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checksums"><a class="header" href="#checksums">Checksums</a></h1>
<p>By default dist will generate a matching checksum file for each <a href="artifacts/../artifacts/archives.html">archive</a> it generates. The default checksum is sha256, so for instance <code>my-app-x86_64-pc-windows-msvc.zip</code> will also come with <code>my-app-x86_64-pc-windows-msvc.zip.sha256</code> that tools like <code>sha256sum</code> can use. This can be configured with <a href="artifacts/../reference/config.html#checksum">the checksum config</a>.</p>
<p><a href="artifacts/../installers/index.html#fetching-installers">Fetching installers</a> can also use these checksums (or ones baked into them) to validate the integrity of the files they download. With https and unsigned checksums the security benefit is minimal, but it can catch more boring problems like data corruption.</p>
<p>The homebrew installer actually ignores your checksum setting and always uses sha256 hashes that are baked into it, as required by homebrew itself.</p>
<p>Updating the other fetching installers to use these checksums is <a href="https://github.com/axodotdev/cargo-dist/issues/439">still a work in progress</a>.</p>
<blockquote>
<p>since 0.24.0</p>
</blockquote>
<p>cargo-dist also generates a "unified" checksum file, like <code>sha256.sum</code>, which contains the checksums for all the archives it has generated, in a format that can be checked with <code>sha256sum -c</code>, for example.</p>
<p>Individual checksums will be deprecated in a future version in favor of that unified checksum file.</p>
<p>Although you can <a href="artifacts/../reference/config.html#checksum">pick other checksum algorithms</a>, since you can only pick one, be aware that not every macOS/Linux/Windows system may have tools installed that are able to check <code>blake2b</code>, for example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbols"><a class="header" href="#symbols">Symbols</a></h1>
<p>This feature is currently disabled <a href="https://github.com/axodotdev/cargo-dist/issues/136">pending a rework</a>, but basically we want to save your debuginfo/symbols/sourcemaps in the form of pdbs, dSYMs, etc. This will automatically happen as a side-effect of building <a href="artifacts/./archives.html">archives</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ci"><a class="header" href="#ci">CI</a></h1>
<p>All of the <a href="ci/../introduction.html#distributing">distribute functionality</a> of dist depends on some kind of CI integration to provide things like <a href="ci/../reference/artifact-url.html">file hosting</a>, secret keys, and the ability to spin up multiple machines.</p>
<p>dist enables CI for you by default the first time you <code>dist init</code>. dist's core CI job can be <a href="ci/../ci/customizing.html">customized</a> using several extra features.</p>
<h2 id="supported-ci-providers"><a class="header" href="#supported-ci-providers">Supported CI Providers</a></h2>
<ul>
<li>github: uses GitHub Actions and uploads to GitHub Releases</li>
</ul>
<h2 id="future-ci-providers"><a class="header" href="#future-ci-providers">Future CI Providers</a></h2>
<p>The following CI providers have been requested, and we're open to supporting them, but we have no specific timeline for when they will be implemented. Providing additional info/feedback on them helps us prioritize the work:</p>
<ul>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/48">gitlab</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/273">travis</a></li>
</ul>
<h2 id="advanced-configuration"><a class="header" href="#advanced-configuration">Advanced configuration</a></h2>
<p>The default CI configuration covers most users' needs. For more advanced needs, we have an extensive guide on how to <a href="ci/../ci/customizing.html">customize</a> your CI pipeline.</p>
<h2 id="a-quick-tour-of-the-ci-process"><a class="header" href="#a-quick-tour-of-the-ci-process">A quick tour of the CI process</a></h2>
<p>The CI process is divided into several stages which happen in order. Understanding these steps will help you follow the release process and, if necessary, debug failures.</p>
<ol>
<li>plan: dist calculates which builds to run, and which platforms to build for, and enumerates the files that builds are expected to produce. The output of this step is saved and shared between steps and is also included in the final release as <code>dist-manifest.json</code>.</li>
<li>build-local-artifacts: dist builds native binaries and produces tarballs.</li>
<li>build-global-artifacts: dist builds platform-independent artifacts such as installers.</li>
<li>host: dist decides whether to proceed with publishing a release and uploading artifacts.</li>
<li>publish: Artifacts are uploaded and, if used, the Homebrew formula is released.</li>
<li>announce: The release is created with its final non-draft contents.</li>
</ol>
<h2 id="outputs-to-watch-out-for"><a class="header" href="#outputs-to-watch-out-for">Outputs to watch out for</a></h2>
<p>The most important output of your build is your release, but there's more advanced information in the logs for users who need it.</p>
<h3 id="checking-what-your-build-linked-against"><a class="header" href="#checking-what-your-build-linked-against">Checking what your build linked against</a></h3>
<blockquote>
<p>since 0.4.0</p>
</blockquote>
<p>Although most Rust builds are statically linked and contain their own Rust dependencies, some crates will end up dynamically linking against system libraries. It's useful to know what your software picked upâ€”sometimes this will help you catch things you may not have intended, like dynamically linking to OpenSSL, or allow you to check for package manager-provided libraries your users will need to have installed in order to be able to run your software.</p>
<p>dist provides a linkage report during your CI build in order to allow you to check for this. For macOS and Linux, it's able to categorize the targets it linked against to help you gauge whether or not it's likely to cause problems for your users. To view this, check the detailed view of your CI build and consult the "Build" step from the <code>upload-local artifacts</code> jobs.</p>
<p>This feature is defined for advanced users; most users won't need to use it. It's most useful for developers with specialized build setups who want to ensure that their binaries will be safe for all of their users. A few examples of users who may need to use it:</p>
<ul>
<li>Users with custom runners with extra packages installed beyond what's included in the operating system;</li>
<li>Users who have installed extra packages using dist's system dependency feature;</li>
<li>Users whose cargo buildsystems include extra C dependencies.</li>
</ul>
<p>The report is divided into categories to help you make sense of where these libraries are from and what it might mean for your users. These categories are:</p>
<ul>
<li>System: Libraries that come with your operating system. On Linux, these packages are all provided by the system's package manager, and the linkage report includes information about which package includes each library. Some of these packages will be included in the base OS, and will be safe to rely on, while you'll need to ensure your users have others. If you're using standard base images like GitHub Actions's and haven't installed additional packages using apt, the packages in this list should be preinstalled for your users. On macOS, these packages are shipped with the operating system and not managed by a package manager; you can always rely on these being there within the same version of macOS.</li>
<li>Homebrew (macOS only): Libraries that are provided by the Homebrew package manager for macOS. These packages are not installed by default, so your users will need to have them installed in order to be able to use your software.</li>
<li>Public (unmanaged): Libraries which are present in public locations, but which are not managed or provided by the system or a package manager. Because these are not standard parts of the operating system, your users will be unlikely to have them.</li>
<li>Frameworks (macOS only): Frameworks, a special type of library provided by macOS. Frameworks installed in the <code>/System</code> directory come with the operating system and are available to all users.</li>
<li>Other: A catch-all category for any libraries which don't fall in the previous categories.</li>
</ul>
<p>Here's an example of what a linkage report looks like for a Linux binary;</p>
<pre><code>axolotlsay (x86_64-unknown-linux-gnu):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Category           â”† Libraries                                       â”‚
â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
â”‚ System             â”† /lib/x86_64-linux-gnu/libgcc_s.so.1 (libgcc-s1) â”‚
â”‚                    â”† /lib/x86_64-linux-gnu/libpthread.so.0 (libc6)   â”‚
â”‚                    â”† /lib/x86_64-linux-gnu/libc.so.6 (libc6)         â”‚
â”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤
â”‚ Homebrew           â”†                                                 â”‚
â”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤
â”‚ Public (unmanaged) â”†                                                 â”‚
â”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤
â”‚ Frameworks         â”†                                                 â”‚
â”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤
â”‚ Other              â”†                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h4 id="limitations"><a class="header" href="#limitations">Limitations</a></h4>
<p>While the linkage report can be run locally, the report for Linux artifacts can only be run on Linux.</p>
<p>The Windows report is currently unable to provide information about the sources of libraries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customizing-github-actions"><a class="header" href="#customizing-github-actions">Customizing GitHub Actions</a></h1>
<ul>
<li><a href="ci/customizing.html#install-extra-packages">Install extra packages</a>
<ul>
<li><a href="ci/customizing.html#limitations">Limitations</a></li>
</ul>
</li>
<li><a href="ci/customizing.html#custom-jobs">Custom jobs</a></li>
<li><a href="ci/customizing.html#custom-runners">Custom runners</a></li>
<li><a href="ci/customizing.html#cross-compilation">Cross-compilation</a></li>
<li><a href="ci/customizing.html#pinned-actions-commits">Pinned actions commits</a></li>
<li><a href="ci/customizing.html#build-and-upload-artifacts-on-every-pull-request">Build and upload artifacts on every pull request</a></li>
<li><a href="ci/customizing.html#advanced-and-esoteric-features">Advanced and esoteric features</a>
<ul>
<li><a href="ci/customizing.html#customizing-build-setup">Customizing Build Setup</a>
<ul>
<li><a href="ci/customizing.html#limitations-1">Limitations</a></li>
</ul>
</li>
<li><a href="ci/customizing.html#bring-your-own-release">Bring your own release</a></li>
<li><a href="ci/customizing.html#publish-github-release-to-another-repository">Publish GitHub Release To Another Repository</a></li>
<li><a href="ci/customizing.html#hand-editing-releaseyml">Hand-editing release.yml</a></li>
<li><a href="ci/customizing.html#fiddly-build-task-settings">Fiddly build task settings</a></li>
</ul>
</li>
</ul>
<p>dist's generated CI configuration can be extended in several ways: it can be configured to install extra packages before the build begins, and it's possible to add extra jobs to run at specific lifecycle moments.</p>
<h2 id="install-extra-packages"><a class="header" href="#install-extra-packages">Install extra packages</a></h2>
<blockquote>
<p>since 0.4.0</p>
</blockquote>
<p>Sometimes, you may need extra packages from the system package manager to be installed before in the builder before dist begins building your software. dist can do this for you by adding the <code>dependencies</code> setting to your dist config. When set, the packages you request will be fetched and installed in the step before <code>build</code>. Additionally, on macOS, the <code>cargo build</code> process will be wrapped in <code>brew bundle exec</code> to ensure that your dependencies can be found no matter where Homebrew placed them.</p>
<p>Sometimes, you may want to make sure your users also have these dependencies available when they install your software. If you use a package manager-based installer, dist has the ability to specify these dependencies. By default, dist will examine your program to try to detect which dependencies it thinks will be necessary. At the moment, <a href="ci/../installers/homebrew.html">Homebrew</a> is the only supported package manager installer. You can also specify these dependencies manually.</p>
<p>For more information, see the <a href="ci/../reference/config.html#dependencies">configuration syntax</a>.</p>
<h3 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h3>
<ul>
<li>Currently, the only supported package managers are Apt (Linux), Chocolatey (Windows) and Homebrew (macOS).</li>
</ul>
<h2 id="custom-jobs"><a class="header" href="#custom-jobs">Custom jobs</a></h2>
<blockquote>
<p>since 0.3.0 (publish-jobs) and 0.7.0 (other steps)</p>
</blockquote>
<p>dist's CI can be configured to call additional jobs on top of the ones it has builtin. Currently, we support adding extra jobs to the the following list of steps:</p>
<ul>
<li><a href="ci/../reference/config.html#plan-jobs"><code>plan-jobs</code></a> (the beginning of the build process)</li>
<li><a href="ci/../reference/config.html#build-local-artifacts-jobs"><code>build-local-artifacts-jobs</code></a></li>
<li><a href="ci/../reference/config.html#build-global-artifacts-jobs"><code>build-global-artifacts-jobs</code></a></li>
<li><a href="ci/../reference/config.html#host-jobs"><code>host-jobs</code></a> (pre-publish)</li>
<li><a href="ci/../reference/config.html#publish-jobs"><code>publish-jobs</code></a></li>
<li><a href="ci/../reference/config.html#post-announce-jobs"><code>post-announce-jobs</code></a> (after the release is created)</li>
</ul>
<p>Custom jobs have access to the plan, produced via the "plan" step. This is a JSON document containing information about the project, planned steps, and its outputs. It's the same format contained as the "dist-manifest.json" that will be included with your release. You can use this in your custom jobs to obtain information about what will be built. For more details on the format of this file, see the <a href="ci/../reference/schema.html">schema reference</a>.</p>
<p>To add a custom job, you need to follow two steps:</p>
<ol>
<li>Define the new job as a reusable workflow using the standard method defined by your CI system. For GitHub actions, see the documentation on <a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows#creating-a-reusable-workflow">reusable workflows</a>.</li>
<li>Add the name of your new workflow file to the appropriate array in your dist config, prefixed with a <code>./</code>. For example, if your job name is <code>.github/workflows/my-publish.yml</code>, you would write it like this:</li>
</ol>
<pre><code class="language-toml">publish-jobs = ["./my-publish"]
</code></pre>
<p>Here's an example reusable workflow written using GitHub Actions. It won't do any real publishing, just echo text to the CI output. First, create a file named <code>.github/workflows/publish-greeter.yml</code> with these contents:</p>
<pre><code class="language-yaml">name: Greeter

on:
  # Defining workflow_call means that this workflow can be called from
  # your main workflow job
  workflow_call:
    # dist exposes the plan from the plan step, as a JSON string,
    # to your job if it needs it
    inputs:
      plan:
        required: true
        type: string

jobs:
  greeter:
    runs-on: ubuntu-latest
    # This is optional; it exposes the plan to your job as an environment variable
    env:
      PLAN: ${{ inputs.plan }}
    steps:
      - name: Step 1
        run: |
          echo "Hello!"
          echo "Plan is: ${PLAN}"
</code></pre>
<p>Then, add the following to your <code>publish-jobs</code> array:</p>
<pre><code class="language-toml">publish-jobs = ["./publish-greeter"]
</code></pre>
<p>Running <code>dist init</code> for your tool will update your GitHub Actions configuration to make use of the new reusable workflow during the publish step.</p>
<h2 id="custom-runners"><a class="header" href="#custom-runners">Custom runners</a></h2>
<blockquote>
<p>since 0.6.0</p>
</blockquote>
<p>By default, dist uses the following runners:</p>
<ul>
<li>Linux (x86_64): <code>ubuntu-22.04</code></li>
<li>macOS (x86_64): <code>macos-15-intel</code></li>
<li>macOS (Apple Silicon): <code>macos-14</code></li>
<li>Windows (x86_64): <code>windows-2022</code></li>
</ul>
<p>It's possible to configure alternate runners for these jobs, or runners for targets not natively supported by GitHub actions. To do this, use the <a href="ci/../reference/config.html#github-custom-runners"><code>github-custom-runners</code></a> configuration setting in your dist config. Here's an example which adds support for Linux (aarch64) using runners from <a href="https://buildjet.com/for-github-actions">Buildjet</a>:</p>
<pre><code class="language-toml"># in `dist-workspace.toml`

[dist.github-custom-runners]
aarch64-unknown-linux-gnu = "buildjet-8vcpu-ubuntu-2204-arm"
aarch64-unknown-linux-musl = "buildjet-8vcpu-ubuntu-2204-arm"
</code></pre>
<p>In addition to adding support for new targets, some users may find it useful to use this feature to fine-tune their builds for supported targets. For example, some projects may wish to build on a newer Ubuntu runner or alternate Linux distros, or may wish to opt into building for Apple Silicon from a native runner by using the <code>macos-14</code> runner. Here's an example which uses <code>macos-14</code> for native Apple Silicon builds:</p>
<pre><code class="language-toml"># in `dist-workspace.toml`

[dist.github-custom-runners]
aarch64-apple-darwin = "macos-14"
</code></pre>
<h2 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-compilation</a></h2>
<blockquote>
<p>since 0.26.0</p>
</blockquote>
<p>dist will transparently use either of:</p>
<ul>
<li><a href="https://github.com/rust-cross/cargo-zigbuild">cargo-zigbuild</a></li>
<li><a href="https://github.com/rust-cross/cargo-xwin">cargo-xwin</a></li>
</ul>
<p>To try and build for the target you specified, from the host you specified.</p>
<p>dist hardcodes knowledge of which cargo wrappers are better suited for which cross: <code>cargo-zigbuild</code>
handles <code>x86_64-unknown-linux-gnu</code> to <code>aarch64-unknown-linux-gnu</code> handsomely, for example.</p>
<p>So if you ask for <code>aarch64-unknown-linux-gnu</code> artifacts, because at the time of this writing
there are no free <code>aarch64</code> GitHub runners, dist will assume you meant this:</p>
<pre><code class="language-toml">[dist.github-custom-runners]
aarch64-unknown-linux-gnu = "ubuntu-22.04"
</code></pre>
<p>Which really means this:</p>
<pre><code class="language-toml">[dist.github-custom-runners.aarch64-unknown-linux-gnu]
runner = "ubuntu-22.04"
host = "x86_64-unknown-linux-gnu"
</code></pre>
<p>...since dist knows which platform GitHub's own <a href="https://github.com/actions/runner-images">runner
images</a> are.</p>
<p>So you really only need to specify the <code>host</code> if you use <a href="https://github.com/neysofu/awesome-github-actions-runners?tab=readme-ov-file#list-of-providers">third-party GitHub Actions
runners</a> (Namespace, Buildjet, etc.)</p>
<p>If you don't specify the host, dist will just assume it's the same platform as
the target, which is why this works:</p>
<pre><code class="language-toml">[dist.github-custom-runners]
aarch64-unknown-linux-gnu = "buildjet-8vcpu-ubuntu-2204-arm"
</code></pre>
<p>Building <code>aarch64-pc-windows-msvc</code> binaries from a <code>x86_64-pc-windows-msvc</code> runner (like
<code>windows-2022</code>) is surprisingly hard. But building both binaries from an <code>x86_64-unknown-linux-gnu</code>
runner is surprisingly easy via <code>cargo-xwin</code></p>
<p>This will work, eventually:</p>
<pre><code class="language-toml"># in `dist-workspace.toml`

[dist]
targets = ["x86_64-pc-windows-msvc", "aarch64-pc-windows-msvc"]

[dist.github-custom-runners.x86_64-pc-windows-msvc]
runner = "ubuntu-22.04"

[dist.github-custom-runners.aarch64-pc-windows-msvc]
runner = "ubuntu-22.04"
</code></pre>
<p>...because dist can install <code>cargo-xwin</code> via <code>pip</code>. However, it will take
forever. It's probably best to use a docker image that already has
<code>cargo-xwin</code> installed, and other dependencies you probably want:</p>
<pre><code class="language-toml"># in `dist-workspace.toml`

[dist]
targets = ["x86_64-pc-windows-msvc", "aarch64-pc-windows-msvc"]

[dist.github-custom-runners.x86_64-pc-windows-msvc]
container = "messense/cargo-xwin"

[dist.github-custom-runners.aarch64-pc-windows-msvc]
container = "messense/cargo-xwin"
</code></pre>
<p>Which is short for:</p>
<pre><code class="language-toml"># cut: the rest of the config file

[dist.github-custom-runners.x86_64-pc-windows-msvc]
container = { image = "messense/cargo-xwin", host = "x86_64-unknown-linux-gnu" }

# etc.
</code></pre>
<p>...but unfortunately, GitHub Actions's "run workflows in container" feature doesn't
support emulation yet. We'd have to set up qemu, run docker manually, etc. â€” which
dist doesn't do as of now. So the <code>host</code> just defaults to <code>x86_64-unknown-linux-gnu</code>
right now, because that's all the GitHub runners support anywyay.</p>
<p>So, because we're only specifying one feature, it's probably easier to just write this:</p>
<pre><code class="language-toml">[dist]
targets = ["x86_64-pc-windows-msvc", "aarch64-pc-windows-msvc"]

[dist.github-custom-runners]
x86_64-pc-windows-msvc.container = "messense/cargo-xwin"
aarch64-pc-windows-msvc.container = "messense/cargo-xwin"

# (yes, that /is/ valid TOML)
</code></pre>
<p>Note that you can use containers for non-cross reasons: maybe you want your binaries to be
compatible with really old versions of glibc, older than Ubuntu 22.04: in this case, you
can do something like:</p>
<pre><code class="language-toml">[dist.github-custom-runners.x86_64-unknown-linux-gnu]
container = { image = "quay.io/pypa/manylinux_2_28_x86_64", host = "x86_64-unknown-linux-musl" }

[dist.github-custom-runners.aarch64-unknown-linux-gnu]
container = { image = "quay.io/pypa/manylinux_2_28_x86_64", host = "x86_64-unknown-linux-musl" }
</code></pre>
<p>Note that here, the host triple for those container images is overridden to be <code>x86_64-unknown-linux-musl</code>, because dist itself (which must run in the container) might be using a too-recent version of glibc.</p>
<p>Because of dist's cross-compilation support, if you have both <code>cargo-zigbuild</code> and <code>cargo-xwin</code>
installed on a macOS machine, you can build pretty much every target dist supports, by running
<code>dist build --artifacts all</code> â€” in fact, this is used to develop dist itself!</p>
<h2 id="pinned-actions-commits"><a class="header" href="#pinned-actions-commits">Pinned actions commits</a></h2>
<blockquote>
<p>since 0.29.0</p>
</blockquote>
<p>Dist uses a number of first-party and third-party actions. Typically, it uses tagged versions; for example, dist 0.29.0 uses <code>actions/checkout@v4</code>. Some users with special security requirements may wish to pin these to specific commits rather than floating tags; this can be done using the <code>github-action-commits</code> setting. For example:</p>
<pre><code class="language-toml">[dist.github-action-commits]
"actions/checkout" = "11bd71901bbe5b1630ceea73d27597364c9af683"
</code></pre>
<h2 id="build-and-upload-artifacts-on-every-pull-request"><a class="header" href="#build-and-upload-artifacts-on-every-pull-request">Build and upload artifacts on every pull request</a></h2>
<blockquote>
<p>since 0.3.0</p>
</blockquote>
<p>By default, dist will run the plan step on every pull request but won't perform a full release build. If these builds are turned on, the resulting pull request artifacts won't be uploaded to a release but will be available as a download from within the CI job. To enable this, select the "upload" option from the "check your release process in pull requests" question in <code>dist init</code> or set <a href="ci/../reference/config.html#pr-run-mode">the <code>pr-run-mode</code> key</a> to <code>"upload"</code> in <code>Cargo.toml</code>'s dist config. For example:</p>
<pre><code class="language-toml">pr-run-mode = "upload"
</code></pre>
<h2 id="advanced-and-esoteric-features"><a class="header" href="#advanced-and-esoteric-features">Advanced and esoteric features</a></h2>
<p>These features are specialized to very particular usecases, but may be useful for some users.</p>
<h3 id="customizing-build-setup"><a class="header" href="#customizing-build-setup">Customizing Build Setup</a></h3>
<blockquote>
<p>since 0.20.0</p>
</blockquote>
<p>This is an experimental feature.</p>
<p>In the event that installing platform dependencies using dist's system dependency feature
doesn't work for your needs, for example a build dependency for your project isn't provided by the
system's package manager, dist provides a method for injecting build steps into the
<code>build-local-artifacts</code> job to prepare the container.</p>
<p>To do this, use the <a href="ci/../reference/config.html#github-build-setup">github-build-setup setting</a> which
should be a path relative to your <code>.github/workflows/</code> directory, and which should point to a
<code>.yml</code> file containing the github workflow steps just as you would normally write them in a workflow.
(don't forget that leading <code>-</code>!)
We recommend storing this file one directory below or above <code>.github/workflows</code> so that GitHub doesn't mistake it for a standalone workflow.</p>
<p>For example, if you needed the Lua programming language installed you could update your <code>Cargo.toml</code> with the following:</p>
<pre><code class="language-toml">[dist]
# ...
github-build-setup = "../build-setup.yml"
</code></pre>
<p>And then include in the root of your repository a file named <code>.github/build-setup.yml</code> containing the
following.</p>
<pre><code class="language-yml">- name: Install Lua
  uses: xpol/setup-lua@v1
  with:
    lua-version: "5.3"
- name: Check lua installation
  run: lua -e "print('hello world!')"
</code></pre>
<p>This would generate a <code>build-local-artifacts</code> job with the following modifications.</p>
<pre><code class="language-yml"># ...
jobs:
# ...
  build-local-artifacts:
    # ...
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Install Lua
        uses: xpol/setup-lua@v1
          with:
            lua-version: "5.3"
      - name: Check lua installation
        run: lua -e "print('hello world!')"
# ...
</code></pre>
<p>Notice that we include the steps right after the <code>actions/checkout</code> step meaning that we are doing
this as early in the build job as possible.</p>
<h4 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h4>
<h5 id="multi-line-strings"><a class="header" href="#multi-line-strings">Multi-line strings</a></h5>
<p>Currently the use of <a href="https://yaml.org/spec/1.2.2/#813-folded-style">folding</a> (<code>&gt;</code>) and
<a href="https://yaml.org/spec/1.2.2/#8112-block-chomping-indicator">chomping</a> (<code>-</code>) multi-line string
modifiers will probably generate a surprising outputs. This is particularly important for any
actions that use the <code>run</code> keyword and it is recommended to use the literal (<code>|</code>) string modifier for
multi-line strings.</p>
<h3 id="bring-your-own-release"><a class="header" href="#bring-your-own-release">Bring your own release</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>By default, dist will want to create its own GitHub Release and set the title/body with things like your CHANGELOG/RELEASES and some info about how to install the release. However if you have your own process for generating the contents of GitHub Release, we support that.</p>
<p>If you set <a href="ci/../reference/config.html#create-release"><code>create-release = false</code></a> in your dist config, dist will assume a draft Github Release for the current git tag already exists with the title/body you want, and just upload artifacts to it. At the end of a successful publish it will undraft the GitHub Release for you.</p>
<h3 id="publish-github-release-to-another-repository"><a class="header" href="#publish-github-release-to-another-repository">Publish GitHub Release To Another Repository</a></h3>
<blockquote>
<p>since 0.14.0</p>
</blockquote>
<p>You can change which repository a GitHub Release gets published to with the <a href="ci/../reference/config.html#github-releases-repo">github-releases-repo setting</a>.</p>
<h3 id="hand-editing-releaseyml"><a class="header" href="#hand-editing-releaseyml">Hand-editing release.yml</a></h3>
<blockquote>
<p>since 0.3.0</p>
</blockquote>
<p>The happy-path of dist has us completely managing release.yml, and since 0.3.0 we will actually consider it an error for there to be any edits or out of date information in release.yml.</p>
<p>If there's something that dist can't do that makes you want to hand-edit the file, we'd love to hear about it so that you can stay on the happy-path!</p>
<p>However we know you sometimes really need to do those hand-edits, so there is a way to opt into it. If you <a href="ci/../reference/config.html#allow-dirty">set <code>allow-dirty = ["ci"]</code> in your dist config</a>, dist will stop trying to update the file and stop checking if it's out of date.</p>
<p>Although you're not "using dist wrong" if you do this, <strong>be aware that you are losing access to a lot of the convenience and UX benefits of dist</strong>. Every piece of documentation that says "just run dist init" may not work correctly, as a new feature may require the CI template to be updated. Even things as simple as "updating dist" will stop working.</p>
<p>We have put a lot of effort into minimizing those situations, with <code>plan</code> increasingly being responsible for dynamically computing what the CI should do, but that's not perfect, and there's no guarantees that future versions of dist won't completely change the way CI is structured.</p>
<h3 id="fiddly-build-task-settings"><a class="header" href="#fiddly-build-task-settings">Fiddly build task settings</a></h3>
<blockquote>
<p>since 0.0.1</p>
</blockquote>
<p>Here's a grab-bag of more random settings you probably don't want to use, but exist in case you need them.</p>
<p>By default dist lets all the build tasks keep running even if one of them fails, to try to get you as much as possible when things go wrong. <a href="ci/../reference/config.html#fail-fast"><code>fail-fast = true</code> can be set to disable this</a>.</p>
<p>By default dist breaks build tasks onto more machines than strictly necessary to create the maximum opportunities for concurrency and to increase fault-tolerance. For instance if you want to build for both arm64 macOS and x64 macOS, that <em>could</em> be done on the same machine, but we put it on two machines so they can be in parallel and succeed/fail independently. <a href="ci/../reference/config.html#merge-tasks"><code>merge-tasks = true</code> can be set to disable this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide"><a class="header" href="#guide">Guide</a></h1>
<p>dist is focused around <em>workspaces</em> - conceptual groupings of projects that exist in the same repository, and which can be built and released together. A workspace can contain just a single project, and the simplest form is easy to get going. If you just want to get going, we recommend checking the <a href="workspaces/../quickstart/index.html">quickstart</a> guide first.</p>
<p>For users interested in learning more about how workspaces work, and how to put them to work with more complex projects, we recommend starting with our <a href="workspaces/./structure.html">guide to workspace structure</a>, followed by the <a href="workspaces/./simple-guide.html">simple guide</a> which walks you through a simple sample repo and the <a href="workspaces/./workspace-guide.html">complex guide</a> that introduces a workspace with more complicated features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-structure"><a class="header" href="#workspace-structure">Workspace Structure</a></h1>
<p>All dist projects, regardless of how many packages they may contain, are
considered workspaces. A minimalist dist project would be a workspace that
contains a single package.</p>
<p>This guide walks through the structure of a dist workspace, but if you're more interested in seeing one in action, you can skip ahead to the <a href="workspaces/./simple-guide.html">simple workspace guide</a>.</p>
<p>Dist has two types of configuration:</p>
<ul>
<li><strong>Workspace</strong>: Configuration that should apply to any projects in a single repo</li>
<li><strong>Package</strong>: Configuration that should apply to one specific project</li>
</ul>
<p>The vast majority of configuration for dist is workspace configuration. Because
we understand language-specific config manifests like <code>Cargo.toml</code> and
<code>package.json</code>, package configuration usually does not require any additional
files. Dedicated package configuration, in <code>dist.toml</code> files, is typically only needed when using dist's <a href="workspaces/../custom-builds.html">"custom builds"</a> mode.</p>
<h2 id="workspace-configuration"><a class="header" href="#workspace-configuration">Workspace configuration</a></h2>
<p>A workspace file may be:</p>
<ul>
<li><code>dist-workspace.toml</code></li>
<li>(deprecated in 0.23.0) <code>Cargo.toml</code> (Rust users only, goes in <code>[workspace.metadata.dist]</code>)</li>
</ul>
<h3 id="specifying-the-members-of-your-workspace"><a class="header" href="#specifying-the-members-of-your-workspace">Specifying The Members Of Your Workspace</a></h3>
<p>Create a <code>workspace.members</code> field in your <code>dist-workspace.toml</code> that points to
an array of strings. Each string is prefaced with a type:</p>
<ul>
<li><code>npm</code>: this indicates a package that is specified by a <code>package.json</code></li>
<li><code>cargo</code>: this indicates a package (or nested workspace) that is specified by a <code>Cargo.toml</code>. You do not need to specify cargo workspace members individually, you can simply refer to the workspace.</li>
<li><code>dist</code>: this indicates a package that is specified by a <code>dist.toml</code></li>
</ul>
<p>For example:</p>
<pre><code class="language-toml">[workspace]
members = [
  "npm:path/to/npm/packagejson/dir/",
  "cargo:path/to/workspace/cargotoml/dir/",
  "dist:path/to/distoml/dir/"
]
</code></pre>
<h2 id="package-configuration"><a class="header" href="#package-configuration">Package configuration</a></h2>
<p>A package file may be:</p>
<ul>
<li><code>dist.toml</code></li>
<li><code>dist-workspace.toml</code></li>
<li><code>Cargo.toml</code> (for a Rust package)</li>
<li><code>package.json</code> (for an npm package)</li>
</ul>
<p>In the case of a <code>Cargo.toml</code> and <code>package.json</code>, we'll do our best to find basic package
info like package name, version, repository, binaries among the native language-specific config.</p>
<p>However these files do not natively support dist-specific config, so you may
need to place a dist config <em>next</em> to them to specify additional dist-specific
config. If we see the language-specific package file, we will automatically
check for a neighbouring dist config and merge its contents in. If you wish to
"shadow" or change a value that is present in your package manifest -- you can
use the dist config file to "override" it.</p>
<p>For a <code>Cargo.toml</code> you can instead use <code>[package.metadata.dist]</code>. However to
override values in the <code>[package]</code> field, you would need to create a dist
config file..</p>
<h2 id="specifying-the-members-of-your-workspace-1"><a class="header" href="#specifying-the-members-of-your-workspace-1">Specifying The Members Of Your Workspace</a></h2>
<p>If you have a pure Cargo project, and are using <code>[workspace.metadata.dist]</code>, you don't
need to specify project members at all -- we'll just find all the packages with our
native understanding of Cargo.</p>
<p>For everyone else, your dist-workspace.toml will need to contain a <code>workspace.members</code> field enumerating paths to all your packages -- although again for a Cargo member you
don't actually enumerate the packages, you just point to the Cargo workspace
and we'll find all the packages in that workspace:</p>
<pre><code class="language-toml">[workspace]
members = [
  "npm:path/to/npm/packagejson/dir/",
  "cargo:path/to/workspace/cargotoml/dir/",
  "dist:path/to/distoml/dir/"
]
</code></pre>
<h2 id="which-packages-are-distable"><a class="header" href="#which-packages-are-distable">Which Packages Are Distable</a></h2>
<p>When you ask dist to release a version of your workspace (by specifying a
version, either with a tag or via workflow dispatch), we will release all "distable" packages with the
given version.</p>
<p>The set of distable packages isn't just "all the packages in your dist workspace"
because we support natively importing entire language-specific workspaces, which may
include tons of libraries you aren't interested in, or example/test applications.</p>
<p>By default we assume a package is distable, and then run through a set of criteria
to try to disqualify it:</p>
<ul>
<li>If the package is "empty", it's not distable
<ul>
<li>By default, we check for whether the package defines binaries</li>
<li>If you have enabled <code>cdylibs/cstaticlibs</code> we check for those as well</li>
</ul>
</li>
<li>If the package has <code>dist=false</code> set, it's not distable
<ul>
<li>For a cargo project, If dist isn't specified, the <code>publish</code> field in
<code>Cargo.toml</code> will be inherited, with a default value of <code>true</code>. Setting
<code>dist=true</code> can therefore be used to ignore <code>publish=false</code> in <code>Cargo.toml</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-a-simple-application"><a class="header" href="#guide-a-simple-application">Guide: A Simple Application</a></h1>
<ul>
<li><a href="workspaces/simple-guide.html#setup-and-updates">Setup (and Updates)</a>
<ul>
<li><a href="workspaces/simple-guide.html#the-dist-profile">The "dist" Profile</a></li>
<li><a href="workspaces/simple-guide.html#the-workspace-config">The Workspace Config</a></li>
<li><a href="workspaces/simple-guide.html#the-ci-script">The CI Script</a></li>
<li><a href="workspaces/simple-guide.html#finishing-setup">Finishing Setup</a></li>
</ul>
</li>
<li><a href="workspaces/simple-guide.html#cutting-releases">Cutting Releases</a>
<ul>
<li><a href="workspaces/simple-guide.html#release-notes">Release Notes</a></li>
</ul>
</li>
</ul>
<p>Let's start with the kind of simple <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> you would get from <code>cargo new my-app</code> (or <code>cargo init my-app</code>): a single package that defines a <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary target</a>. This is exactly the situation the <a href="workspaces/../quickstart/index.html">quickstart</a> should work perfectly for. Here we're going to take it a bit slower.</p>
<p>Our goal will be to setup a Github CI workflow that announces a new release of our application with a Github Release. The workflow will also build our application for the 3 major desktop platforms, wrap the binaries in zips/tarballs, and upload them to the Github Release. The Github Release's text will also include the relevant release notes from our RELEASES.md file.</p>
<p>The workflow will be triggered whenever you push a <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git Tag</a> specifying the application's new version, like "v1.0.0". Don't worry, you won't need to write those workflows yourself, dist will generate them for you!</p>
<blockquote>
<p>TO BE EXTREMELY PEDANTIC: The workflow will trigger whenever Github sees that the git tag <em>and</em> the commit it refers to are part of the repo <em>and</em> the timestamp(?) of both(?) is <em>after</em> the commit that introduced the workflow's yml file. That last part is an absolute headache, and may require you to delete the tag <em>both locally and on github</em> if you created it before the workflow. Basically, setup dist <em>before</em> you start cutting releases!</p>
</blockquote>
<h2 id="setup-and-updates"><a class="header" href="#setup-and-updates">Setup (and Updates)</a></h2>
<p>To setup dist on our project (after we've <a href="workspaces/../install.html">installed it</a>), we "need" to run <code>dist init</code>, which will provide us with a series of interactive prompts and explanations to configure our project. The recommended option can always be selected by hitting ENTER, and you can automate that by just passing <code>--yes</code>.</p>
<p>You can rerun <code>init</code> as many times as you want, as it also functions as an "update" command for your config. This is especially convenient for updating your project to the version of dist you're running, as it will prompt you to do that whenever the versions don't match (refusing to proceed if declined).</p>
<pre><code class="language-sh">dist init
</code></pre>
<p><a href="workspaces/../reference/cli.html#dist-init"><code>init</code></a> on its own just edits your Cargo.toml to include the recommended defaults. If you have enabled CI support, it will also run <code>dist generate</code> after setting things up. This ensures your config and your CI scripts are in sync, but will unfortunately clobber any hand-edits you made to the scripts.</p>
<p>Let's look at those defaults that were added (yes those comments are generated too, you will never stop me from adding more docs!!!):</p>
<pre><code class="language-toml"># The profile that 'dist' will build with
[profile.dist]
inherits = "release"
lto = "thin"

# Config for 'dist'
[workspace.metadata.dist]
# The preferred dist version to use in CI (Cargo.toml SemVer syntax)
cargo-dist-version = "0.0.6"
# CI backends to support
ci = ["github"]
# The installers to generate for each app
installers = []
# Target platforms to build apps for (Rust target-triple syntax)
targets = ["x86_64-unknown-linux-gnu", "x86_64-apple-darwin", "x86_64-pc-windows-msvc", "aarch64-apple-darwin"]
</code></pre>
<blockquote>
<p>If your config doesn't have <code>ci = ["github"]</code> by default, then you probably don't have <code>repository = "https://github.com/..."</code> consistently set in your Cargo.toml(s). The rest of this guide will assume you did. dist will work fine without it, you just won't get Github CI integration or <a href="workspaces/../installers/index.html">installers</a>.</p>
</blockquote>
<h3 id="the-dist-profile"><a class="header" href="#the-dist-profile">The "dist" Profile</a></h3>
<p>First let's talk about <code>[profile.dist]</code>. This is a custom <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo Profile</a> that dist will use to build your app. If you want to, you can use it yourself by passing <code>--profile=dist</code> to cargo (i.e. <code>cargo run --profile=dist</code>). We define a separate profile from the normal "release" one so that you can be comfortable giving your Shippable Builds more aggressive settings without making local development too tedious.</p>
<p>In this case the default profile dist recommends is essentially the same as --release (hence <code>inherits = "release"</code>), but with <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#lto">thin LTO</a> enabled (<code>lto = "thin"</code>). This will make the build take longer, but produce more optimized builds.</p>
<p>dist uses the existence of <code>[profile.dist]</code> in your Cargo.toml to detect if your project has been properly initialized, and will generally refuse to run other commands otherwise. Sorry but you can't delete the profile!</p>
<h3 id="the-workspace-config"><a class="header" href="#the-workspace-config">The Workspace Config</a></h3>
<p>Next let's talk about <code>[workspace.metadata.dist]</code>. Cargo allows other tools to include their own project-wide settings in this kind of <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-metadata-table">metadata table</a>. See <a href="workspaces/../reference/config.html">config</a> for the full set of options, but here we'll look at the defaults.</p>
<p><code>cargo-dist-version = "0.0.6"</code> is dist recording its own version in your config for the sake of reproducibility and documentation. When you run <a href="workspaces/../reference/cli.html#dist-generate">generate</a> the resulting CI scripts will use that version of dist.</p>
<p><code>ci = ["github"]</code> lets subsequent runs of <a href="workspaces/../reference/cli.html#dist-generate">generate</a> know what CI scripts to generate. Its presence also enables certain Github-specific features like generating the body for a Github Release and telling installers to fetch binaries from a Github Release. It will be enabled by default if you have <code>repository = "https://github.com/..."</code> consistently set in your Cargo.toml(s). ("github" is currently the only supported CI backend.)</p>
<p><code>installer = []</code> is just saying that we haven't enabled any <a href="workspaces/../installers/index.html">installers</a>. Installers are intentionally excluded here to keep this example focused.</p>
<p><code>targets = ...</code> is listing the <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">platforms</a> to build your application for. In this case, because we didn't specify the targets with <code>--target</code>, <a href="workspaces/../reference/cli.html#dist-init">init</a> has selected the "recommended desktop suite": "x64 linux", "x64 macos", "x64 windows", and "arm64 macos (Apple silicon)". In v0.0.6 these are the only properly supported choices, because we wanted to get the core of dist solid first. Future versions should hopefully introduce proper support for important targets like "musl linux".</p>
<h3 id="the-ci-script"><a class="header" href="#the-ci-script">The CI Script</a></h3>
<p>Because we set <code>ci = ["github"]</code>, <a href="workspaces/../reference/cli.html#dist-init">init</a> invoked <a href="workspaces/../reference/cli.html#dist-generate">generate</a> for us. Creating the Github CI workflow we wanted at <code>.github/workflows/release.yml</code>. Rather than including the full text here, I'll just link <a href="https://github.com/axodotdev/cargo-dist/blob/main/.github/workflows/release.yml">dist's own release.yml</a>, because dist is self-hosting and has an extremely boring build/config that is basically equivalent to the one we're looking at in this example.</p>
<p>The first thing you might notice is that there's a <em>lot</em> of comments describing the script. As always: you will never stop me from writing more docs and shoving them in your face. Actually ok you <em>can</em> stop me because I need to write a lot of docs here and those comments are already decent docs. Feel free to peruse them to get a feel for it.</p>
<p>One thing I want to emphasize is that each job of the workflow essentially boils down to "install dist, run dist exactly once, then upload the files it tells you to". Ideally this means you can run that one dist command and get the same things that CI produced!</p>
<p>Anyway, the CI totally does all the things we said it should! Yay!</p>
<h3 id="finishing-setup"><a class="header" href="#finishing-setup">Finishing Setup</a></h3>
<p>Now that we've run <code>dist init</code>, all we need to do is commit the results and push them up:</p>
<pre><code class="language-sh">git add .
git commit -am 'wow cool new dist CI!'
git push
</code></pre>
<p>Actually wait we should... probably test that we set things up properly? The devil's always in the details when it comes to CI, but we can do some initial checking of things with the <a href="workspaces/../reference/cli.html#dist-plan">plan</a> command:</p>
<pre><code class="language-sh">dist plan
</code></pre>
<p><a href="workspaces/../reference/cli.html#dist-plan">plan</a> is the same as <a href="workspaces/../reference/cli.html#dist-build">build</a> but it doesn't actually <em>run</em> the build and defaults to reporting info for all platforms. This makes it ideal for asking dist about the full Announcement a CI run would produce.</p>
<p>If everything went right, you should see something like the following:</p>
<p><img src="workspaces/../img/simple-app-manifest.png" alt="The result of running the plan command, described below" />.</p>
<p>This output has two parts: "analyzing workspace" and "announcing"</p>
<p>"analyzing workspace" describes what dist found in your workspace. In this case there's a package called "my-app" with a <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary target</a> of the same name.</p>
<p>"announcing v0.1.0" tells us the tag that should be pushed to announce a release of the current workspace ("v0.1.0"). Underneath it we see that the announcement will include "my-app 0.1.0" as expected. Underneath that we see 4 artifacts will be produced and uploaded:</p>
<ul>
<li>The Intel macOS build: my-app-v0.1.0-x86_64-apple-darwin.tar.xz</li>
<li>The M1 macOS build: my-app-v0.1.0-aarch64-apple-darwin.tar.xz</li>
<li>The Windows build: my-app-v0.1.0-x86_64-pc-windows-msvc.zip</li>
<li>The Linux build: my-app-v0.1.0-x86_64-unknown-linux-gnu.tar.xz</li>
</ul>
<p>It also helpfully lists the contents of each zip. In this case I didn't properly setup my project at all, so it only contains a prebuilt binary. If I actually add files like README.md, LICENSE, and RELEASES.md, dist will helpfully pick those up and include them (disable this with the <code>auto-includes=false</code> <a href="workspaces/../reference/config.html">config</a>):</p>
<p><img src="workspaces/../img/simple-app-manifest-with-files.png" alt="The same as the last screenshot, but now the files mentioned above are included in each zip/tarball" /></p>
<p>If you add <code>--output-format=json</code> you'll get a full machine-readable output instead, and have locally recreated the first step of the generate CI!</p>
<h2 id="cutting-releases"><a class="header" href="#cutting-releases">Cutting Releases</a></h2>
<p>With all our one-time setup done, we're ready to cut a release! This can be streamlined a lot with <a href="https://github.com/crate-ci/cargo-release">cargo-release</a> which will do essentially everything we're about to go through with a single command (<a href="workspaces/./cargo-release-guide.html">see the guide on that</a>), but it's helpful to understand the actual steps in case cargo-release doesn't fit your usecase or if you need to debug issues.</p>
<p>The first step is to do all the things you would do to prep a release: update docs, update release notes, bump version numbers in Cargo.tomls, run tests, and so on.</p>
<p>At this point we're confident and want to release things for real. Once again, we can check what dist thinks should happen with the <a href="workspaces/../reference/cli.html#dist-plan">plan</a> command:</p>
<pre><code class="language-sh">dist plan
</code></pre>
<p>Similarly you can check that <code>cargo publish</code> will work with the <code>--dry-run</code> flag:</p>
<pre><code class="language-sh">cargo publish --dry-run
</code></pre>
<p>If both of those seem happy, you're ready to release! All we need to do is push up a commit that has the <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git Tag</a> that <a href="workspaces/../reference/cli.html#dist-plan">plan</a> suggested. As we've seen in previous sections, it's recommending "v0.1.0" for our example app, so let's use that:</p>
<pre><code class="language-sh"># Publish to a Github Release with dist
git commit -am "Chore: Release 0.1.0"
git tag "v0.1.0"
git push
git push --tags

# Publish to crates.io
cargo publish
</code></pre>
<p>and that's... it! If everything's working, your CI should spin up a "Release" workflow that dist generated for you, and after a few minutes the "Releases" section of your repo should have all the results populated with something like this:</p>
<p><img src="workspaces/../img/simple-github-release.png" alt="A Github Release for &quot;my-app 0.1.0&quot; with shell-script installers and tarballs of prebuilt binaries" /></p>
<p>Oops! There's some extra features in that screenshot that I haven't explained yet! This includes the "Release Notes" feature and a few <a href="workspaces/../installers/index.html">installers</a>. Since we're talking about Releasing, let's talk about Release Notes.</p>
<h3 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h3>
<p>If your project has a top-level RELEASES/CHANGELOG file like "RELEASES.md", then dist will automatically try to use it as part of your Announcement (Github Release). We use the <a href="https://github.com/taiki-e/parse-changelog">parse-changelog</a> library to try to find a heading for the version you're releasing, and if we do, we add it to the Github Release's text. We also use the heading as the title for the Github Release (rather than just the git tag).</p>
<p>Roughly speaking, the library is looking for something like:</p>
<pre><code class="language-text"># &lt;ignorable prefix&gt; &lt;version&gt; &lt;ignorable suffix&gt;
</code></pre>
<p>For instance in <code># Version 1.0.0 (2022-03-01)</code>, the only really important part is the "1.0.0", which should exactly match the Cargo version of your package. If you want to see how your RELEASES/CHANGELOG file is interpreted you can install parse-changelog as a CLI and run it on the file to see what it thinks. In the future we'll have some better debugging tools for this.</p>
<p>If you're publishing a Version with some prerelease bits like "1.0.0-prerelease.1", then we'll first look for that exact match in your RELEASES/CHANGELOG. If we can't find it we'll strip the prerelease/build suffix (in this case going back to "1.0.0") and check for that. If <em>that</em> finds a match we'll edit the heading to include the prerelease suffix when we include it in the Announcement. This lets you have a stable heading like <code># Version 1.0.0 (under development)</code>, and prereleases will get headings like <code># Version 1.0.0-prerelease.1 (under development)</code>.</p>
<p>If none of the previous rules apply, "1.0.0-prerelease.1" will also match a special "Unreleased" heading (i.e. "# Unreleased"), which will get rewritten to "# Version 1.0.0-prerelease.1". This lets you maintain a changelog for a pending release without having to commit to what version it will be.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-more-complex-workspaces"><a class="header" href="#guide-more-complex-workspaces">Guide: More Complex Workspaces</a></h1>
<ul>
<li><a href="workspaces/workspace-guide.html#multiple-binaries-in-one-package">Multiple Binaries In One Package</a></li>
<li><a href="workspaces/workspace-guide.html#multiple-packages-in-a-workspace">Multiple Packages In A Workspace</a></li>
<li><a href="workspaces/workspace-guide.html#announcement-tags">Announcement Tags</a></li>
<li><a href="workspaces/workspace-guide.html#singular-library-hack">Singular Library Hack</a></li>
<li><a href="workspaces/workspace-guide.html#using-cargo-release">Using cargo-release</a></li>
</ul>
<p>Now that we've <a href="workspaces/./simple-guide.html">looked at a simple example</a> with <code>cargo new</code>, let's start looking at ways to make a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> more complicated, and how dist will deal with them.</p>
<p>But first, let's define some precise terminology:</p>
<p>Rust projects typically exist as a single <em><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Workspace</a></em>, which is a collection of one or more <em><a href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package">Packages</a></em> that are all developed in the same repository (<a href="https://crates.io/">crates.io</a> dependencies are not considered part of the workspace). A workspace always has a root Cargo.toml where certain workspace-global settings are defined.</p>
<p>If the root Cargo.toml <em>doesn't</em> define a Package then we say it's a <em><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">Virtual Workspace</a></em>. A Virtual Workspace puts all the packages on the same level, treating them as equals. If you don't use a Virtual Workspace you are essentially saying the entire project exists to produce that one root Package. Both approaches make sense in different contexts. I personally prefer virtual workspaces because it makes cargo (and other tools) default to operating on all packages at once, which is usually what I want (e.g. I want <code>cargo test</code> to test the entire workspace, I want <code>cargo fmt</code> to format the whole workspace, and so on).</p>
<p>A <em><a href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package">Package</a></em> is the thing defined by a Cargo.toml (except for the root Cargo.toml of a Virtual Workspace, which defines no package). Many people reasonably assume "Package" and "Crate" are synonyms -- after all you host your Packages on a website called "<a href="https://crates.io/">crates.io</a>"! As it turns out, this is not the case: a Package can in fact define multiple Crates at the same time.</p>
<p>A <em><a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">Crate</a></em> is the actual unit of compilation that <em>rustc</em> thinks about, like a single library or binary. For the purposes of dist, you don't really need a perfect understanding of what is or isn't a "crate". The important takeaway is that a single Package can contain multiple things that are conflated with a single unified name and version. As we'll see, this can be useful.</p>
<h2 id="multiple-binaries-in-one-package"><a class="header" href="#multiple-binaries-in-one-package">Multiple Binaries In One Package</a></h2>
<p>So here's where the difference between a "Package" and a "Crate" is most relevant: <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">Cargo lets a single Package define multiple binaries</a>. See those docs for all the details. This can be convenient if you want to produce a single logical application that provides a suite of CLIs. For instance, you might want to make a standalone "my-tool" CLI that can be invoked as <code>cargo my-tool</code> as well. The easiest way to do this is to define a second "cargo-my-tool" binary as part of the "my-tool" Package. Once you do, <code>cargo install my-tool</code> will install both!</p>
<p>dist tries to respect this semantic. If you define multiple binaries in a Package, we will treat the Package as one "Application" and bundle both binaries in all zips and <a href="workspaces/../installers/index.html">installers</a> for that App. There is no way to override this behaviour -- if you don't want two binaries to be considered part of the same App, you should use separate Packages.</p>
<h2 id="multiple-packages-in-a-workspace"><a class="header" href="#multiple-packages-in-a-workspace">Multiple Packages In A Workspace</a></h2>
<p>Alright here's where things get a bit more complicated and you need to make a decision on how exactly you plan to develop and release the packages that make up your project. Up until now we've been assuming you have a single package in your workspace, but now we're going to deal with more.</p>
<p>How dist interprets multiple packages is actually fairly simple:</p>
<ul>
<li>Each Package that defines binaries is considered an "App" with completely independent zips/installers</li>
<li>Each Package that doesn't define binaries is wholly irrelevant and ignored</li>
</ul>
<p>If a Package defines binaries but you want dist to ignore it just like it does with library-only packages (i.e. because the binaries are for local testing), you can do that with either:</p>
<ul>
<li><a href="workspaces/../reference/config.html#publish"><code>publish = false</code> in that Package's Cargo.toml</a></li>
<li><a href="workspaces/../reference/config.html#dist"><code>dist = false</code> in that Package's <code>[package.metadata.dist]</code></a></li>
</ul>
<p>Now here's the really important question you need to answer: <strong>how do you want to announce new versions of your packages?</strong></p>
<h2 id="announcement-tags"><a class="header" href="#announcement-tags">Announcement Tags</a></h2>
<blockquote>
<p>See <a href="workspaces/./cargo-release-guide.html">the guide on using dist with cargo-release for more detailed documentation of how to tag your commits in various workspace configurations</a>!</p>
</blockquote>
<p>When you push a Git Tag to your repository, dist's CI will try to create a single Announcement (A Github Release) for that tag. When you only have one Package that's a completely unambiguous operation. When you have multiple Packages we now need some way to disambiguate what you actually meant.</p>
<p>1 Git Tag = 1 dist Announcement = 1 Github Release</p>
<p>dist supports two forms of Announcement which you can select with the format of your Git Tag:</p>
<ul>
<li>Unified Announcement: VERSION selects all packages with the given version (v1.0.0, 0.1.0-prerelease.1, releases/1.2.3, ...)</li>
<li>Singular Announcement: PACKAGE-VERSION or PACKAGE/VERSION selects only the given package (my-app-v1.0.0, my-app/1.0.0, release/my-app/v1.2.3-alpha, ...)</li>
</ul>
<blockquote>
<p>People love their different tag formats, so we do our best to parse lots
of different kinds! Prefixing the version with <code>v</code> is optional. Anything
that comes before a <code>/</code> is ignored unless it's exactly a package name
(so <code>really/cool/5.0.0/releases/v1.0.0</code> is just read as "1.0.0"). Note
that something like "1.0" is not a valid <a href="https://docs.rs/semver/latest/semver/struct.Version.html#errors">Cargo SemVer Version</a>.</p>
</blockquote>
<p>These two modes support the following workflows:</p>
<ul>
<li>Releasing a workspace with only one App (either mode works but Unified is Best)</li>
<li>Releasing a workspace where all Apps are versioned in lockstep (Unified)</li>
<li>Releasing an individual App in a workspace with its own independent versioning (Singular)</li>
<li>Releasing several Apps in a workspace at once, but all independently (Push multiple Singular tags at once)</li>
</ul>
<blockquote>
<p>NOTE: Although you <em>could</em> use extremely careful versioning in conjunction with Unified Announcements to release a weird subset of the packages in your workspace, you really <em>shouldn't</em> because the Github Releases will be incoherent (v0.1.0 has these random packages, v0.2.0 has these other random packages... huh?), and you're liable to create painful tag collisions.</p>
</blockquote>
<p><strong>The need for a coherent Announcement Tag is so important that dist commands like "build" and "manifest" will error out if one isn't provided and it can't be guessed.</strong> If that happens you may need to pass an explicit <code>--tag=...</code> flag to disambiguate. Being this strict helps catch problems before you push to CI.</p>
<h2 id="singular-library-hack"><a class="header" href="#singular-library-hack">Singular Library Hack</a></h2>
<p>Normally dist will error out if the Announcement Tag selects no Apps, because it exists to build and distribute Apps and you just asked it to do nothing (which is probably a mistake). This would however create annoying CI errors if you just wanted to tag releases for your libraries.</p>
<p>For 0.0.3 I opted for this kind of weird half-functionality:</p>
<p><strong>dist will produce a very minimal build-less Announcement (and therefore Github Release) if you explicitly request a Singular Announcement that matches a library-only package</strong>. This feature is kind of half-baked, please let us know what you want to happen in this situation!</p>
<p>We'll probably have to add a config for specifying whether you want libraries to get Announcements or not when you push a singular tag for them.</p>
<h2 id="using-cargo-release"><a class="header" href="#using-cargo-release">Using cargo-release</a></h2>
<p>See <a href="workspaces/./cargo-release-guide.html">the dedicated guide to using cargo-release with dist</a>, which covers all sorts of nasty workspaces (it's also just a more useful in-depth look at ).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-cargo-release-1"><a class="header" href="#using-cargo-release-1">Using cargo-release</a></h1>
<ul>
<li><a href="workspaces/cargo-release-guide.html#cargo-release-basics">cargo-release Basics</a></li>
<li><a href="workspaces/cargo-release-guide.html#cargo-release-advanced-usage">cargo-release Advanced Usage</a></li>
<li><a href="workspaces/cargo-release-guide.html#one-package">One Package</a></li>
<li><a href="workspaces/cargo-release-guide.html#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a>
<ul>
<li><a href="workspaces/cargo-release-guide.html#using-slash-in-tag-prefix-with-cargo-release">Using slash in tag prefix with cargo-release</a></li>
</ul>
</li>
<li><a href="workspaces/cargo-release-guide.html#virtual-workspace-with-unified-versions">Virtual Workspace With Unified Versions</a></li>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-unified-versions">Non-Virtual Workspace With Unified Versions</a></li>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-totally-independent-versions">Non-Virtual Workspace With Totally Independent Versions</a></li>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-independent-libraries">Non-Virtual Workspace With Independent Libraries</a></li>
<li><a href="workspaces/cargo-release-guide.html#library-only-workspaces">Library-only Workspaces</a></li>
<li><a href="workspaces/cargo-release-guide.html#previewing-your-release">Previewing Your Release</a></li>
<li><a href="workspaces/cargo-release-guide.html#using-cargo-release-with-pull-requests">Using cargo-release with Pull Requests</a></li>
</ul>
<blockquote>
<p>NOTE: It will be helpful to read <a href="workspaces/./workspace-guide.html#announcement-tags">the section on dist Announcement Tags</a>, because that is the interface boundary between cargo-release and dist. TL;DR: dist interprets a git tag of "v1.0.0" as "Announce/Release the whole workspace" (Unified Announcement) and "my-app-v1.0.0" or "my-app/v1.0.0" as "Announce/Release that one package" (Singular Announcement).</p>
</blockquote>
<blockquote>
<p>NOTE: this guide assumes you're running <a href="https://github.com/crate-ci/cargo-release/releases/tag/v0.22.0">cargo-release v0.22.0</a> or greater, as that version made several significant changes to default behaviours (for the better!).</p>
</blockquote>
<p>dist intentionally doesn't handle these steps of cutting a release for you:</p>
<ul>
<li>updating the versions of your packages</li>
<li>writing your release notes</li>
<li>committing the results</li>
<li>tagging your commits</li>
<li>pushing to your repo</li>
<li>publishing to crates.io</li>
</ul>
<p>There's a lot of different workflows for these things and we're happy to leave that to you. All dist cares about is that a tagged commit eventually ends up in your repo (and that the format of that commit reflects the versions/names in your Cargo.tomls).</p>
<p>That said, you might find <a href="https://github.com/crate-ci/cargo-release">cargo-release</a> useful because it can handle all of the above things for you in a single command like <code>cargo release 1.0.0</code>. This section is dedicated to explaining how to use cargo-release with dist in various situations.</p>
<h2 id="cargo-release-basics"><a class="header" href="#cargo-release-basics">cargo-release Basics</a></h2>
<blockquote>
<p>NOTE: cargo-release will never do anything side-effectful unless you also pass it <code>--execute</code>. Unless otherwise specified, we are discussing the behaviour when that flag is passed, but will be omitting it for safety/brevity.</p>
</blockquote>
<p>In <a href="workspaces/./simple-guide.html">a simple project</a> with one package, without any configuration set for cargo-release, the command <code>cargo release 1.0.0</code> is roughly sugar for:</p>
<pre><code class="language-sh">&lt;does some basic checks for uncommitted files and upstream being ahead&gt;
&lt;edits your Cargo.toml to have version 1.0.0&gt;
git commit -am "chore: Release my-app version 1.0.0"
git tag v1.0.0
cargo publish
git push --atomic &lt;remote-branch&gt; refs/tags/v1.0.0
</code></pre>
<p>(The <code>git push --atomic</code> is basically a more robust version of <code>git push &amp;&amp; git push --tags</code>)</p>
<p>Hey neat that's basically everything I listed at the start of this section! And the tag format is exactly what dist expects for <a href="workspaces/./simple-guide.html">a simple project</a>!! What a coincidence!!! ðŸ˜¸</p>
<p>If you don't want some of these behaviours, you can disable them permanently with <code>[workspace.metadata.release]</code> in your Cargo.toml, or disable temporarily with CLI flags. See the <a href="https://github.com/crate-ci/cargo-release/blob/master/docs/reference.md">cargo-release reference</a> for all the details but here's some important ones to only get a subset of the behaviours:</p>
<ul>
<li>Don't want to publish? Set <code>publish = false</code> in the config or pass <code>--no-publish</code></li>
<li>Don't want to push? Set <code>push = false</code> in the config or pass <code>--no-push</code></li>
<li>Don't want to tag? Set <code>tag = false</code> in the config or pass <code>--no-tag</code></li>
</ul>
<p>See <a href="workspaces/cargo-release-guide.html#using-cargo-release-with-pull-requests">this section for specific details on using cargo-release with github pull requests (PRs)</a>.</p>
<p>Note also that you can use <code>[package.metadata.release]</code> to set configs on individual packages and not the whole workspace.</p>
<h2 id="cargo-release-advanced-usage"><a class="header" href="#cargo-release-advanced-usage">cargo-release Advanced Usage</a></h2>
<p>With <a href="workspaces/./workspace-guide.html">a more complex project/workspace</a>, cargo-release won't work as well out of the box with dist. To understand why, we need to understand the rules it applies consistently that can be strange if unexpected.</p>
<p>When you run <code>cargo release</code> <strong>it should follow the same rules cargo does for selecting the subset of the workspace to operate on</strong>. That is, if you were to run <code>cargo test</code>, the packages that actually get tested are the same ones that <code>cargo release</code> will attempt to release! I'll try to briefly summarize (imperfectly, workspaces can get really Complicated):</p>
<ul>
<li>When run in the subdirectory of a package, execution is scoped to that package</li>
<li>When run in the root of a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (where the root Cargo.toml isn't an actual package), execution applies to all packages</li>
<li>When run in the root of a non-virtual workspace (where the root Cargo.toml is probably the "main" package that all other packages exist to implement), execution <strong>only applies to the root package</strong>.</li>
<li>When run with <code>--workspace</code>, execution applies to all packages (good for making a non-virtual workspace behave more like a virtual one).</li>
<li>Specific packages can be selected with <code>-p</code>/<code>--package</code></li>
<li>I haven't checked if cargo-release respects <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-default-members-field">default-members</a> but that's a thing too!</li>
</ul>
<p><strong>By default, cargo-release will create a separate git tag for every package it's releasing.</strong> The default format of these tags depends on the shape of your workspace:</p>
<ul>
<li>If there is a root package (the workspace is non-virtual), releases of the root package will be tagged as <code>v{VERSION}</code> ("v1.0.0").</li>
<li>All other packages will be tagged <code>{PACKAGE_NAME}-v{VERSION}</code> ("my-app-v1.0.0")</li>
</ul>
<p>As we'll see below, these combined behaviours have the following interactions with dist:</p>
<ul>
<li>âœ… one package workspace: tags it like "v1.0.0"</li>
<li>âœ… virtual workspace, independent versions: tags each package like "my-app-v1.0.0"</li>
<li>âœ… virtual workspace, independent versions: tags each package like "my-app/v1.0.0" (needs additional configuration in cargo-release, see below)</li>
<li>âŒ virtual workspace, unified versions: we want a single tag like "v1.0.0"</li>
<li>âŒ non-virtual workspace: it will mix the tag formats, which <em>might</em> be ok in one situation</li>
</ul>
<p>Now let's dig into each of these situations in more detail.</p>
<h2 id="one-package"><a class="header" href="#one-package">One Package</a></h2>
<p>TLDR: cargo-release Just Works.</p>
<pre><code class="language-sh">cargo release 1.0.0
</code></pre>
<hr />
<p>As stated previously, cargo-release works great with dist if you have <a href="workspaces/./simple-guide.html">a simple project</a> consisting of a single package (the kind of project <code>cargo new my-app</code> or <code>cargo init my-app</code> will create).</p>
<p>See the previous sections for what this will do and how to configure the behaviour if, e.g. you want to hold off on publishing to crates.io or pushing.</p>
<p>The more general version of this situation -- where you have one root package and all the other workspace members are libraries that exist to implement it -- has two possible solutions depending on how you want to version/release the libraries:</p>
<ul>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-unified-versions">version/release the libraries in lockstep</a></li>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-independent-libraries">version/release the libraries separately</a></li>
</ul>
<h2 id="virtual-workspace-with-independent-versions"><a class="header" href="#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a></h2>
<p>TLDR: cargo-release just needs you to specify which package to release.</p>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>If you have a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (one where the root Cargo.toml isn't an actual package) and want everything in the workspace to be versioned/released independently, then dist will default to operating on all your packages at once, and you should do the same thing you would do if you were running <code>cargo publish</code>: either use <code>-p</code> to select the relevant packages or <code>cd</code> into the subdir of that package before running the command.</p>
<p>Each tag will induce dist to produce an independent Announcement (Github Release) for that package.</p>
<p>If the package is a library the Github Release won't have any builds/artifacts uploaded. <a href="workspaces/./workspace-guide.html#singular-library-hack">See here for details</a>.</p>
<p>Note that we currently don't support finding/emitting Release Notes for Singular Releases (simply haven't had time to design and implement it yet).</p>
<h3 id="using-slash-in-tag-prefix-with-cargo-release"><a class="header" href="#using-slash-in-tag-prefix-with-cargo-release">Using slash in tag prefix with cargo-release</a></h3>
<p>For cargo-release to work with tag prefixes that use a slash, you must configure it to use a different prefix for tags in <code>Cargo.toml</code>.</p>
<p>For a virtual workspace, put the following in your root Cargo.toml:</p>
<pre><code class="language-toml">[workspace.metadata.release]
tag-prefix = "{{crate_name}}/"
</code></pre>
<p>Please refer to <a href="https://github.com/crate-ci/cargo-release/blob/master/docs/reference.md#configuration">the cargo-release reference</a> for further information on how you can configure cargo-release.</p>
<h2 id="virtual-workspace-with-unified-versions"><a class="header" href="#virtual-workspace-with-unified-versions">Virtual Workspace With Unified Versions</a></h2>
<p>TLDR: cargo-release just needs you to specify that versioning/tagging should be unified.</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (virtual manifest)
[workspace.metadata.release]
shared-version = true
tag-name = "v{{version}}"
</code></pre>
<pre><code class="language-sh">cargo release 1.0.0
</code></pre>
<hr />
<p>If you have a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (one where the root Cargo.toml isn't an actual package) and want everything in the workspace to be versioned/released in lockstep with a single Unified Announcement (One Big Github Release), then you're going to need to configure cargo-release as above.</p>
<p>After that it works perfectly, and cargo-release will even automagically handle publishing your packages to crates.io in the right sequence and waiting for the publishes to propagate before running the next one (no more "oops sorry the package you just published isn't actually propagated to the registry yet so the package that depends on it can't be published").</p>
<p>(See the next section on non-virtual workspaces with unified versions for some grittier details on what's going on here.)</p>
<h2 id="non-virtual-workspace-with-unified-versions"><a class="header" href="#non-virtual-workspace-with-unified-versions">Non-Virtual Workspace With Unified Versions</a></h2>
<p>TLDR: this is much the same as the virtual workspace case <strong>but you need to pass --workspace on the CLI</strong>.</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (virtual manifest)
[workspace.metadata.release]
shared-version = true
tag-name = "v{{version}}"
</code></pre>
<pre><code class="language-sh">cargo release 1.0.0 --workspace
</code></pre>
<hr />
<p>If you have a non-virtual workspace (one where the root Cargo.toml is a package) and want everything in the workspace to be versioned/released in lockstep with a single Unified Announcement (One Big Github Release), then it's <em>almost</em> the same as the virtual case (see the previous section).</p>
<p>The one caveat is that dist is consistent to a fault here, and even though we've explicitly told it things should be versioned/tagged in lockstep, <strong>running it in the root of your project still only releases the root package</strong>, and that's not what you want!</p>
<p>We need to tell it that we <em>really</em> meant it and pass <code>--workspace</code>!</p>
<p>What's happening here is that <code>cargo-release</code> is conceptually defined to run on each package individually, with just the "git push" step being unified. The tagging settings we're providing work because it's basically repeatedly going "oh hey I was already going to make that tag, no need to make it again". It doesn't have a proper notion of the entire workspace being released in perfect lockstep, so if you ask it to release only some of the packages it will happily oblige.</p>
<p>In the virtual workspace this Just Works because commands in the root directory are implicitly <code>--workspace</code>.</p>
<h2 id="non-virtual-workspace-with-totally-independent-versions"><a class="header" href="#non-virtual-workspace-with-totally-independent-versions">Non-Virtual Workspace With Totally Independent Versions</a></h2>
<p>TLDR: this is a more complicated mess because but you <em>probably</em> want to make the root package have the Singular Announcement format, and then you just need to be explicit about each package you want to release on the CLI:</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (main package)
[package.metadata.release]
tag-name = "{{crate_name}}-v{{version}}"
</code></pre>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>If you have a non-virtual workspace (one where the root Cargo.toml is a package) and want everything in the workspace to be versioned/released independently, then the simplest approach is to make everything behave like it does in the <a href="workspaces/cargo-release-guide.html#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a>.</p>
<p>However if you find yourself in this position it's likely that your workspace actually looks like:</p>
<ul>
<li>root package is The One Application this project exists to develop</li>
<li>all other packages are libraries that support it</li>
</ul>
<p>In this <em>precise</em> configuration you may be able to avoid configuration by adopting a hybrid "Partially Independent Versions" approach as described in the next section.</p>
<h2 id="non-virtual-workspace-with-independent-libraries"><a class="header" href="#non-virtual-workspace-with-independent-libraries">Non-Virtual Workspace With Independent Libraries</a></h2>
<p>TLDR: technically this Just Works but you need to be specific about what packages you're publishing and may have annoying issues in the future.</p>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>So if your workspace looks like this:</p>
<ul>
<li>root package is The One Application this project exists to develop</li>
<li>all other packages are libraries that support it</li>
</ul>
<p>Whenever you <code>cargo release</code> the root package, it will get tagged without a prefix ("v1.0.0") and dist will create a Unified Announcement. Even though there are other packages in the workspace, dist will take this in stride because as far as it's concerned <strong>this looks exactly the same as a workspace with one package</strong>. Which is to say, it's no different from <a href="workspaces/./simple-guide.html">a simple project</a> as far as dist is concerned.</p>
<p>Whenever you <code>cargo release</code> a library, it will get tagged with a prefix ("my-lib-v1.0.0") and dist will create a minimal Singular Announcement. <a href="workspaces/./workspace-guide.html#singular-library-hack">See here for details</a>. In future versions we might change this default (or at least make it configurable).</p>
<p>I have some vague concerns that this will be wonky if you ever introduce a second application to the workspace, but honestly that's probably going to be true regardless of if you were using dist, so maybe it's fine? Really I just don't trust non-virtual workspaces...</p>
<h2 id="library-only-workspaces"><a class="header" href="#library-only-workspaces">Library-only Workspaces</a></h2>
<p>dist really isn't designed for this but technically you can use the <a href="workspaces/./workspace-guide.html#singular-library-hack">Singular Library Trick</a> if you want. If you want dist to properly support this, please let us know!</p>
<h2 id="previewing-your-release"><a class="header" href="#previewing-your-release">Previewing Your Release</a></h2>
<p>cargo-release defaults to dry-run semantics, only doing side-effectful operations if you pass it <code>--execute</code>. It will also do its best to detect problems early and error out if things seem wrong. This absolutely rules!</p>
<p>There are two things to keep in mind:</p>
<ul>
<li>cargo-release's dry-run is imperfect and has some differences from the real run</li>
<li>cargo-release isn't aware of dist, so it can't check if what it's about to do will blow up in CI or not</li>
</ul>
<p>Let's start with the dry-run differences. I don't know them all but the <em>biggest</em> one that I hit is that it doesn't fully emulate bumping the versions in your Cargo.tomls. Notably when it checks if <code>publish</code> will work, it's building the current version of the packages. If your build is aware of its own version this can cause/miss problems (and you'll see funky stuff like "Upgrading my-app from 1.0.0 to 2.0.0" ... "Packaging my-app 1.0.0").</p>
<p>As for being aware of dist... I want to design some features for this, but I'm not quite sure what it should look like yet.</p>
<p>I think in the short-term, the best I can offer you is "make a temporary git branch and tell cargo-release to --execute but not push/tag/publish, then ask dist what it thinks extremely manually". A rough sketch:</p>
<pre><code class="language-sh"># make a temp branch where we can mess stuff up
git checkout -b tmp-release

# ask cargo-release what it thinks should happen
# (substitute the actual cargo-release command you'd use here)
cargo release 1.0.0
</code></pre>
<p>That should end with a line that looks like "Pushing main, v1.0.0 to origin". The first item is the branch it's pushing to, all the following items are all the tags it wants to push. Now that we know the tags, we can ask cargo-release to update the package versions and then ask dist what it thinks of those tags:</p>
<pre><code class="language-sh"># just bump versions
cargo release 1.0.0 --execute --no-push --no-tag --no-publish

# ask dist what should be produced for the given tag
dist plan --tag=&lt;tag-you-want-to-check&gt;
</code></pre>
<p>If that runs successfully and prints out the artifacts you expect, that's pretty good sign running cargo-release For Real will work! (You can also try <code>dist build</code> if you're worried about the actual build failing.)</p>
<h2 id="using-cargo-release-with-pull-requests"><a class="header" href="#using-cargo-release-with-pull-requests">Using cargo-release with Pull Requests</a></h2>
<blockquote>
<p>In this section we will be using <code>$BRANCH</code> and <code>$VERSION</code> as placeholders for the branch you make your PR on and the version you want to release.</p>
</blockquote>
<p>Many teams have policies that prevent pushing to main, and require you to open pull requests instead. This conflicts with the <em>default</em> behaviour of cargo-release, but it works fine with some extra flags to encourage it to defer the steps until later. Specifically, use the following to "partially" run cargo-release:</p>
<pre><code class="language-sh">cargo release --no-publish --no-tag --allow-branch=$BRANCH $VERSION
</code></pre>
<p>The release process then has the following steps:</p>
<ul>
<li>step 0: create a new branch for the PR</li>
<li>step 1: &lt; finalize things like changelogs and commit &gt;</li>
<li>step 2: <strong>partially</strong> run <code>cargo release ...</code> to update your Cargo.tomls and push your branch</li>
<li>step 3: &lt; open a pr, review, merge &gt;</li>
<li>step 4: <strong>fully</strong> run <code>cargo release</code> on main to complete the process (publish and tag)</li>
</ul>
<p>Crucially, neither invocation of <code>cargo release</code> will modify your main branch directly. Step 4 will only push a git tag for the commit that is already on main.</p>
<p>Here's what this looks in practice:</p>
<pre><code class="language-sh"># step 0: make a branch
git checkout -b $BRANCH


# step 1: update things like the changelog
# &lt; edit some files or whatever here &gt;
git commit -am "prep release"


# step 2: have cargo-release handle tedious mechanical stuff
# this will:
#  * do some safety checks like "git index is clean"
#  * update version numbers in your crates (and handle inter-dependencies)
#  * git commit -am "chore: release $NAME $VERSION" (one commit for the whole workspace)
#  * git push (remember we're on a branch)
cargo release --no-publish --no-tag --allow-branch=$BRANCH $VERSION


# step 3: open a PR and review/merge to main
# NOTE: the above steps will result in two commits
#       we recommend using github's "merge and squash" feature to clean up
# ...


# step 4: remove the shackles from cargo release and RUN ON MAIN
# this will:
#  * tag the commit
#  * push the tag
#  * publish all crates to crates.io (handles waiting for dep publishes to propagate)
#  * trigger dist when it sees the tag (if applicable)
# THIS WON'T CREATE NEW COMMITS
#
# running "dist plan" is totally optional, but this is is the best time to check
# that your dist release CI will produce the desired result when you push the tag
git checkout main
git pull
dist plan
cargo release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>The following sections are more focused on precise details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<ul>
<li><a href="reference/concepts.html#defining-your-apps">Defining Your Apps</a></li>
<li><a href="reference/concepts.html#defining-your-artifacts">Defining Your Artifacts</a></li>
<li><a href="reference/concepts.html#announcements-selecting-apps">Announcements (Selecting Apps)</a></li>
<li><a href="reference/concepts.html#artifact-modes-selecting-artifacts">Artifact Modes (Selecting Artifacts)</a>
<ul>
<li><a href="reference/concepts.html#all-artifacts-mode">All Artifacts Mode</a></li>
<li><a href="reference/concepts.html#global-artifacts-mode">Global Artifacts Mode</a></li>
<li><a href="reference/concepts.html#local-artifacts-mode">Local Artifacts Mode</a></li>
<li><a href="reference/concepts.html#host-artifacts-mode">Host Artifacts Mode</a></li>
</ul>
</li>
<li><a href="reference/concepts.html#putting-it-all-together">Putting It All Together</a></li>
</ul>
<p>Here's the section where I use a bunch of Capitalized Words to indicate they are a Special Concept in dist as I try to explain how it works. These are the "advanced" docs of dist; see <a href="reference/../workspaces/index.html">the guide</a> for the "beginner" docs.</p>
<p>An invocation of dist has 4 major inputs:</p>
<ul>
<li>The structure of your project's <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> (via <a href="https://doc.rust-lang.org/cargo/commands/cargo-metadata.html">cargo-metadata</a>)</li>
<li>The config in your Cargo.toml <code>[workspace.metadata.dist]</code> (and <code>[package.metadata.dist]</code>)</li>
<li>The "announcement tag" (e.g. <code>--tag=v1.0.0</code>)</li>
<li>The "artifact mode" (e.g. <code>--artifacts=all</code>)</li>
</ul>
<p>The first two define the full "Universe" of your project -- the platforms/binaries/<a href="reference/../installers/index.html">installers</a> that dist wants to build. The second two tell dist what subset of the Universe to actually bother with.</p>
<p>It's important to the structure of dist that every invocation is aware of the full Universe and how it's being subsetted, because for instance if you want a shell script installer that does platform detection and fetches binaries, it needs to know about all the binaries/platforms it has to select from, even if this <em>particular</em> run of dist won't build them all!</p>
<p>First let's look at how dist computes the Universe.</p>
<h1 id="defining-your-apps"><a class="header" href="#defining-your-apps">Defining Your Apps</a></h1>
<p>Each Cargo package in your workspace that has <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary targets</a> is considered an App by dist. dist exists to build Apps, so making sure you and it agree on is important! (We prefer "App" over "package" because we want the freedom to one day decouple the two concepts -- for now they are strictly equivalent.)</p>
<p>In addition to your executables dist can publish your <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#library">cdylibs</a>, including WASM bundles. Note that, for Rust specifically, there can be <a href="https://github.com/rust-lang/cargo/issues/6313">messy issues around Cargo clobbering itself when you define two many things under one package</a>.</p>
<p>Most invocations of dist will start by printing out a brief summary of the Apps that dist has found:</p>
<p><img src="reference/../img/workspace-log.png" alt="screenshot of the debug log, described below" /></p>
<p>The summary includes a list of every package in your workspace. If that package defines binaries, they will be listed underneath the package. If the package's listing is greyed out, that means dist has decided it's either Not An App or that it's not part of the current Announcement (<a href="reference/concepts.html#announcements-selecting-apps">see the Announcement section</a>), along with a parenthetical reason for its rejection, such as: "no binaries", "publish = false", "dist = false", or "didn't match tag".</p>
<p>In the above example the available Apps are "evil-workspace", "many-bin", and "third-bin". "many-bin" defines two binaries, while the other two Apps only define one.</p>
<p>To match cargo-install's behaviour, if a package defines multiple binaries then they will be considered part of the same App and zips/<a href="reference/../installers/index.html">installers</a> for it will contain/install all of them. We figure if you went out of your way to have multiple binaries under one package (as opposed to separate packages for each), you did that for a reason! If you don't want that, make separate packages. There is currently no way to group multiple packages into a single App, although there probably will be one day.</p>
<p>If you don't want a package-with-binaries to be considered an App that dist should care about, you can use Cargo's own builtin <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field">publish = false</a>. You can also use <code>dist = false</code> or <code>dist = true</code> in <a href="reference/../reference/config.html#dist">dist's own config</a>, which when defined will take priority over <code>publish</code>.</p>
<p>Distability can also be configured on the workspace level by using the <code>packages</code> setting in the workspace configuration. If set, this defines a specific list of packages which will be distributed, overriding any <code>dist = true</code> or <code>dist = false</code> configuration.</p>
<h1 id="defining-your-artifacts"><a class="header" href="#defining-your-artifacts">Defining Your Artifacts</a></h1>
<p>Ok so you've defined your App, but what should we actually build for it? Let's look at what <code>dist init --ci=github --installer=shell --installer=powershell --yes</code> dumps into your root Cargo.toml:</p>
<pre><code class="language-toml"># Config for 'dist'
[workspace.metadata.dist]
# The preferred dist version to use in CI (Cargo.toml SemVer syntax)
cargo-dist-version = "0.0.3"
# CI backends to support
ci = ["github"]
# The installers to generate for each app
installers = ["shell", "powershell"]
# Target platforms to build apps for (Rust target-triple syntax)
targets = ["x86_64-unknown-linux-gnu", "x86_64-apple-darwin", "x86_64-pc-windows-msvc", "aarch64-apple-darwin"]

# The profile that 'dist' will build with
[profile.dist]
inherits = "release"
lto = "thin"
</code></pre>
<p>The parts we're really interested in here are "installers", "targets", and <code>[profile.dist]</code>.</p>
<p>First the easy part: <code>profile.dist</code> is the profile dist will build everything with. We define a separate profile from <code>release</code> so that it can be tuned more aggressively for builds that are longer or more resource-intensive without making it tedious to develop locally.</p>
<p>The other 3 fields are defining the various Artifacts that should be produced for each App in the workspace (because this is <code>[workspace.metadata]</code> and not <code>[package.metadata]</code>).</p>
<p>For each entry in <code>targets</code> you will get a build of your App for <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">that platform</a> in the form of an <a href="reference/../artifacts/archives.html">archive</a>.</p>
<p>For each entry in <code>installers</code> you get that kind of <a href="reference/../installers/index.html">installer</a> for your App. There are two classes of installer: "global" and "local". This will be explained further in <a href="reference/concepts.html#artifact-modes-selecting-artifacts">the section on artifact modes</a>, but the tl;dr is that "global" installers are one-per-App while "local" installers are one-per-platform-per-app, similar to a <a href="https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs">Github CI Matrix</a>.</p>
<p>"shell" and "powershell" are both global installers. There aren't currently any implemented local installers, but those would be things like a windows "msi" or macos "dmg", where you ostensibly want individual installers for each architecture.</p>
<h1 id="announcements-selecting-apps"><a class="header" href="#announcements-selecting-apps">Announcements (Selecting Apps)</a></h1>
<p>dist's self-generated CI is triggered by pushing git tags with specific formats like "v1.0.0", "my-app-v1.0.0" or "my-app/v1.0.0". Each tag will trigger its own independent run of that CI workflow. That tag defines the subset of the workspace (what packages) we want to produce a single unified Announcement for (i.e. a single Github Release). Every invocation of dist in that CI run will be passed that git tag with the <code>--tag</code> flag to ensure consensus on what to Announce (and therefore build and upload).</p>
<p>1 Git Tag = 1 dist Announcement = 1 Github Release</p>
<p>Even when not running in CI, this concept of a coherent Announcement Tag is important enough that we will always try to guess one even if none is provided. The "build", "manifest", and "plan" commands will refuse to run if a coherent Announcement Tag can't be determined to help you catch problems before you start pushing to CI. If this happens you will get a printout telling you some options:</p>
<p><img src="reference/../img/announcement-error.png" alt="the error printout, described below" /></p>
<p>Here we have the same workspace we saw in the <a href="reference/concepts.html#defining-your-apps">"defining your apps" section</a>, but we get a complaint from <code>dist manifest</code>:</p>
<blockquote>
<p>There are too many unrelated apps in your workspace to coherently Announce!</p>
<p>Please either specify --tag, or give them all the same version</p>
</blockquote>
<p><strong>This introduces the one big rule for Announcements: all the Apps being Announced together have to agree on their Version.</strong> We need something to tie the announcement together and "3 random Apps with different Versions" has nothing to use! You should really just have 3 separate Announcements for those Apps. If you disagree, please let us know!</p>
<p>The error goes on to recommend the two formats for the Announcement Tag:</p>
<ul>
<li>Unified Announcement: VERSION selects all packages with the given version (v1.0.0, 0.1.0-prerelease.1, releases/1.2.3, ...)</li>
<li>Singular Announcement: PACKAGE-VERSION or PACKAGE/VERSION selects only the given package (my-app-v1.0.0, my-app/1.0.0, release/my-app/v1.2.3-alpha, ...)</li>
</ul>
<p>These two modes support the following workflows:</p>
<ul>
<li>Releasing a workspace with only one App (either mode works but Unified is Cleaner)</li>
<li>Releasing a workspace where all Apps are versioned in lockstep (Unified)</li>
<li>Releasing an individual App in a workspace with its own independent versioning (Singular)</li>
<li>Releasing several Apps in a workspace at once, but all independently (Push multiple Singular tags at once)</li>
</ul>
<p>In this case the error notes two valid Unified Announcements:</p>
<blockquote>
<p><code>--tag=v0.5.0</code> will Announce: evil-workspace, third-bin
<code>--tag=v0.7.6</code> will Announce: many-bin</p>
</blockquote>
<p>This tells us that evil-workspace and third-bin actually already agree on their Version. If we <em>do</em> want a Unified Announcement, we probably want to bring many-bin into agreement, or mark it as publish=false or dist=false.</p>
<p>Although you <em>could</em> use extremely careful versioning in conjunction with Unified Announcements to release a weird subset of the packages in your workspace, you really <em>shouldn't</em> because the Github Releases will be incoherent (v0.1.0 has these random packages, v0.2.0 has these other random packages... huh?), and you're liable to create painful tag collisions.</p>
<p>Normally dist will error out if the Announcement Tag selects no Apps, because it exists to build and distribute Apps and you just asked it to do nothing (which is probably a mistake). This would however create annoying CI errors if you just wanted to tag Individual Releases for your libraries. To make this more pleasant, <strong>dist will produce a very minimal build-less Announcement (and therefore Github Release) if you explicitly request a Singular Announcement that matches a library-only package</strong>. This feature is kind of half-baked, please let us know what you want to happen in this situation!</p>
<h1 id="artifact-modes-selecting-artifacts"><a class="header" href="#artifact-modes-selecting-artifacts">Artifact Modes (Selecting Artifacts)</a></h1>
<p>Now that we have a coherent Announcement and therefore have selected what apps we want to Release, we need to select what artifacts we want to build (or get a manifest for). Enumerating the exact artifacts for each invocation of dist would be tedious and error-prone, so we provide the <code>--artifacts=...</code> flag to specify the <em>Artifact Mode</em>, which is a certain subset of the Universe of all Artifacts:</p>
<ul>
<li>"local": artifacts that are per-target platform (<a href="reference/../artifacts/archives.html">archives</a>, symbols, msi installers...)</li>
<li>"global": artifacts that are one-per-app (shell installer, npm package...)</li>
<li>"all": both global and local (so the whole Universe)</li>
<li>"host": the default mode that kind of breaks the rules to let you test things out locally</li>
</ul>
<p>Let's ignore "host" mode for a bit and focus on the other three. Each one of these is intended to be used for specific tasks.</p>
<h2 id="all-artifacts-mode"><a class="header" href="#all-artifacts-mode">All Artifacts Mode</a></h2>
<p>The "all" Artifact Mode is largely intended for the <code>manifest</code> command, to get a listing of everything that would be produced if you were to push the given tag to CI. Here we check what v0.5.0 would produce for our favourite example workspace:</p>
<pre><code class="language-sh">dist manifest --tag=v0.5.0 --artifacts=all --no-local-paths
</code></pre>
<p><img src="reference/../img/human-manifest-all.png" alt="A listing of the various Artifacts that should be produced" /></p>
<p>If we add <code>--output-format=json</code> we will get the <code>dist-manifest.json</code> that CI uploads to your Github Release:</p>
<pre><code class="language-sh">dist manifest --tag=v0.5.0 --artifacts=all --no-local-paths --output-format=json
</code></pre>
<p>This is the only way that CI uses the flag, but you could also use "all" with <code>build</code> (the default dist command) if you want to get all the artifacts built at once, although you should probably filter the <code>--target</code>s as discussed in the section on "local".</p>
<p><code>dist manifest --artifacts=all --no-local-paths</code> is so useful/common that we provide an alias for it: <code>dist plan</code>. The above can be simplified to:</p>
<pre><code class="language-sh">dist plan --tag=v0.5.0
</code></pre>
<pre><code class="language-sh">dist plan --tag=v0.5.0 -ojson
</code></pre>
<h2 id="global-artifacts-mode"><a class="header" href="#global-artifacts-mode">Global Artifacts Mode</a></h2>
<p>The "global" Artifact Mode allows you to unambiguously create a task that will build all the Artifacts for your Apps that <em>aren't</em> platform-specific and therefore only need to be made once per App:</p>
<pre><code class="language-sh">dist build --tag=v0.5.0 --artifacts=global --no-local-paths
</code></pre>
<p><img src="reference/../img/global-build.png" alt="A global build producing only shell and powershell installers" /></p>
<p>Here we see that it only results in the "shell" and "powershell" installers getting built. The code to generate these should be totally cross-platform, so any runner is suitable for the task. The CI creates one "global" task that uses linux because that's the fast/cheap one.</p>
<h2 id="local-artifacts-mode"><a class="header" href="#local-artifacts-mode">Local Artifacts Mode</a></h2>
<p>The "local" Artifact Mode allows you to unambiguously create a task that will build all the Artifacts for your Apps that <em>are</em> platform-specific and therefore should have a copy made for every target platform.</p>
<p>If you just use this flag bare, dist <em>will</em> respect the request and try to build for all platforms at once... and this will probably fail, because cross-compilation is hard. Each "local" run should generally use <code>--target</code> to filter down the set of all supported targets to the ones you can confidently build on the current machine (<code>rustc -vV</code> will tell you the "host" target platform if you're not sure).</p>
<p>In my case it's "x86_64-pc-windows-msvc", so let's try that:</p>
<pre><code class="language-sh">dist build --tag=v0.5.0 --artifacts=local --target=x86_64-pc-windows-msvc --no-local-paths
</code></pre>
<p><img src="reference/../img/local-build.png" alt="A local build producing only archives for the current platform" /></p>
<p>Note that you can pass <code>--target</code> multiple times to select more than one. Note also that <code>--target</code> is not allowed to select targets that aren't specified by the config your Cargo.toml. This ensures that global installers are consistently aware of all the platform-specific artifacts they can fetch. ("host" mode breaks this rule.) ((Also in theory <code>--installer</code> should work the same for selecting specific installers but it's not well tested because there isn't any reason to ever use that outside of <code>dist init</code>.))</p>
<p>CI will spin up one "local" task for each of the major desktop platforms, grouping the targets that are easy to build on those platforms together. In the future we might want to spawn one task per target, or at least make that an option you can pick. That said, some Artifacts like macOS universal binaries may find it useful to have multiple targets built on the same machine!</p>
<h2 id="host-artifacts-mode"><a class="header" href="#host-artifacts-mode">Host Artifacts Mode</a></h2>
<p>Host mode is the default "do something useful on my machine" mode. It's intended for testing and demoing dist on your project, and is never used in CI due to its intentionally fuzzy semantics.</p>
<p>It's currently roughly equivalent to <code>--artifacts=all --target=HOST_TARGET</code>, but HOST_TARGET is allowed to fall outside the set of targets defined in your Cargo.toml, because it's not terribly useful to tell someone trying out dist on ARM64 Linux that their platform isn't defined in the config.</p>
<p>If you <em>do</em> pass <code>--target</code> in host mode then we won't do fuzzy target selection and will just build the targets you ask for like normal.</p>
<h1 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h1>
<p>Ok so here's what goes through dist's brains when you run it:</p>
<ol>
<li>Read in the workspace/config/cli-flags</li>
<li>Determine the Announcement Tag (select the Apps) ("v1.0.0")</li>
<li>Determine what Targets we're building for</li>
<li>Call the specific Version of each App a "Release" ("my-app-v1.0.0")</li>
<li>For each Release-Target pair, create a "ReleaseVariant" ("my-app-v1.0.0-x86_64-apple-darwin")</li>
<li>Add archive Artifacts to each Release (broadcasted to each Variant, filtered by Artifact Mode)</li>
<li>Add all the enabled Installers to each Release (local ones broadcasted to each Variant, filtered by Artifact Mode)</li>
<li>Compute the Build Steps necessary to produce each Artifact ("run cargo, copy this file, ...")</li>
<li>Generate top-level Announcement info like the body for a Github Release</li>
<li>run the Build Steps (ignored by <code>manifest</code>/<code>plan</code>)</li>
<li>print a manifest of the computed Announcement/Releases/Artifacts</li>
</ol>
<p>CI will parse the resulting (<code>--output-format=json</code>) manifest of each <code>build</code> invocation to know what artifacts were produced and need to be uploaded to the Github Release.</p>
<p>CI will just invoke dist in the following sequence:</p>
<ol>
<li>create-release: <code>dist manifest --artifacts=all --output-format=json --no-local-paths</code></li>
<li>upload-artifacts (local): <code>dist build --artifacts=local --target=... --output-format=json</code></li>
<li>upload-artifacts (global): <code>dist build --artifacts=global --output-format=json</code></li>
<li>publish-release: none, just marks the Github Release as a non-draft</li>
</ol>
<p>(All the upload-artifacts tasks are in parallel, and there are multiple "local" tasks to cover the target platforms.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifact-url"><a class="header" href="#artifact-url">Artifact URL</a></h1>
<ul>
<li><a href="reference/artifact-url.html#github">github</a>
<ul>
<li><a href="reference/artifact-url.html#linking-github-latest">Linking GitHub Latest</a></li>
</ul>
</li>
<li><a href="reference/artifact-url.html#other">Other</a></li>
<li><a href="reference/artifact-url.html#source-hosts">Source Hosts</a></li>
</ul>
<p><a href="reference/../installers/index.html">Fetching installers</a> need to know where to download the <a href="reference/../artifacts/archives.html">actual binaries</a> from, so dist needs to be aware of a base Artifact URL that it can derive download URLs from when it builds those kinds of installers.</p>
<p>Currently artifact URLs are derived from <a href="reference/./config.html#hosting">hosting providers</a> and <a href="reference/artifact-url.html#source-hosts">source hosts</a>. Both must be well-defined for fetching installers to be enabled. Here is the behaviour of each hosting provider in more excruciating detail:</p>
<h2 id="github"><a class="header" href="#github">github</a></h2>
<p>This host uploads your artifacts to a GitHub Release. Currently this functionality is restricted to <a href="reference/../ci/index.html">the "github" CI backend</a>. Because dist is fully in control of the uploading of your artifacts, it can automatically compute the Artifact URL for you, as:</p>
<pre><code class="language-text">{repo_url}/releases/download/{tag}
</code></pre>
<p>Where <code>repo_url</code> is <a href="reference/artifact-url.html#source-hosts">your source host repo_url</a>, and <code>tag</code> is the git tag of the release.</p>
<p>For example, if we want the linux build of axolotlsay 0.1.0, we have:</p>
<pre><code>* Cargo.toml "repository": `https://github.com/axodotdev/axolotlsay/`
* git tag: `v0.1.0`
* artifact url: `https://github.com/axodotdev/axolotlsay/releases/download/v0.1.0/`
* download: `https://github.com/axodotdev/axolotlsay/releases/download/v0.1.0/axolotlsay-x86_64-unknown-linux-gnu.tar.gz`
</code></pre>
<h3 id="linking-github-latest"><a class="header" href="#linking-github-latest">Linking GitHub Latest</a></h3>
<p>dist doesn't use this, but it's good for you to know: GitHub Releases lets you hotlink the files of "the latest release". This is useful for writing your own docs, as you can set them and forget them. dist specifically avoids putting version numbers in artifact names so that these kinds of URLs can be used.</p>
<p>The schema is (LOOK CLOSELY, IT IS NOT THE OBVIOUS SCHEMA, GITHUB DID THIS WEIRD):</p>
<pre><code>{repo_url}/releases/latest/download/
</code></pre>
<p>Example:</p>
<pre><code>https://github.com/axodotdev/cargo-dist/releases/latest/download/dist-manifest-schema.json
</code></pre>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p>Future releases <a href="https://github.com/axodotdev/cargo-dist/issues/236">will expose a more general mechanism for specifying artifact download URLs</a>.</p>
<h2 id="source-hosts"><a class="header" href="#source-hosts">Source Hosts</a></h2>
<p>Regardless of what <a href="reference/./config.html#hosting">hosting providers</a> you ask for, dist will complain if you don't have a properly defined source host, which is a fancy way of saying we need a URL to your git repo. Currently the only supported Source Host is <code>github.com</code>, but we <a href="https://github.com/axodotdev/cargo-dist/issues/48">would like to support more</a>.</p>
<p>Most Cargo projects already set a Source Host: it's just <a href="reference/./config.html#repository">your <code>[package].repository</code> URL</a>.</p>
<p>dist will parse this value and produce 3 values for your source host: owner, project, and repo_url. Here's an example:</p>
<pre><code>* Cargo.toml "repository": https://github.com/axodotdev/axolotlsay.git
* owner: axodotdev
* project: axolotlsay
* repo_url: https://github.com/axodotdev/axolotlsay/
</code></pre>
<p>(Note that in the above example the <code>repo_url</code> is not the verbatim <code>repository</code>; we support various common variations and will normalize them away for you!)</p>
<p><strong>For safety reasons, dist will refuse to accept a Source Host unless all packages in your workspace that define <code>repository</code> can be parsed to the exact same Source Host. Having inconsistent/outdated repository URLs is a very common issue. This check <em>does not</em> respect publish=false or dist=false!</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config"><a class="header" href="#config">Config</a></h1>
<p>These are the reference docs for configuring dist. <a href="reference/../updating.html">dist init</a> manages the most important of these for you, but if you ever need advanced configuration, this is where to look!</p>
<p>Configuration is currently read from the following sources, in increasing preference:</p>
<ol>
<li>Your language-specific project manifests like <a href="reference/../quickstart/rust.html">Cargo.toml</a> or <a href="reference/../quickstart/javascript.html">package.json</a></li>
<li>Your workspace dist config in <a href="reference/../quickstart/javascript.html">dist-workspace.toml</a> or <a href="reference/../custom-builds.html">dist.toml</a></li>
<li>Your package dist config in <a href="reference/../custom-builds.html">dist.toml</a></li>
</ol>
<p>We're currently in the middle of <a href="https://github.com/axodotdev/cargo-dist/pull/1247">a major config migration</a>. For <a href="reference/../quickstart/rust.html">existing Rust users</a>, all references to the <code>[dist]</code> section in dist-workspace.toml and dist.toml may also refer to <code>[workspace.metadata.dist]</code> or <code>[package.metadata.dist]</code> in your Cargo.toml.</p>
<p><a href="reference/config.html#the-dist-section"><code>[dist]</code></a></p>
<ul>
<li><a href="reference/config.html#allow-dirty"><code>allow-dirty</code></a></li>
<li><a href="reference/config.html#cargo-dist-version"><code>cargo-dist-version</code></a></li>
<li><a href="reference/config.html#dist"><code>dist</code></a></li>
<li><a href="reference/config.html#packages"><code>packages</code></a></li>
<li><a href="reference/config.html#targets"><code>targets</code></a></li>
<li><a href="reference/config.html#version"><code>version</code></a></li>
</ul>
<p><a href="reference/config.html#artifact-settings">artifact settings</a></p>
<ul>
<li><a href="reference/config.html#checksum"><code>checksum</code></a></li>
<li><a href="reference/config.html#extra-artifacts"><code>extra-artifacts</code></a></li>
<li><a href="reference/config.html#source-tarball"><code>source-tarball</code></a></li>
<li><a href="reference/config.html#recursive-tarball"><code>recursive-tarball</code></a></li>
<li><a href="reference/config.html#ssldotcom-windows-sign"><code>ssldotcom-windows-sign</code></a></li>
<li><a href="reference/config.html#artifact-settings">archive settings</a>
<ul>
<li><a href="reference/config.html#auto-includes"><code>auto-includes</code></a></li>
<li><a href="reference/config.html#include"><code>include</code></a></li>
<li><a href="reference/config.html#package-libraries"><code>package-libraries</code></a></li>
<li><a href="reference/config.html#unix-archive"><code>unix-archive</code></a></li>
<li><a href="reference/config.html#windows-archive"><code>windows-archive</code></a></li>
</ul>
</li>
</ul>
<p><a href="reference/config.html#build-settings">build settings</a></p>
<ul>
<li><a href="reference/config.html#dependencies"><code>dependencies</code></a></li>
<li><a href="reference/config.html#cargo-build-settings">cargo build settings</a>
<ul>
<li><a href="reference/config.html#all-features"><code>all-features</code></a></li>
<li><a href="reference/config.html#default-features"><code>default-features</code></a></li>
<li><a href="reference/config.html#features"><code>features</code></a></li>
<li><a href="reference/config.html#min-glibc-version"><code>min-glibc-version</code></a></li>
<li><a href="reference/config.html#msvc-crt-static"><code>msvc-crt-static</code></a></li>
<li><a href="reference/config.html#precise-builds"><code>precise-builds</code></a></li>
<li><a href="reference/config.html#rust-toolchain-version"><code>rust-toolchain-version</code></a></li>
<li><a href="reference/config.html#cargo-auditable"><code>cargo-auditable</code></a></li>
<li><a href="reference/config.html#cargo-cyclonedx"><code>cargo-cyclonedx</code></a></li>
<li><a href="reference/config.html#omnibor"><code>omnibor</code></a></li>
</ul>
</li>
</ul>
<p><a href="reference/config.html#installer-settings">installer settings</a></p>
<ul>
<li><a href="reference/config.html#installers"><code>installers</code></a></li>
<li><a href="reference/config.html#install-libraries"><code>install-libraries</code></a></li>
<li><a href="reference/config.html#bin-aliases"><code>bin-aliases</code></a></li>
<li><a href="reference/config.html#binaries"><code>binaries</code></a></li>
<li><a href="reference/config.html#shell-and-powershell-installer-settings">shell and powershell installer settings</a>
<ul>
<li><a href="reference/config.html#install-success-msg"><code>install-success-msg</code></a></li>
<li><a href="reference/config.html#install-path"><code>install-path</code></a></li>
<li><a href="reference/config.html#install-updater"><code>install-updater</code></a></li>
</ul>
</li>
<li><a href="reference/config.html#npm-installer-settings">npm installer settings</a>
<ul>
<li><a href="reference/config.html#npm-scope"><code>npm-scope</code></a></li>
<li><a href="reference/config.html#npm-package"><code>npm-package</code></a></li>
<li><a href="reference/config.html#npm-shrinkwrap"><code>npm-shrinkwrap</code></a></li>
</ul>
</li>
<li><a href="reference/config.html#homebrew-installer-settings">homebrew installer settings</a>
<ul>
<li><a href="reference/config.html#tap"><code>tap</code></a></li>
<li><a href="reference/config.html#formula"><code>formula</code></a></li>
</ul>
</li>
</ul>
<p><a href="reference/config.html#publisher-settings">publisher settings</a></p>
<ul>
<li><a href="reference/config.html#publish-jobs"><code>publish-jobs</code></a></li>
<li><a href="reference/config.html#publish-prereleases"><code>publish-prereleases</code></a></li>
</ul>
<p><a href="reference/config.html#hosting-settings">hosting settings</a></p>
<ul>
<li><a href="reference/config.html#hosting"><code>hosting</code></a></li>
<li><a href="reference/config.html#display"><code>display</code></a></li>
<li><a href="reference/config.html#display-name"><code>display-name</code></a></li>
<li><a href="reference/config.html#force-latest"><code>force-latest</code></a></li>
<li><a href="reference/config.html#github-hosting-settings">github hosting settings</a>
<ul>
<li><a href="reference/config.html#create-release"><code>create-release</code></a></li>
<li><a href="reference/config.html#github-attestations"><code>github-attestations</code></a></li>
<li><a href="reference/config.html#github-attestations-phase"><code>github-attestations-phase</code></a></li>
<li><a href="reference/config.html#github-attestations-filters"><code>github-attestations-filters</code></a></li>
<li><a href="reference/config.html#github-release"><code>github-release</code></a></li>
<li><a href="reference/config.html#github-releases-repo"><code>github-releases-repo</code></a></li>
<li><a href="reference/config.html#github-releases-submodule-path"><code>github-releases-submodule-path</code></a></li>
</ul>
</li>
<li><a href="reference/config.html#simple-hosting-settings">simple hosting settings</a>
<ul>
<li><a href="reference/config.html#simple-download-url"><code>simple-download-url</code></a></li>
</ul>
</li>
</ul>
<p><a href="reference/config.html#ci-settings">ci settings</a></p>
<ul>
<li><a href="reference/config.html#ci"><code>ci</code></a></li>
<li><a href="reference/config.html#build-local-artifacts"><code>build-local-artifacts</code></a></li>
<li><a href="reference/config.html#cache-builds"><code>cache-builds</code></a></li>
<li><a href="reference/config.html#dispatch-releases"><code>dispatch-releases</code></a></li>
<li><a href="reference/config.html#all-features"><code>fail-fast</code></a></li>
<li><a href="reference/config.html#merge-tasks"><code>merge-tasks</code></a></li>
<li><a href="reference/config.html#pr-run-mode"><code>pr-run-mode</code></a></li>
<li><a href="reference/config.html#tag-namespace"><code>tag-namespace</code></a></li>
<li><a href="reference/config.html#github-ci-settings">github ci settings</a>
<ul>
<li><a href="reference/config.html#github-custom-job-permissions"><code>github-custom-job-permissions</code></a></li>
<li><a href="reference/config.html#github-custom-runners"><code>github-custom-runners</code></a></li>
<li><a href="reference/config.html#github-build-setup"><code>github-build-setup</code></a></li>
<li><a href="reference/config.html#github-action-commits"><code>github-action-commits</code></a></li>
</ul>
</li>
<li><a href="reference/config.html#custom-ci-jobs">custom ci jobs</a>
<ul>
<li><a href="reference/config.html#plan-jobs"><code>plan-jobs</code></a></li>
<li><a href="reference/config.html#local-artifacts-jobs"><code>local-artifacts-jobs</code></a></li>
<li><a href="reference/config.html#global-artifacts-jobs"><code>global-artifacts-jobs</code></a></li>
<li><a href="reference/config.html#host-jobs"><code>host-jobs</code></a></li>
<li><a href="reference/config.html#publish-jobs"><code>publish-jobs</code></a></li>
<li><a href="reference/config.html#post-announce-jobs"><code>post-announce-jobs</code></a></li>
</ul>
</li>
</ul>
<p><a href="reference/config.html#the-workspace-section"><code>[workspace]</code></a></p>
<ul>
<li><a href="reference/config.html#workspacemembers"><code>members</code></a></li>
</ul>
<p><a href="reference/config.html#the-package-section"><code>[package]</code></a></p>
<ul>
<li><a href="reference/config.html#packagename"><code>name</code></a></li>
<li><a href="reference/config.html#packageversion"><code>version</code></a></li>
<li><a href="reference/config.html#packagedescription"><code>description</code></a></li>
<li><a href="reference/config.html#packageauthors"><code>authors</code></a></li>
<li><a href="reference/config.html#packagerepository"><code>repository</code></a></li>
<li><a href="reference/config.html#packagehomepage"><code>homepage</code></a></li>
<li><a href="reference/config.html#packagedocumentation"><code>documentation</code></a></li>
<li><a href="reference/config.html#packagechangelog"><code>changelog</code></a></li>
<li><a href="reference/config.html#packagereadme"><code>readme</code></a></li>
<li><a href="reference/config.html#packagelicense"><code>license</code></a></li>
<li><a href="reference/config.html#packagelicense-files"><code>license-files</code></a></li>
<li><a href="reference/config.html#packagebinaries"><code>binaries</code></a></li>
<li><a href="reference/config.html#packagecstaticlibs"><code>cstaticlibs</code></a></li>
<li><a href="reference/config.html#packagecdylibs"><code>cdylibs</code></a></li>
<li><a href="reference/config.html#packagebuild-command"><code>build-command</code></a></li>
</ul>
<hr />
<h1 id="the-dist-section"><a class="header" href="#the-dist-section">the <code>[dist]</code> section</a></h1>
<p>This section represents all the configuration for how dist should build and publish your applications. The <code>[dist]</code> section is a temporary placeholder which will soon be replaced (and automatically migrated) to a new hierarchy in <a href="https://github.com/axodotdev/cargo-dist/pull/1247">Config 1.0</a>.</p>
<h2 id="allow-dirty"><a class="header" href="#allow-dirty"><code>allow-dirty</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.3.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
allow-dirty = ["ci", "msi"]
</code></pre>
</blockquote>
<p>This is a list of <a href="reference/../reference/cli.html#dist-generate"><code>generate</code></a> tasks for dist to ignore when checking if generated configuration is up to date.</p>
<p><strong>We recommend avoiding setting this, as it prevents dist from updating these files for you whenever you update or change your configuration. If you think you need this, please <a href="https://github.com/axodotdev/cargo-dist/issues/new">do file an issue</a> or ask us about it, so we know what settings we're missing that necessitates this (or ideally, can point you to the existing settings).</strong></p>
<p>Nevertheless, setting can be necessary for users who customize their own configuration beyond dist's generated defaults and want to avoid dist overwriting it.</p>
<p>Possible values are:</p>
<ul>
<li>"ci": don't check/regenerate ci scripts (release.yml)</li>
<li>"msi": don't check/regenerate msi templates (main.wxs)</li>
</ul>
<h2 id="cargo-dist-version"><a class="header" href="#cargo-dist-version"><code>cargo-dist-version</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.3.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
default = <code>&lt;none&gt;</code> (this is mandatory!)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
cargo-dist-version = "0.10.0"
</code></pre>
</blockquote>
<p>This is added automatically by <a href="reference/../updating.html"><code>dist init</code></a>, and is a recording of its own version for the sake of reproducibility and documentation.</p>
<p>Your <a href="reference/../ci/index.html">release CI</a> will fetch and use the given version of dist to build and publish your project.</p>
<p>The syntax must be a valid <a href="https://docs.rs/semver/latest/semver/struct.Version.html">Cargo-style SemVer Version</a> (not a VersionReq!).</p>
<h2 id="dist"><a class="header" href="#dist"><code>dist</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.3.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>&lt;none&gt;</code> (infer it)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
dist = true
</code></pre>
</blockquote>
<p>Specifies whether dist <a href="reference/../artifacts/index.html">should distribute (build and publish) a package</a>, overriding all other rules for deciding if a package is eligible.</p>
<p>There are 3 major cases where you might use this:</p>
<ul>
<li><code>dist = false</code> on a package can be used to force dist to ignore it</li>
<li><code>dist = true</code> on a package can be used to force dist to distribute it in spite of signals like Cargo's <code>publish = false</code> that would suggest otherwise.</li>
<li><code>dist = false</code> on a whole workspace defaults all packages to do-not-distribute, forcing you to manually allow-list packages with <code>dist = true</code> (large monorepos often find this to be a better way of managing project distribution when most developers aren't release engineers).</li>
</ul>
<h2 id="packages"><a class="header" href="#packages"><code>packages</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.29.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>&lt;none&gt;</code> (infer it)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
packages = ["a", "b"]
</code></pre>
</blockquote>
<p><code>packages</code> provides a more explicit way of specifying which packages to dist (or not). If <code>packages</code> is set, it provides a list of exactly which packages should be distributed within the workspace. It overrides individual package-level <code>dist = true</code> or <code>dist = false</code> configuration.</p>
<h2 id="targets"><a class="header" href="#targets"><code>targets</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.0.3<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
targets = [
   "x86_64-pc-windows-msvc",
   "x86_64-unknown-linux-gnu",
   "x86_64-apple-darwin",
   "aarch64-apple-darwin",
]
</code></pre>
</blockquote>
<p>This is a list of <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">target platforms</a> you want your packages to be built for.</p>
<p>The supported choices are:</p>
<ul>
<li>x64 macOS: "x86_64-apple-darwin"</li>
<li>x64 Windows: "x86_64-pc-windows-msvc"</li>
<li>x64 Linux: "x86_64-unknown-linux-gnu"</li>
<li>arm64 macOS (Apple silicon): "aarch64-apple-darwin"</li>
<li>arm64 Linux: "aarch64-unknown-linux-gnu"</li>
<li>x64 Linux (static musl): "x86_64-unknown-linux-musl"</li>
<li>arm64 Linux (static musl): "aarch64-unknown-linux-musl"</li>
</ul>
<p>By default all runs of <code>dist</code> will be trying to handle all platforms specified here at once. If you specify <code>--target=...</code> on the CLI this will focus the run to only those platforms. As discussed in <a href="reference/../reference/concepts.html">concepts</a>, this cannot be used to specify platforms that are not listed in <code>metadata.dist</code>, to ensure different runs agree on the maximum set of platforms.</p>
<h2 id="version"><a class="header" href="#version"><code>version</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.29.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
default = <code>&lt;none&gt;</code> (infer it)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
version = "0.0.1"
</code></pre>
</blockquote>
<p>If set, this value will override the actual version configured for each package. For example, if the workspace contains packages versioned "0.2" and "0.3", and this value is set to "0.1", then dist will consider every package in the workspace to have the version "0.1".</p>
<h2 id="artifact-settings"><a class="header" href="#artifact-settings">artifact settings</a></h2>
<p><a href="reference/../artifacts/index.html">Artifacts</a> are the files that will be uploaded to <a href="reference/../ci/index.html">your hosting</a>. These settings affect what files those are, and what they contain. See also <a href="reference/config.html#installer-settings">installers</a> which are important enough to be separated out from other artifacts.</p>
<h3 id="checksum"><a class="header" href="#checksum"><code>checksum</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.1.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../artifacts/checksums.html">ðŸ“– read the checksum guide!</a> <br />
default = <code>"sha256"</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
checksum = "sha512"
</code></pre>
</blockquote>
<p>Specifies how to checksum other <a href="reference/../artifacts/index.html">artifacts</a>. Supported values:</p>
<ul>
<li>"sha256" - generate a .sha256 file for each archive</li>
<li>"sha512" - generate a .sha512 file for each archive</li>
<li>"sha3-256" - generate a .sha3-256 file for each archive</li>
<li>"sha3-512" - generate a .sha3-512 file for each archive</li>
<li>"blake2s" - generate a .blake2s file for each archive</li>
<li>"blake2b" - generate a .blake2b file for each archive</li>
<li>"false" - do not generate any checksums</li>
</ul>
<p>The hashes should match the result that sha256sum, sha512sum, etc. generate, and the file should be readable by those sorts of commands.</p>
<p>Future work is planned to <a href="https://github.com/axodotdev/cargo-dist/issues/120">support more robust signed checksums</a>.</p>
<h3 id="extra-artifacts"><a class="header" href="#extra-artifacts"><code>extra-artifacts</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.6.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the artifacts guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[[dist.extra-artifacts]]
artifacts = ["schema.json"]
build = ["cargo", "run", "--", "generate-schema"]

[[dist.extra-artifacts]]
artifacts = ["target/coolsignature.txt", "target/importantfile.xml"]
build = ["make"]
</code></pre>
</blockquote>
<p>(Note the <code>[[double-square-brackets]]</code>, you can specify multiple extra-artifacts entries!)</p>
<p>This specifies extra artifacts to build and upload to your <a href="reference/../ci/index.html">hosting</a>. Users can download these directly alongside other <a href="reference/../artifacts/index.html">artifacts</a> like <a href="reference/../artifacts/archives.html">archives</a> or <a href="reference/../installers/index.html">installers</a>.</p>
<p>Each extra-artifacts entry takes the following settings:</p>
<ul>
<li><code>build</code>: A command or script to run to produce these artifacts. This is an array of one or more strings; the first string is the command to run, and any subsequent strings are arguments to pass to that command.</li>
<li><code>artifacts</code>: An array of relative paths to files that dist expects to exist after the <code>build</code> command is run. Every file in this list will be uploaded individually to your release as its own artifact.</li>
</ul>
<p>dist uses this feature to distribute its <a href="reference/./schema.html"><code>dist-manifest-schema.json</code></a> as part of every release.</p>
<h3 id="source-tarball"><a class="header" href="#source-tarball"><code>source-tarball</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.14.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the artifacts guide!</a> <br />
default = <code>true</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
source-tarball = false
</code></pre>
</blockquote>
<p>By default, dist creates and uploads source tarballs from your repository. This setting disables that behaviour. This is especially useful for users who distribute closed-source software to hosts outside their git repos and who would prefer not to distribute source code to their users.</p>
<h3 id="recursive-tarball"><a class="header" href="#recursive-tarball"><code>recursive-tarball</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.29.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the artifacts guide!</a> <br />
default = <code>true</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
recursive-tarball = true
</code></pre>
</blockquote>
<p>By default, dist's source tarballs only includes the contents of your repository. Setting <code>recursive-tarball = true</code> switches to an alternate tarball generation method which includes the content of submodules.</p>
<h3 id="ssldotcom-windows-sign"><a class="header" href="#ssldotcom-windows-sign"><code>ssldotcom-windows-sign</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.14.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../supplychain-security/signing/windows.html">ðŸ“– read the windows signing guide!</a> <br />
default = <code>&lt;none&gt;</code> (disabled)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
ssldotcom-windows-sign = "prod"
</code></pre>
</blockquote>
<p>If you wish to sign your Windows artifacts (<a href="reference/../artifacts/index.html">EXEs</a> and <a href="reference/../installers/msi.html">MSIs</a>) such that Windows SmartScreen won't complain about them, this is the feature for you.</p>
<p>This setting takes one of two values:</p>
<ul>
<li>"prod": use the production ssl.com signing service</li>
<li>"test": use the testing ("sandbox") ssl.com signing service</li>
</ul>
<p>These strings match the <a href="https://github.com/SSLcom/esigner-codesign/blob/32825070bd8ca335577862dc735343ae155f2652/README.md#L48">environment_name setting</a> that <a href="https://github.com/SSLcom/esigner-codesign">SSL.com's code signing action uses</a> uses.</p>
<h3 id="archive-settings"><a class="header" href="#archive-settings">archive settings</a></h3>
<h4 id="auto-includes"><a class="header" href="#auto-includes"><code>auto-includes</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.0.3<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/archives.html">ðŸ“– read the archives guide!</a> <br />
default = <code>true</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
auto-includes = false
</code></pre>
</blockquote>
<p>Specifies whether dist should auto-include README, (UN)LICENSE, and CHANGELOG/RELEASES files in <a href="reference/../artifacts/archives.html">archives</a> and <a href="reference/../installers/index.html">installers</a>.</p>
<p>See also: <a href="reference/config.html#include"><code>include</code></a></p>
<h4 id="include"><a class="header" href="#include"><code>include</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.0.3<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/archives.html">ðŸ“– read the archives guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
include = [
   "my-cool-file.txt",
   "../other-cool-file.txt",
   "./some/dir/"
]
</code></pre>
</blockquote>
<p>This is a list of additional <em>files</em> or <em>directories</em> to copy into the root of all <a href="reference/../artifacts/archives.html">archives</a> and <a href="reference/../installers/index.html">installers</a>. Paths are relative to the config file. Globs are not supported.</p>
<p>All items specified will be placed in the root of the archive/installer (so in the above example <code>my-cool-file.txt</code>, <code>other-cool-file.txt</code>, and <code>dir</code> would be side-by-side with your binaries in an archive).</p>
<p>See also: <a href="reference/config.html#auto-includes"><code>auto-includes</code></a></p>
<h4 id="package-libraries"><a class="header" href="#package-libraries"><code>package-libraries</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.20.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
ðŸ”§ this is an experimental feature! <br />
<a href="reference/../artifacts/archives.html">ðŸ“– read the archives guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
package-libraries = ["cdylib", "cstaticlib"]
</code></pre>
</blockquote>
<p>Which kinds of <a href="reference/../artifacts/index.html">compiled libraries</a> to include in <a href="reference/../artifacts/archives.html">archives</a>. By default only <a href="reference/../artifacts/index.html">binaries</a> will be included in <a href="reference/../artifacts/archives.html">archives</a> and used to decide if a package should be <a href="reference/../artifacts/index.html">distributed</a>. This feature allows you to opt into bundling static and dynamic libraries that your package builds.</p>
<p>When enabled, libraries will be included in your <a href="reference/../artifacts/archives.html">archives</a> alongside your binaries, but <a href="reference/../installers/index.html">installers</a> will still ignore them. That can be changed using the <a href="reference/config.html#install-libraries"><code>install-libraries</code></a> setting.</p>
<h4 id="unix-archive"><a class="header" href="#unix-archive"><code>unix-archive</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.0.5<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/archives.html">ðŸ“– read the archives guide!</a> <br />
default = <code>".tar.xz"</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
unix-archive = ".tar.gz"
</code></pre>
</blockquote>
<p>Specifies the file format to use for <a href="reference/../artifacts/archives.html">archives</a> that target not-windows.</p>
<p>See <a href="reference/config.html#windows-archive">windows-archive</a> for a complete list of supported values.</p>
<h4 id="windows-archive"><a class="header" href="#windows-archive"><code>windows-archive</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.0.5<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/archives.html">ðŸ“– read the archives guide!</a> <br />
default = <code>".zip"</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
windows-archive = ".tar.gz"
</code></pre>
</blockquote>
<p>Allows you to specify the file format to use for <a href="reference/../artifacts/archives.html">archives</a> that target windows.</p>
<p>Supported values:</p>
<ul>
<li>".zip"</li>
<li>".tar.gz"</li>
<li>".tar.xz"</li>
<li>".tar.zstd" (deprecated for Zstd)</li>
<li>".tar.zst" (recommended for Zstd)</li>
</ul>
<p>See also: <a href="reference/config.html#unix-archive">unix-archive</a></p>
<h2 id="build-settings"><a class="header" href="#build-settings">build settings</a></h2>
<p>These settings configure <a href="reference/../artifacts/index.html">your builds</a>.</p>
<h3 id="dependencies"><a class="header" href="#dependencies"><code>dependencies</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.4.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist.dependencies.homebrew]
cmake = '*'
libcue = { stage = ["build", "run"] }

[dist.dependencies.apt]
cmake = '*'
libcue-dev = { version = "2.2.1-2" }

[dist.dependencies.chocolatey]
lftp = '*'
cmake = { version = '3.27.6', targets = ["aarch64-pc-windows-msvc"] }
</code></pre>
</blockquote>
<p>Allows specifying dependencies to be installed from a system package manager before the build begins. This is useful if your tool needs certain build tools (say, cmake) or links against C libraries provided by the package manager. This is specified in a Cargo-like format. Dependencies can be specified in two forms:</p>
<ul>
<li>A simple form, in which only a version is specified. If any version will do, use <code>'*'</code>.</li>
<li>A complex form, in several extra options can be specified.</li>
</ul>
<p>Supported options are:</p>
<ul>
<li><code>version</code> - A specific version of the package to install. This must be specified in the format that the package manager itself uses. Not used on Homebrew, since Homebrew does not support any method to specify installing specific versions of software.</li>
<li><code>stage</code> - When exactly dist should make use of this package. Two values are supported: <code>build</code>, which specifies that the package should be installed before the build occurs; and <code>run</code>, which specifies that the package should be installed alongside your software at the time end users run it. The default is <code>build</code>. If <code>run</code> is specified for Homebrew dependencies, and you've enabled the Homebrew installer, the Homebrew installer will specify those packages as dependencies.</li>
<li><code>targets</code> - A set of one or more targets to install the package on, in Rust target-triple format. If not specified, the package is installed on all targets. This is meant as an override to allow a package to be conditionally installed on only certain platforms; for example, a platform may need a build dependency only on Apple Silicon macOS, or have different build dependencies between x86_64 and ARM Windows.</li>
</ul>
<p>Supported package managers:</p>
<ul>
<li>Apt (Linux)</li>
<li>Chocolatey (Windows)</li>
<li>Homebrew (macOS)</li>
</ul>
<h3 id="cargo-build-settings"><a class="header" href="#cargo-build-settings">cargo build settings</a></h3>
<p>These settings are specific to how we <a href="reference/../artifacts/index.html">build your Cargo projects</a>.</p>
<h4 id="all-features"><a class="header" href="#all-features"><code>all-features</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.2.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the Cargo project guide!</a> <br />
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
all-features = true
</code></pre>
</blockquote>
<p>Specifies that all features for a Cargo package should be enabled when building it (when set to true this tells us to pass <code>--all-features</code> to Cargo).</p>
<h4 id="default-features"><a class="header" href="#default-features"><code>default-features</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.2.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the Cargo project guide!</a> <br />
default = <code>true</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
default-features = false
</code></pre>
</blockquote>
<p>Specifies that default features for a Cargo package should be enabled when building it (when set to false, this tells us to pass <code>--no-default-features</code> to Cargo).</p>
<h4 id="features"><a class="header" href="#features"><code>features</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.2.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the Cargo project guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
features = ["serde-support", "fancy-output"]
</code></pre>
</blockquote>
<p>Specifies feature-flags that should be passed to a Cargo package when building it. This lets you enable features that should be on "in production" but for whatever reason shouldn't be on by default.</p>
<p>For instance for packages that are a library and a CLI binary, some developers prefer to make the library the default and the CLI opt-in. In such a case you would want to add <code>features = ["cli"]</code> to your config.</p>
<h4 id="min-glibc-version"><a class="header" href="#min-glibc-version"><code>min-glibc-version</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.26.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
default = <code>{}</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist.min-glibc-version]
# Override glibc version for specific target triplets
aarch64-unknown-linux-gnu = "2.19"
x86_64-unknown-linux-gnu = "2.18"
# Override all remaining glibc versions.
"*" = "2.17"
</code></pre>
</blockquote>
<p>By default, dist will try to auto-detect the glibc version for each build for targets using glibc.</p>
<p>This setting allows you to override the minimum supported glibc version for specific target triplets, in case dist gets it wrong.</p>
<p>The special-cased <code>"*"</code> key will allow you to override the minimum supported glibc version for all targets that are not individually overridden.</p>
<p>Note that this setting only affects builds for Linux targets using the GNU libc (glibc). Non-Linux targets, or targets using another libc are not affected.</p>
<h4 id="msvc-crt-static"><a class="header" href="#msvc-crt-static"><code>msvc-crt-static</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.4.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the Cargo project guide!</a> <br />
default = <code>true</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
msvc-crt-static = false
</code></pre>
</blockquote>
<p>Specifies how The C Runtime (CRT) should be linked when building a Cargo package for Windows. Rust defaults to this being <code>= false</code> (dynamically link the CRT), but dist actually defaults to making this <code>= true</code> (statically link the CRT). <a href="https://github.com/rust-lang/rfcs/blob/master/text/1721-crt-static.md#future-work">The Rust default is mostly a historical accident, and it's widely regarded to be an error that should one day be changed</a>. Specifically it's a mistake for the typical Rust application which statically links everything else, because Windows doesn't actually guarantee that the desired things are installed on all machines by default, and statically linking the CRT is a supported solution to this issue.</p>
<p>However when you <em>do</em> want a Rust application that dynamically links more things, it then becomes correct to dynamically link the CRT so that your app and the DLLs it uses can agree on things like malloc. However Rust's default is still insufficient for reliably shipping such a binary, because you really should also bundle a "Visual C(++) Redistributable" with your app that installs your required version of the CRT. The only case where it's <em>probably</em> fine to not do this is when shipping tools for programmers who probably already have all of that stuff installed (i.e. anyone who installs the Rust toolchain will have that stuff installed).</p>
<p>This config exists as a blunt way to return to the default Rust behaviour of dynamically linking the CRT if you really want it, but more work is needed to handle Redistributables for that usecase.</p>
<p><a href="https://github.com/axodotdev/cargo-dist/issues/496">See this issue for details and discussion</a>.</p>
<h4 id="precise-builds"><a class="header" href="#precise-builds"><code>precise-builds</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.1.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the Cargo project guide!</a> <br />
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
precise-builds = true
</code></pre>
</blockquote>
<p>Build only the required Cargo packages, and individually.</p>
<p><a href="reference/config.html#inferring-precise-builds">See "inferring precise-builds" for the default behaviour.</a></p>
<p>By default when we need to build anything in your workspace, we try to build your entire workspace with <code>--workspace</code>. This setting tells dist to instead build each app individually.</p>
<p>On balance, the Rust experts we've consulted with find building with --workspace to be a safer/better default, as it provides some of the benefits of a more manual <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/about/index.html">workspace-hack</a>, without the user needing to be aware that this is a thing.</p>
<p>TL;DR: cargo prefers building one copy of each dependency in a build, so if two apps in your workspace depend on e.g. serde with different features, building with --workspace, will build serde once with the features unioned together. However if you build each package individually it will more precisely build two copies of serde with different feature sets.</p>
<p>The downside of using --workspace is that if your workspace has lots of example/test crates, or if you release only parts of your workspace at a time, we build a lot of gunk that's not needed, and potentially bloat up your app with unnecessary features.</p>
<p>If that downside is big enough for you, this setting is a good idea.</p>
<h5 id="inferring-precise-builds"><a class="header" href="#inferring-precise-builds">inferring precise-builds</a></h5>
<p>Although dist prefers <code>--workspace</code> builds (<a href="reference/config.html#precise-builds">precise-builds</a> = <code>false</code>) for the reasons stated above, it <em>will</em> attempt to check if that's possible, and use <code>--package</code> builds if necessary (<code>precise-builds = true</code>).</p>
<p>If you explicitly set <code>precise-builds = false</code> and we determine <code>--package</code> builds are required, dist will produce an error. <code>precise-builds = true</code> will never produce an error.</p>
<p>Precise-builds are considered required when you use any of <a href="reference/config.html#features">features</a>, <a href="reference/config.html#all-features">all-features</a>, or <a href="reference/config.html#default-features">default-features</a> <em>and</em> not all of the packages in your workspace have the same values set.</p>
<p>So for instance if you have several packages in your workspace and only one sets <code>all-features = true</code>, then we will require precise-builds, and will pass <code>--all-features</code> to only the <code>cargo build</code> for that package.</p>
<p>If we instead set <code>all-features = true</code> on the workspace, then we will just pass <code>--all-features</code> to <code>cargo build --workspace</code>.</p>
<h4 id="rust-toolchain-version"><a class="header" href="#rust-toolchain-version"><code>rust-toolchain-version</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.0.3<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
âš ï¸ deprecated in 0.1.0 <br />
<a href="reference/../artifacts/index.html">ðŸ“– read the Cargo project guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
rust-toolchain-version = "1.67.1"
</code></pre>
</blockquote>
<blockquote>
<p>Deprecation reason: <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rust-toolchain.toml</a> is a more standard/universal mechanism for pinning toolchain versions for reproducibility. Teams without dedicated release engineers will likely benefit from unpinning their toolchain and letting the underlying CI vendor silently update them to "some recent stable toolchain", as they will get updates/improvements and are unlikely to have regressions.</p>
</blockquote>
<p>This represents the "ideal" Rust toolchain to build your Cargo packages with. This is in contrast to the builtin Cargo <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field">rust-version</a> which is used to specify the <em>minimum</em> supported Rust version. Your CI scripts will install that version of the Rust toolchain with <a href="https://rust-lang.github.io/rustup/">rustup</a>.</p>
<p>The syntax must be a valid rustup toolchain like "1.60.0" or "stable" (should not specify the platform, we want to install this toolchain on all platforms).</p>
<p>Without this setting, CI won't explicitly setup a toolchain, so whatever's on the machine will be used (with things like rust-toolchain.toml behaving as normal).</p>
<h4 id="cargo-auditable-1"><a class="header" href="#cargo-auditable-1"><code>cargo-auditable</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.26.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
cargo-auditable = true
</code></pre>
</blockquote>
<p>Specifies whether to use <a href="https://github.com/rust-secure-code/cargo-auditable"><code>cargo auditable</code></a> to embed metadata about your dependency tree into the built executables.
When this value is false, dist will run <code>cargo build</code>; when it is true, dist will run <code>cargo auditable build</code>.</p>
<p>You can then use <a href="https://github.com/rustsec/rustsec/blob/main/cargo-audit/README.md"><code>cargo audit</code></a> to audit your dependencies for security vulnerabilities that have been reported to the <a href="https://rustsec.org/">RustSec Vulnerability Database</a>.</p>
<h4 id="cargo-cyclonedx-1"><a class="header" href="#cargo-cyclonedx-1"><code>cargo-cyclonedx</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.26.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
cargo-cyclonedx = true
</code></pre>
</blockquote>
<p>Specifies whether to use <a href="https://github.com/CycloneDX/cyclonedx-rust-cargo"><code>cargo cyclonedx</code></a> to generate and upload a Software Bill Of Materials (SBOM) for each project in a workspace.</p>
<h4 id="omnibor"><a class="header" href="#omnibor"><code>omnibor</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.26.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
omnibor = true
</code></pre>
</blockquote>
<p>Specifies whether to use <a href="https://github.com/omnibor/omnibor-rs/tree/main/omnibor-cli"><code>omnibor-cli</code></a> to generate and upload <a href="https://omnibor.io/docs/artifact-ids/">OmniBOR Artifact IDs</a> for artifact in a release.</p>
<h2 id="installer-settings"><a class="header" href="#installer-settings">installer settings</a></h2>
<p>Installers <a href="reference/../installers/index.html">main installer docs</a>!</p>
<h3 id="installers-1"><a class="header" href="#installers-1"><code>installers</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.0.3<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../installers/index.html">ðŸ“– read the installer guides!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
installers = [
  "shell",
  "powershell",
  "npm",
  "homebrew",
  "msi"
]
</code></pre>
</blockquote>
<p>This is a list of <a href="reference/../installers/index.html">installers</a> you want for your packages.</p>
<p>Possible values:</p>
<ul>
<li><a href="reference/../installers/shell.html">"shell": a curl-sh script for unixy systems</a></li>
<li><a href="reference/../installers/powershell.html">"powershell": an irm-iex script for Windows</a></li>
<li><a href="reference/../installers/npm.html">"npm": an npm package that runs prebuilt binaries</a></li>
<li><a href="reference/../installers/homebrew.html">"homebrew": a Homebrew formula</a></li>
<li><a href="reference/../installers/msi.html">"msi": a Windows MSI installer</a></li>
</ul>
<h3 id="bin-aliases"><a class="header" href="#bin-aliases"><code>bin-aliases</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.14.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../artifacts/index.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist.bin-aliases]
mybin = ["somealias"]
myotherbin = ["someotheralias", "anotheralias"]
</code></pre>
</blockquote>
<p>This is a map of binary names to aliases that your <a href="reference/../installers/index.html">installers</a> should create for those <a href="reference/../artifacts/index.html">binaries</a>. These aliases aren't included in your <a href="reference/../artifacts/archives.html">archives</a>, and are only created by the installers themselves. The way the alias is created is installer-specific, and may change in the future. Currently:</p>
<ul>
<li><a href="reference/../installers/shell.html">shell</a>: symlink</li>
<li><a href="reference/../installers/powershell.html">powershell</a>: hardlink</li>
<li><a href="reference/../installers/npm.html">npm</a>: extra "bins" pointing at the same command</li>
<li><a href="reference/../installers/homebrew.html">homebrew</a>: bin.install_symlink</li>
<li><a href="reference/../installers/msi.html">msi</a>: <strong>not currently supported</strong></li>
</ul>
<h3 id="binaries"><a class="header" href="#binaries"><code>binaries</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.29.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist.binaries]
x86_64-pc-windows-msvc = ["a", "b"]
</code></pre>
</blockquote>
<p>This setting allows overriding the list of binaries to install on a per-platform basis.</p>
<h3 id="install-libraries"><a class="header" href="#install-libraries"><code>install-libraries</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.20.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
ðŸ”§ this is an experimental feature! <br />
<a href="reference/../artifacts/index.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
install-libraries = ["cdylib", "cstaticlib"]
</code></pre>
</blockquote>
<p><strong>To use this feature, you must also enable the <a href="reference/config.html#package-libraries">package-libraries</a> setting.</strong></p>
<p>Which kinds of <a href="reference/../artifacts/index.html">compiled libraries</a> to unpack and installer with your <a href="reference/../installers/index.html">installers</a>.  When enabled, libraries will be installed alongside a package's <a href="reference/../artifacts/index.html">binaries</a>.</p>
<p>When using <a href="reference/../installers/shell.html">shell</a> and <a href="reference/../installers/powershell.html">powershell</a> installers The currently-supported <a href="reference/config.html#install-path">install-paths</a> will place libraries alongside binaries. This means they may appear in the user's <code>$PATH</code>, which you may find undesirable, and we may change it.</p>
<h3 id="shell-and-powershell-installer-settings"><a class="header" href="#shell-and-powershell-installer-settings">shell and powershell installer settings</a></h3>
<p>These settings are specific to the <a href="reference/../installers/shell.html">shell</a> and <a href="reference/../installers/powershell.html">powershell</a> installers, which provide a <code>curl | sh</code> installer for unix, and the equivalent <code>irm | iex</code> for windows. The two largely support the same things and behave the same, and typically want to be configured and enabled together.</p>
<h4 id="install-success-msg"><a class="header" href="#install-success-msg"><code>install-success-msg</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.15.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
ðŸ“– read the <a href="reference/../installers/shell.html">shell</a> and <a href="reference/../installers/powershell.html">powershell</a> installer guides!<br />
default = <code>"everything's installed!"</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
install-success-msg = "axolotlsay is ready to rumble! &gt;o_o&lt;"
</code></pre>
</blockquote>
<p>The message to display on success in the <a href="reference/../installers/shell.html">shell</a> and <a href="reference/../installers/powershell.html">powershell</a> installers.</p>
<h4 id="install-path"><a class="header" href="#install-path"><code>install-path</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.1.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
ðŸ“– read the <a href="reference/../installers/shell.html">shell</a> and <a href="reference/../installers/powershell.html">powershell</a> installer guides!<br />
default = <code>"CARGO_HOME"</code></p>
<p>*in your dist-workspace.toml or dist.toml:*s</p>
<pre><code class="language-toml">[dist]
install-path = "~/.my-app/"
</code></pre>
<pre><code class="language-toml">[dist]
install-path = ["$MY_APP_HOME/bin", "~/.my-app/bin"]
</code></pre>
</blockquote>
<p>The strategy that script installers (<a href="reference/../installers/shell.html">shell</a>, <a href="reference/../installers/powershell.html">powershell</a>) should use for selecting a path to install things at, with 3 possible syntaxes:</p>
<ul>
<li>
<p>"CARGO_HOME": installs as if <code>cargo install</code> did it (tries <code>$CARGO_HOME/bin/</code>, but if <code>$CARGO_HOME</code> isn't set uses <code>$HOME/.cargo/bin/</code>). Note that we do not (yet) properly update some of the extra metadata files Cargo maintains, so Cargo may be confused if you ask it to manage the binary.</p>
</li>
<li>
<p>"~/some/subdir/": installs to the given subdir of the user's <code>$HOME</code></p>
</li>
<li>
<p>"$SOME_VAR/some/subdir": installs to the given subdir of the dir defined by <code>$SOME_VAR</code></p>
</li>
</ul>
<blockquote>
<p>NOTE: <code>$HOME/some/subdir</code> is technically valid syntax but it won't behave the way you want on Windows, because <code>$HOME</code> isn't a proper environment variable. Let us handle those details for you and just use <code>~/subdir/</code>.</p>
</blockquote>
<p>All of these error out if none of the required env-vars are set to a non-empty value. Since 0.14.0 you can provide an array of options to try if all the previous ones fail. Such an "install-path cascade" would typically be used to provide an environment variable for changing the install dir, with a more hardcoded home subdir as a fallback:</p>
<pre><code class="language-toml">install-path = ["$MY_APP_HOME/bin", "~/.my-app/bin"]
</code></pre>
<p>It hasn't yet been tested whether this is appropriate to pair with things like <code>$XDG_BIN_HOME</code>, but we'd sure like it to be.</p>
<p>We do not currently sanitize/escape the path components (it's not really a security concern when the user is about to download+run an opaque binary anyway). In the future validation/escaping of this input will become more strict. We do appear to correctly handle spaces in paths on both windows and unix (i.e. <code>~/My dist Documents/bin/</code> works), but we won't be surprised if things misbehave on Interesting Inputs.</p>
<p>Future Improvements:</p>
<ul>
<li>In the future <a href="https://github.com/axodotdev/cargo-dist/issues/287">we may support XDG dirs</a></li>
<li>In the future <a href="https://github.com/axodotdev/cargo-dist/issues/288">we may support %windows dirs%</a></li>
<li>For historical reasons <code>CARGO_HOME</code> <a href="https://github.com/axodotdev/cargo-dist/issues/934">uses a slightly different install dir structure from the others</a>, and so for safety cannot be paired with the others strategies in an install-path cascade.</li>
</ul>
<p>(Please file an issue if you have other requirements!)</p>
<h4 id="install-updater"><a class="header" href="#install-updater"><code>install-updater</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../installers/updater.html">ðŸ“– read the updater guide!</a> <br />
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
install-updater = true
</code></pre>
</blockquote>
<p>Determines whether to install a standalone updater program alongside your program when using the <a href="reference/../installers/shell.html">shell</a> or <a href="reference/../installers/powershell.html">powershell</a> installers. This program will be named <code>yourpackage-update</code>, and can be run by the user to automatically check for newer versions and install them without needing to visit your website.</p>
<p>Users who received your package from a package manager, such as <a href="reference/../installers/homebrew.html">Homebrew</a> or <a href="reference/../installers/npm.html">npm</a>, will need to use the same package manager to perform upgrades.</p>
<p>This updater is the commandline tool contained in the open source <a href="https://github.com/axodotdev/axoupdater">axoupdater</a> package.</p>
<h3 id="npm-installer-settings"><a class="header" href="#npm-installer-settings">npm installer settings</a></h3>
<p>These settings are specific to the <a href="reference/../installers/npm.html">npm installer</a>.</p>
<h4 id="npm-scope"><a class="header" href="#npm-scope"><code>npm-scope</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.0.6<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../installers/npm.html">ðŸ“– read the npm installer guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
npm-scope = "@axodotdev"
</code></pre>
</blockquote>
<p>Specifies that <a href="reference/../installers/npm.html">npm installers</a> should be published under the given <a href="https://docs.npmjs.com/cli/v9/using-npm/scope">scope</a>. The leading <code>@</code> is mandatory. If you newly enable the npm installer in <code>dist init</code>'s interactive UI, then it will give you an opportunity to add the scope.</p>
<p>If no scope is specified the package will be global.</p>
<p>See also: <a href="reference/config.html#npm-package">npm-package</a></p>
<h4 id="npm-package"><a class="header" href="#npm-package"><code>npm-package</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.14.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../installers/npm.html">ðŸ“– read the npm installer guide!</a> <br />
default = <a href="reference/config.html#packagename">package.name</a></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
npm-package = "mycoolapp"
</code></pre>
</blockquote>
<p>Specifies that an <a href="reference/../installers/npm.html">npm installer</a> should be published under the given name, as opposed to the <a href="reference/config.html#packagename">name of the package</a> they are defined by.</p>
<p>This does not set the <a href="https://docs.npmjs.com/cli/v9/using-npm/scope">scope</a> the package is published under, for that see <a href="reference/config.html#npm-scope">npm-scope</a>.</p>
<h4 id="npm-shrinkwrap"><a class="header" href="#npm-shrinkwrap"><code>npm-shrinkwrap</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.31.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../installers/npm.html">ðŸ“– read the npm installer guide!</a> <br />
default = true</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
npm-shrinkwrap = false
</code></pre>
</blockquote>
<p>Specifies whether an <code>npm-shrinkwrap.json</code> should be written for the generated npm package. This affects the versions used for modules used to fetch your binary.</p>
<h3 id="homebrew-installer-settings"><a class="header" href="#homebrew-installer-settings">homebrew installer settings</a></h3>
<p>These settings are specific to the <a href="reference/../installers/homebrew.html">homebrew installer</a>.</p>
<h4 id="tap"><a class="header" href="#tap"><code>tap</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.2.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../installers/homebrew.html">ðŸ“– read the homebrew installer guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
tap = "axodotdev/homebrew-tap"
</code></pre>
</blockquote>
<p>This is the name of a GitHub repository which dist should publish the Homebrew installer to. It must already exist, and the token which creates releases must have write access.</p>
<p>It's conventional for the repo name to start with <code>homebrew-</code>.</p>
<h4 id="formula"><a class="header" href="#formula"><code>formula</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.11.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../installers/homebrew.html">ðŸ“– read the homebrew installer guide!</a> <br />
default = <a href="reference/config.html#packagename">package.name</a></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
formula = "axolotlbrew"
</code></pre>
</blockquote>
<p>Specifies the Homebrew formula name for a package, as opposed to the <a href="reference/config.html#packagename">package's name</a>.</p>
<p>This works well specifically for folks who are customizing their bin name and would like the Homebrew formula to match the bin name as opposed to the package name.</p>
<h2 id="publisher-settings"><a class="header" href="#publisher-settings">publisher settings</a></h2>
<p>These settings are specific to how we publish your packages to package managers like <a href="reference/../installers/homebrew.html">homebrew taps</a> and <a href="reference/../installers/npm.html">npm</a>.</p>
<h3 id="publish-prereleases"><a class="header" href="#publish-prereleases"><code>publish-prereleases</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.2.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
publish-prereleases = true
</code></pre>
</blockquote>
<p>If you set <code>publish-prereleases = true</code>, dist will <a href="reference/config.html#publish-jobs">publish</a> prerelease versions to package managers such as <a href="reference/../installers/homebrew.html">homebrew</a> and <a href="reference/../installers/npm.html">npm</a>. By default, dist will only publish stable versions to avoid polluting your releases. This is especially important for things like Homebrew which don't really have a proper notion of "prereleases" or "literally having more than one published version of a package".</p>
<h2 id="hosting-settings"><a class="header" href="#hosting-settings">hosting settings</a></h2>
<p>These settings govern how we host your files with platforms like <a href="reference/../ci/index.html">GitHub Releases</a>, and the text we tell them to display about your releases.</p>
<h3 id="hosting"><a class="header" href="#hosting"><code>hosting</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.5.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the releases guide!</a> <br />
default = <code>&lt;none&gt;</code> (infer based on <a href="reference/config.html#ci">ci</a>)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
hosting = ["simple", "github"]
</code></pre>
</blockquote>
<p>Possible values:</p>
<ul>
<li><code>github</code>: Use GitHub Releases (enabled if <a href="reference/config.html#ci">ci = "github"</a>)</li>
<li><code>simple</code>: Use a simple static file server (enabled if <a href="reference/config.html#simple-download-url">simple-download-url</a> is set)</li>
</ul>
<p>Specifies what hosting provider to use when downloading files for installers.</p>
<p>By default we will automatically use the native hosting of your CI provider, so when running on GitHub CI,
we'll default to using GitHub Releases for hosting/announcing.</p>
<p>If both <code>ci = "github"</code> and <code>simple-download-url = ...</code> are set, installers will be aware of both download sources,
and try <code>simple-download-url</code> first, falling back to downloading from GitHub Releases if that fails
(currently this fallback behaviour is only implemented for <a href="reference/../installers/shell.html">shell</a> and
<a href="reference/../installers/powershell.html">powershell</a>, other downloading installers will only try the highest priority one).</p>
<p>We prefer the simple URL over GitHub because this feature is often requested to work around GitHub Releases being unreliable.</p>
<p>By explicitly specifying <code>hosting</code> you can change the priority and whether a download source is consulted by installers:</p>
<ul>
<li><code>hosting = ["simple", "github"]</code> is the implicit default when both are enabled</li>
<li><code>hosting = ["github", "simple"]</code> specifies to instead try GitHub first and fallback to the simple URL if it fails</li>
<li><code>hosting = ["simple"]</code> specifies to <em>only</em> use the simple URL and ignore GitHub (if <code>ci = "github"</code> is set we will still upload to there)</li>
</ul>
<p>The preferred entry will also be the one rendered into things like <code>curl | sh</code> strings we emit.</p>
<h3 id="display"><a class="header" href="#display"><code>display</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.16.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the releases guide!</a> <br />
default = <code>true</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
display = false
</code></pre>
</blockquote>
<p>Specifies whether this package should be displayed in release bodies of <a href="reference/config.html#hosting">hosting providers</a> (like GitHub Releases). This is useful for hiding things that aren't the "primary" or "featured" application but still need to be included in the release for logistical reasons.</p>
<h3 id="display-name"><a class="header" href="#display-name"><code>display-name</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.16.0<br><a href="reference/config.html#setting-availabilities">package-local</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the releases guide!</a> <br />
default = <a href="reference/config.html#packagename">package.name</a></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
display-name = "my cool app"
</code></pre>
</blockquote>
<p>Specifies how to refer to the package in release bodies of <a href="reference/config.html#hosting">hosting providers</a> (like GitHub Releases). This is useful for situations where the package name <em>must</em> have a certain value for logistical reasons but you want to refer to it by a nicer name in marketing materials.</p>
<h3 id="force-latest"><a class="header" href="#force-latest"><code>force-latest</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.16.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the releases guide!</a> <br />
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
force-latest = true
</code></pre>
</blockquote>
<p>Overrides dist's default handling of prerelease versions. Ordinarily, dist uses <a href="https://semver.org">semver</a> rules to determine if a version number is a prerelease or not and has some special handling if it is. With this setting, dist will always consider a version to be the latest no matter what its version number is.</p>
<p>This means that the following prerelease handling behaviour will <strong>no longer apply</strong>:</p>
<ul>
<li>If dist interprets a version as a prerelease, it will <a href="reference/config.html#hosting">publish it to GitHub Releases</a> as a "prerelease" instead of the "latest" release.</li>
<li>dist will not publish prereleases to <a href="reference/../installers/homebrew.html">Homebrew</a> or <a href="reference/../installers/npm.html">npm</a> by default.</li>
</ul>
<p>See also: <a href="reference/config.html#publish-prereleases"><code>publish-prereleases</code></a></p>
<h3 id="github-hosting-settings"><a class="header" href="#github-hosting-settings">github hosting settings</a></h3>
<p>These settings govern how we host your files on <a href="reference/../ci/index.html">GitHub Releases</a> and the text we tell them to display.</p>
<h4 id="github-attestations"><a class="header" href="#github-attestations"><code>github-attestations</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.16.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
ðŸ”§ this is an experimental feature! <br />
<a href="reference/../supplychain-security/attestations/github.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
github-attestations = true
</code></pre>
</blockquote>
<p>If you're using GitHub Releases, this will enable GitHub's experimental artifact attestation feature.</p>
<h4 id="github-attestations-phase"><a class="header" href="#github-attestations-phase"><code>github-attestations-phase</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.30.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
ðŸ”§ this is an experimental feature! <br />
<a href="reference/../supplychain-security/attestations/github.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>"build-local-artifacts"</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
github-attestations-phase = "host"
</code></pre>
</blockquote>
<p>Most users won't need to use this feature. If you've enabled <code>github-attestations</code>, attestations are ordinarily performed while local builds are running. Users making use of the <a href="reference/config.html#build-local-artifacts"><code>build-local-artifacts = false</code></a> setting to perform their own builds won't be able to make use of attestations in that phase, so these users will need to move attestations to another phase.</p>
<p>Possible values:</p>
<ul>
<li><code>announce</code>: Create the GitHub Attestations during the <code>announce</code> phase. Make sure <code>github-release = "announce"</code> is also set to avoid permission side effects.</li>
<li><code>host</code>: Create the GitHub Attestations during the <code>host</code> phase. Make sure <code>github-release = "host"</code> is also set to avoid permission side effects.</li>
<li><code>build-local-artifacts</code>: Create the GitHub Attestations during the <code>build-local-artifacts</code> phase (default).</li>
</ul>
<h4 id="github-attestations-filters"><a class="header" href="#github-attestations-filters"><code>github-attestations-filters</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.30.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
ðŸ”§ this is an experimental feature! <br />
<a href="reference/../supplychain-security/attestations/github.html">ðŸ“– read the guide for this feature!</a> <br />
default = <code>["*"]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
github-attestations-filters = ["*.json", "*.sh", "*.ps1", "*.zip", "*.tar.gz"]
</code></pre>
</blockquote>
<p>Allows configuring which artifacts to perform GitHub Attestations for in the <code>host</code> phase. All patterns are globed against the pattern <code>artifacts/{filter}</code>.</p>
<p>This doesn't currently support attestations performed in the <code>build-local-artifacts</code> phase, but support for this may be added in the future.</p>
<h4 id="github-release"><a class="header" href="#github-release"><code>github-release</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.17.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the releases guide!</a> <br />
default = "auto"</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
github-release = "announce"
</code></pre>
</blockquote>
<p>Possible values:</p>
<ul>
<li><code>auto</code>: create the GitHub Release whenever is best</li>
<li><code>host</code>: create the GitHub Release during the host step</li>
<li><code>announce</code>: create the GitHub Release during the announce step</li>
</ul>
<p>Controls which stage of the release process the GitHub Release will be created in.</p>
<p>By default, the GitHub Release is created during the "host" phase, as it hosts the files some installers will try to download. <strong>Most users should be well-served by the default setting, and changing it is likely to introduce undesirable publishing race conditions.</strong> The only reason you might want to override this setting is if you're using <a href="reference/config.html#dispatch-releases"><code>dispatch-releases = true</code></a> and you really want your git tag to be the last operation in your release process (because creating a GitHub Release necessarily creates the git tag if it doesn't yet exist). In this case setting github-release = "announce" will accomplish that, but see below for what race conditions this might introduce.</p>
<p>If using only GitHub Releases, and you force it to run during "announce", there will be a very brief window (~30 seconds) during which generated <a href="reference/../installers/homebrew.html">Homebrew</a> and <a href="reference/../installers/npm.html">npm</a> installers are live and referencing URLs that will only exist when the GitHub Release is created, causing the packages to error out when installed.</p>
<p>However, if you're publishing only packages that don't reference hosted artifacts (such as Cargo crates, or any custom publish job that fully embeds the binaries), then there is no race, and you could consider changing the default. That said, it would be a looming footgun if you ever introduce new publish jobs and forget about this.</p>
<h4 id="github-releases-repo"><a class="header" href="#github-releases-repo"><code>github-releases-repo</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.14.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the releases guide!</a> <br />
default = <code>&lt;none&gt;</code> (use the project's own repository)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
github-releases-repo = "myorg/public"
</code></pre>
</blockquote>
<p>Allows specifying a different repo to publish GitHub Releases to than the current one. This can be used to publish to a public repo from a private one. Let's assume you want to publish to <code>myorg/public</code> from <code>myorg/private</code>. Then in your config in <code>myorg/private</code>, you'd set <code>github-releases-repo = "myorg/public"</code>.</p>
<p>To ensure the workflow has permission to do this, you need to create a <a href="https://github.com/settings/tokens/new?scopes=repo">GitHub Personal Access Token with the "repo" scope</a> that can access <code>myorg/public</code>. This must be added as a GitHub SECRET called <code>GH_RELEASES_TOKEN</code> on <code>myorg/private</code>.</p>
<p>GitHub Releases isn't really designed for this, so there's a few strange things that will happen here:</p>
<ul>
<li>
<p>GitHub Releases always requires a commit to be tagged, and in this case the tag would be on <code>myorg/public</code> even though the workflow is running on <code>myorg/private</code>, which (presumably) has unrelated commits. Currently <strong>we will tag the latest commit on the <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches#about-the-default-branch">default branch</a> of <code>myorg/public</code></strong>. If you're using <a href="reference/config.html#dispatch-releases">the dispatch-releases flow</a>, no tag will be created on <code>myorg/private</code>.</p>
</li>
<li>
<p>GitHub Releases will provide a source tarball pointing at the tagged commit on <code>myorg/public</code>, but that's (presumably) not the source that your release was actually built from. This cannot be disabled, but it's also essentially harmless. However <strong>dist uploads its own source tarball and that <em>WILL</em> contain the source of the private repo</strong>. If you don't want this, use <a href="reference/config.html#source-tarball">the <code>source-tarball = false</code> setting</a>.</p>
</li>
</ul>
<h4 id="github-releases-submodule-path"><a class="header" href="#github-releases-submodule-path"><code>github-releases-submodule-path</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.15.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the releases guide!</a> <br />
default = <code>&lt;none&gt;</code> (use the project's root repository)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
github-releases-submodule-path = "rel/path/to/submodule"
</code></pre>
</blockquote>
<p>Designed for use with <a href="reference/config.html#github-releases-repo">github-releases-repo</a> setting. When specified, the cached commit of the submodule at this path will be used as the commit to tag in the target repository. If not specified, the latest commit in the target repository will be used instead.</p>
<h4 id="create-release"><a class="header" href="#create-release"><code>create-release</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.2.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the releases guide!</a> <br />
default = <code>true</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
create-release = false
</code></pre>
</blockquote>
<p>Whether we should create the GitHub Release for you in your Release CI.</p>
<p>If true, dist will create a new GitHub Release and generate
a title/body for it based on your changelog.</p>
<p>If false, dist will assume a draft GitHub Release for the current git tag
already exists with the title/body you want, and just upload artifacts to it, undrafting when all artifacts are uploaded.</p>
<p>See also: <a href="reference/config.html#github-release"><code>github-release</code></a></p>
<h3 id="simple-hosting-settings"><a class="header" href="#simple-hosting-settings">simple hosting settings</a></h3>
<p>These settings govern how we host your files on a simple static file server.</p>
<p>This is an alternative to <a href="reference/config.html#github-hosting-settings">GitHub Hosting</a>. Installers that fetch binaries from the internet
can be configured to use only one of them or both. See the <a href="reference/config.html#hosting">hosting setting</a> for details.</p>
<p>This hosting mode is currently read-only -- it's up to you to actually upload the files to your servers.</p>
<h4 id="simple-download-url"><a class="header" href="#simple-download-url"><code>simple-download-url</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.16.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
simple-download-url = "https://static.myapp.com/{tag}"
</code></pre>
</blockquote>
<p>A template for a url to download a release from when using the simple host. <code>{tag}</code> will be replaced with the git tag
of the release (so if you tag like <code>v1.0.0</code> we will use that, if you tag like <code>1.0.0</code> we will use that). Currently
only <code>{tag}</code> is supported as a template variable.</p>
<p>The given URL is expected to be a directory containing the same filenames that we upload to a GitHub Release. So with
the above example URL, we will try to fetch something like
<code>https://static.myapp.com/v1.0.0/myapp-x86_64-unknown-linux-gnu.tar.gz</code>
or
<code>https://static.myapp.com/v1.0.0/myapp-x86_64-pc-windows-msvc.zip</code>.</p>
<h2 id="ci-settings"><a class="header" href="#ci-settings">ci settings</a></h2>
<p>These settings govern how <a href="reference/../ci/index.html">your CI should work</a>, including how to trigger the release process and custom tasks to run.</p>
<h3 id="ci-1"><a class="header" href="#ci-1"><code>ci</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.0.3<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
ci = ["github"]
</code></pre>
</blockquote>
<p>This is a list of CI backends you want to support, allowing dist to know what CI scripts to generate. Most dist features require this to be enabled!</p>
<p><a href="reference/../ci/index.html">"github"</a> is currently the only supported CI backend.</p>
<h3 id="build-local-artifacts"><a class="header" href="#build-local-artifacts"><code>build-local-artifacts</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.8.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>true</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
build-local-artifacts = false
</code></pre>
</blockquote>
<p><code>build-local-artifacts = false</code> disables the builtin CI jobs that would build your binaries and archives (and MSI installers). This allows a Sufficiently Motivated user to use custom <code>build-local-jobs</code> to completely replace dist's binary building with something like maturin.</p>
<p>The requirements are simply that you need your custom actions to:</p>
<ul>
<li>build archives (tarballs/zips) and checksums that the local CI was expected to produce</li>
<li>use the github upload-artifacts action to upload all of those to an artifact named <code>artifacts</code></li>
</ul>
<p>You can get a listing of the exact artifact names to use and their expected contents with:</p>
<pre><code>dist manifest --artifacts=local --no-local-paths
</code></pre>
<p>(<code>[checksum]</code> entries are separate artifacts and not actually stored in the archives.)</p>
<p>Also note that for legacy reasons a tarball is expected to have all the contents nested under a root dir with the same name as the tarball (sans extension), while zips are expected to have all the files directly in the root (installers pass <code>--strip-components=1</code> to tar when extracting).</p>
<h3 id="cache-builds"><a class="header" href="#cache-builds"><code>cache-builds</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.18.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>&lt;none&gt;</code> (inferred, probably <code>false</code>)</p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
cache-builds = true
</code></pre>
</blockquote>
<p>Determines whether CI will try to cache work between builds. Defaults false, unless <a href="reference/config.html#release-branch"><code>release-branch</code></a> or <a href="reference/config.html#pr-run-mode"><code>pr-run-mode = "upload"</code></a> are enabled.</p>
<p>This is unlikely to be productive because for safety the cache aggressively invalidates based on things like "Cargo.toml or Cargo.lock changed" (which is always true if you change the version of a Rust project), and a noop cache run can randomly take over 2 minutes (typically more like 10 seconds).</p>
<p>The cases where we enable it by default are the only ones we know where you <em>might</em> want to enable it.</p>
<h3 id="dispatch-releases"><a class="header" href="#dispatch-releases"><code>dispatch-releases</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.8.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
dispatch-releases = true
</code></pre>
</blockquote>
<p>When enabled, your release CI is triggered with workflow_dispatch instead of tag-push (relying on creating a GitHub release implicitly tagging).</p>
<p>Enabling this disables tag-push releases, but keeps pr checks enabled.</p>
<p>By default the workflow dispatch form will have "dry-run" populated as the tag, which is taken to have the same meaning as <a href="reference/config.html#pr-run-mode"><code>pr-run-mode = "upload"</code></a>: run the plan and build steps, but not the publish or announce ones. Currently hosting is also disabled, but future versions may add some forms of hosting in this mode.</p>
<h3 id="fail-fast"><a class="header" href="#fail-fast"><code>fail-fast</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.1.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
fail-fast = true
</code></pre>
</blockquote>
<p>Whether failing builds tasks should make us give up on all other build tasks.</p>
<p>When building a release in CI, you might discover that one platform's build is broken. When this happens you have two options: kill all other builds immediately (<code>fail-fast = true</code>), or keep trying to build all the other platforms anyway (<code>fail-fast = false</code>) to see what other platforms might have problems.</p>
<p>Either way, the global build task will refuse to run if any of these tasks fail, so you can't get any kind of partial release. However, if the build failure was spurious, resuming all failed tasks should resume without issue.</p>
<h3 id="pr-run-mode"><a class="header" href="#pr-run-mode"><code>pr-run-mode</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.3.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>"plan"</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
pr-run-mode = "upload"
</code></pre>
</blockquote>
<p>This setting determines to what extent we run your Release CI on pull-requests:</p>
<ul>
<li>"skip": don't check the release process in PRs</li>
<li>"plan": run 'dist plan' on PRs (recommended, also the default)</li>
<li>"upload": build and upload an artifacts to the PR (expensive)</li>
</ul>
<h3 id="tag-namespace"><a class="header" href="#tag-namespace"><code>tag-namespace</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.10.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
tag-namespace = "some-prefix"
</code></pre>
</blockquote>
<p>Setting <code>tag-namespace = "owo"</code> will change the tag matching expression we put in your GitHub CI, to require the tag to start with "owo" for dist to care about it. This can be useful for situations where you have several things with different tag/release workflows in the same workspace. It also renames <code>release.yaml</code> to <code>owo-release.yml</code> to make it clear it's just one of many release workflows.</p>
<p><strong>NOTE</strong>: if you change tag-namespace, dist will generate the new <code>owo-release.yml</code> file, but not delete the old one. Be sure to manually delete the old <code>release.yml</code>!</p>
<h3 id="merge-tasks"><a class="header" href="#merge-tasks"><code>merge-tasks</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.1.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>false</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
merge-tasks = true
</code></pre>
</blockquote>
<p>Whether we should try to merge otherwise-parallelizable tasks onto the same machine, sacrificing latency and fault-isolation for the sake of minor efficiency gains.</p>
<p>For example, if you build for x64 macos and arm64 macos, by default we will generate ci which builds those independently on separate logical machines. With this enabled we will build both of those platforms together on the same machine, making it take twice as long as any other build and making it impossible for only one of them to succeed.</p>
<p>The default is <code>false</code>. Before 0.1.0 it was always <code>true</code> and couldn't be changed, making releases annoyingly slow (and technically less fault-isolated). This setting was added to allow you to restore the old behaviour, if you really want.</p>
<h3 id="github-ci-settings"><a class="header" href="#github-ci-settings">github ci settings</a></h3>
<p>These settings are specific to <a href="reference/../ci/index.html">your dist GitHub CI</a>.</p>
<h4 id="github-build-setup"><a class="header" href="#github-build-setup"><code>github-build-setup</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.20.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
ðŸ”§ this is an experimental feature! <br />
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
github-build-setup = "path/to/build-setup.yml"
</code></pre>
</blockquote>
<p>This configuration value should be a path relative to the repository your <code>.github/workflows</code> directory.
The file located at that path should contain a yaml array of <a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsid">steps</a> which will be
performed before we call <code>dist build</code>.</p>
<h4 id="github-custom-job-permissions"><a class="header" href="#github-custom-job-permissions"><code>github-custom-job-permissions</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.18.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
publish-jobs = ["npm", "./my-custom-publish"]
github-custom-job-permissions = { "my-custom-publish" = { packages = "admin" } }
</code></pre>
</blockquote>
<p>Allows you to customize the permissions given to your custom CI jobs.</p>
<p>By default all custom <code>publish-jobs</code> get <code>{ id-token = "write", packages = "write" }</code>.
If you override a publish job's permissions, the default permissions will be removed.
All other custom jobs default to no special permissions.</p>
<h4 id="github-custom-runners"><a class="header" href="#github-custom-runners"><code>github-custom-runners</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.6.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist.github-custom-runners]
aarch64-unknown-linux-gnu = "buildjet-8vcpu-ubuntu-2204-arm"
aarch64-unknown-linux-musl = "buildjet-8vcpu-ubuntu-2204-arm"
</code></pre>
</blockquote>
<p>Allows specifying which runner to use for a target. The keys within this table are target triples in the same format as the <a href="reference/config.html#targets">"targets"</a> setting. Any targets not specified in this table will use the defaults.</p>
<p>In addition to defining runners for a target, it's also possible to specify a runner for the global, non-target-specific tasks using the <code>global</code> key. This runner will be used for tasks like <code>plan</code>, <code>host</code>, generating installers, and so on.</p>
<h3 id="github-action-commits"><a class="header" href="#github-action-commits"><code>github-action-commits</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.29.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist.github-action-commits]
"actions/checkout" = "11bd71901bbe5b1630ceea73d27597364c9af683"
</code></pre>
</blockquote>
<p>Allows overriding which version of a GitHub Action to use. This can be useful to replace the default set of tags used by dist with a specific pinned set of commits.</p>
<h3 id="custom-ci-jobs"><a class="header" href="#custom-ci-jobs">custom ci jobs</a></h3>
<p>These settings all similarly extend <a href="reference/../ci/index.html">your dist GitHub CI</a> with custom jobs to run at specific steps of the release process, which looks like:</p>
<ol>
<li>plan: check settings, decide what we're releasing</li>
<li>build-local: compile things for each platform</li>
<li>build-global: combine things and generate installers</li>
<li>host: upload files to hosting, make URLs live</li>
<li>publish: publish to package managers</li>
<li>announce: announce to the world that the release was a success</li>
</ol>
<h4 id="plan-jobs"><a class="header" href="#plan-jobs"><code>plan-jobs</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.7.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
plan-jobs = ["./my-job"]
</code></pre>
</blockquote>
<p>This setting determines which custom jobs to run during the "plan" phase, which happens at the very start of the build.</p>
<h4 id="local-artifacts-jobs"><a class="header" href="#local-artifacts-jobs"><code>local-artifacts-jobs</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.7.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
local-artifacts-jobs = ["./my-job"]
</code></pre>
</blockquote>
<p>This setting determines which custom jobs to run during the "build local artifacts" phase, during which binaries are built.</p>
<h4 id="global-artifacts-jobs"><a class="header" href="#global-artifacts-jobs"><code>global-artifacts-jobs</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.7.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
global-artifacts-jobs = ["./my-job"]
</code></pre>
</blockquote>
<p>This setting determines which custom jobs to run during the "build global artifacts" phase, during which installers are built.</p>
<h4 id="host-jobs"><a class="header" href="#host-jobs"><code>host-jobs</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.7.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
host-jobs = ["./my-job"]
</code></pre>
</blockquote>
<p>This setting determines which custom jobs to run during the "host" phase, during which dist decides whether to proceed with publishing the release.</p>
<h4 id="publish-jobs"><a class="header" href="#publish-jobs"><code>publish-jobs</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.2.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
publish-jobs = ["homebrew", "npm", "./my-custom-job"]
</code></pre>
</blockquote>
<p>This setting determines which publish jobs to run. It accepts 3 kinds of value:</p>
<ul>
<li><a href="reference/../installers/homebrew.html">"homebrew", for builtin homebrew publishes</a> (since 0.2.0)</li>
<li><a href="reference/../installers/npm.html">"npm", for builtin npm publishes</a> (since 0.14.0)</li>
<li><a href="reference/../ci/customizing.html#custom-jobs">"./my-custom-job" for custom jobs</a> (since 0.3.0)</li>
</ul>
<h4 id="post-announce-jobs"><a class="header" href="#post-announce-jobs"><code>post-announce-jobs</code></a></h4>
<blockquote>
<p><span style="float:right">since 0.7.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../ci/index.html">ðŸ“– read the ci customization guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[dist]
post-announce-jobs = ["./my-job"]
</code></pre>
</blockquote>
<p>This setting determines which custom jobs to run after the "announce" phase. "Announce" is the final phase during which dist schedules any jobs, so any custom jobs specified here are guaranteed to run after everything else.</p>
<h1 id="the-workspace-section"><a class="header" href="#the-workspace-section">the <code>[workspace]</code> section</a></h1>
<p>This section is only available in <code>dist-workspace.toml</code> files.</p>
<h3 id="workspacemembers"><a class="header" href="#workspacemembers"><code>workspace.members</code></a></h3>
<blockquote>
<p><span style="float:right">since 0.20.0<br><a href="reference/config.html#setting-availabilities">global-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>[]</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[workspace]
members = [
    "cargo:rel/path/to/rust/workspace",
    "npm:some/js/project/",
    "npm:some/other/js/project/",
    "dist:a/generic/project/"
]
</code></pre>
</blockquote>
<p>In a dist-workspace.toml, this specifies the various projects/workspaces/packages that should
be managed by dist. Each member is of the format <code>&lt;project-type&gt;:&lt;relative-path&gt;</code> where
<code>relative-path</code> is a path relative to the dist-workspace.toml to a directory containing that type of project, and <code>project-type</code> can be one of:</p>
<ul>
<li>cargo: expect a Cargo.toml for a cargo-based Rust project in that dir</li>
<li>npm: expect a package.json for an npm-based JavaScript project in that dir</li>
<li>dist: expect a dist.toml for a dist-based generic project in that dir</li>
</ul>
<h1 id="the-package-section"><a class="header" href="#the-package-section">the <code>[package]</code> section</a></h1>
<p>This section is available in <code>dist.toml</code> and <code>dist-workspace.toml</code> files.</p>
<h2 id="packagename"><a class="header" href="#packagename"><code>package.name</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
name = "my-cool-app"
</code></pre>
</blockquote>
<p>The name of the package.</p>
<p>All packages must have a name, either sourced from a dist.toml or inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>The name is used in a myriad of places to refer to your application and its releases.</p>
<h2 id="packageversion"><a class="header" href="#packageversion"><code>package.version</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
version = "1.2.0-prerelease.2"
</code></pre>
</blockquote>
<p>The version of the package. Syntax must be a valid <a href="https://docs.rs/semver/latest/semver/struct.Version.html">Cargo SemVer Version</a>.</p>
<p>All packages must have a version, either sourced from a dist.toml or inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>The version is used in a myriad of places to refer to your application and its releases.</p>
<h2 id="packagedescription"><a class="header" href="#packagedescription"><code>package.description</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
version = "A cool application that solves all your problems!"
</code></pre>
</blockquote>
<p>A brief description of the package.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This may be used in the metadata of various <a href="reference/../installers/index.html">installers</a>.</p>
<h2 id="packageauthors"><a class="header" href="#packageauthors"><code>package.authors</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
authors = ["axodotdev &lt;hello@axo.dev&gt;"]
</code></pre>
</blockquote>
<p>The authors of the package.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This may be used in the metadata of various <a href="reference/../installers/index.html">installers</a>. We recommend keeping it fairly generic to avoid needless hassles from people changing their names.</p>
<h2 id="packagerepository"><a class="header" href="#packagerepository"><code>package.repository</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
repository = "https://github.com/axodotdev/axolotolsay"
</code></pre>
</blockquote>
<p>A URL to the repository hosting this package.</p>
<p>The following formats are all supported and treated as equivalent:</p>
<ul>
<li><code>"https://github.com/axodotdev/axolotolsay"</code></li>
<li><code>"https://github.com/axodotdev/axolotolsay.git"</code></li>
<li><code>"git@github.com:axodotdev/axolotlsay.git"</code></li>
</ul>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This is <em>essentially</em> required as almost all dist features are blocked behind knowing where your project is hosted. All <a href="reference/config.html#dist">distable</a> packages must agree on this value.</p>
<h2 id="packagehomepage"><a class="header" href="#packagehomepage"><code>package.homepage</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
homepage = "https://axodotdev.github.io/axolotlsay"
</code></pre>
</blockquote>
<p>A URL to the homepage of the package.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This may be used in the metadata of various <a href="reference/../installers/index.html">installers</a>.</p>
<h2 id="packagedocumentation"><a class="header" href="#packagedocumentation"><code>package.documentation</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
documentation = "https://docs.rs/axolotlsay"
</code></pre>
</blockquote>
<p>A URL to the documentation of the package.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This may be used in the metadata of various <a href="reference/../installers/index.html">installers</a>.</p>
<h2 id="packagechangelog"><a class="header" href="#packagechangelog"><code>package.changelog</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
changelog = "../CHANGELOG.md"
</code></pre>
</blockquote>
<p>A relative path to the changelog file for your package.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This can be used by various dist features that use your changelog, such as <a href="reference/config.html#auto-includes">auto-includes</a> and <a href="reference/../ci/index.html">release-bodies</a>. We will often <a href="reference/../artifacts/archives.html">autodetect this for you</a>, so this setting is only needed if your changelog has a special name/location/format we can't find.</p>
<h2 id="packagereadme"><a class="header" href="#packagereadme"><code>package.readme</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
readme = "../README.md"
</code></pre>
</blockquote>
<p>A relative path to the readme file for your package.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This can be used by various dist features that use your readme, such as <a href="reference/config.html#auto-includes">auto-includes</a>. We will often <a href="reference/../artifacts/archives.html">autodetect this for you</a>, so this setting is only needed if your readme has a special name/location/format we can't find.</p>
<h2 id="packagelicense"><a class="header" href="#packagelicense"><code>package.license</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
license = "MIT OR Apache-2.0"
</code></pre>
</blockquote>
<p>The license(s) of your package, in <a href="https://spdx.org/licenses">SPDX format</a>.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This may be used in the metadata of various <a href="reference/../installers/index.html">installers</a>.</p>
<h2 id="packagelicense-files"><a class="header" href="#packagelicense-files"><code>package.license-files</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
readme = ["../LICENSE-MIT", "../LICENSE-APACHE"]
</code></pre>
</blockquote>
<p>Relative paths to the license files for your package.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>This can be used by various dist features that use your license files, such as <a href="reference/config.html#auto-includes">auto-includes</a>. We will often <a href="reference/../artifacts/archives.html">autodetect this for you</a>, so this setting is only needed if your licenses have a special name/location/format we can't find.</p>
<h2 id="packagebinaries"><a class="header" href="#packagebinaries"><code>package.binaries</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
binaries = ["my-app", "my-other-app"]
</code></pre>
</blockquote>
<p>Names of binaries (without the extension) your package is expected to build and distribute.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>Including binaries by default opts your package into being <a href="reference/config.html#dist">distable</a>.</p>
<p>See also: <a href="reference/config.html#bin-aliases">bin-aliases</a>, <a href="reference/config.html#packagecstaticlibs">cstaticlibs</a>, <a href="reference/config.html#packagecdylibs">cdylibs</a></p>
<h2 id="packagecstaticlibs"><a class="header" href="#packagecstaticlibs"><code>package.cstaticlibs</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
cstaticlibs = ["mystaticlib", "some-helper"]
</code></pre>
</blockquote>
<p>Names of c-style static libraries (without the extension) your package is expected to build and distribute.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>Including cstaticlibs opts your package into being <a href="reference/config.html#dist">distable</a> if <a href="reference/config.html#package-libraries"><code>package-libraries = ["cstaticlibs"]</code></a> is set.</p>
<p>See also: <a href="reference/config.html#packagebinaries">binaries</a>, <a href="reference/config.html#packagecdylibs">cdylibs</a></p>
<h2 id="packagecdylibs"><a class="header" href="#packagecdylibs"><code>package.cdylibs</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
cdylibs = ["mydylib", "some-other-helper"]
</code></pre>
</blockquote>
<p>Names of c-style dynamic libraries (without the extension) your package is expected to build and distribute.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc.</p>
<p>Including cdylibs opts your package into being <a href="reference/config.html#dist">distable</a> if <a href="reference/config.html#package-libraries"><code>package-libraries = ["cdylibs"]</code></a> is set.</p>
<p>See also: <a href="reference/config.html#packagebinaries">binaries</a>, <a href="reference/config.html#packagecstaticlibs">cstaticlibs</a></p>
<h2 id="packagebuild-command"><a class="header" href="#packagebuild-command"><code>package.build-command</code></a></h2>
<blockquote>
<p><span style="float:right">since 0.12.0<br><a href="reference/config.html#setting-availabilities">package-only</a></span>
ðŸ”§ this is an experimental feature! <br />
<a href="reference/../custom-builds.html">ðŸ“– read the project structure guide!</a> <br />
default = <code>&lt;none&gt;</code></p>
<p><em>in your dist-workspace.toml or dist.toml:</em></p>
<pre><code class="language-toml">[package]
build-command = ["make", "dist"]
</code></pre>
</blockquote>
<p>A command to run in your package's root directory to build its <a href="reference/config.html#packagebinaries">binaries</a>, <a href="reference/config.html#packagecstaticlibs">cstaticlibs</a>, and <a href="reference/config.html#packagecdylibs">cdylibs</a>.</p>
<p>If not specified, this can be inherited from a language's native package format like a <a href="reference/../quickstart/rust.html">Cargo.toml</a>, <a href="reference/../quickstart/javascript.html">package.json</a>, etc. (This is often preferred since we can natively understand e.g. <a href="reference/config.html#cargo-build-settings">Cargo builds</a>).</p>
<h2 id="setting-availabilities"><a class="header" href="#setting-availabilities">setting availabilities</a></h2>
<p>Throughout the above docs, different settings will have different rules for where they can be specified (root workspace config file or package config file), and how they'll be inherited.</p>
<ul>
<li>global-only: this setting can only be set in the root workspace config (<a href="reference/../quickstart/javascript.html">dist-workspace.toml</a> or <a href="reference/../custom-builds.html">dist.toml</a>)</li>
<li>package-only: this setting can only be set in a package config (<a href="reference/../custom-builds.html">dist.toml</a>)</li>
<li>package-local: this setting can be set in either, with the package overriding the workspace value if it provides one (and otherwise inheriting it).</li>
</ul>
<p>When you override a package-local setting, the workspace value will be discarded completely. So for instance if the workspace sets <code>features = ["feature1", "feature2"]</code> and a package sets <code>features = ["feature2", "feature3"]</code>, then that package will only get feature2 and feature3.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dist-cli-manual"><a class="header" href="#dist-cli-manual">dist CLI Manual</a></h1>
<ul>
<li><a href="reference/cli.html#usage">Usage</a></li>
<li><a href="reference/cli.html#commands">Commands</a></li>
<li><a href="reference/cli.html#options">Options</a></li>
<li><a href="reference/cli.html#global-options">GLOBAL OPTIONS</a>
<ul>
<li><a href="reference/cli.html#-v---verbose-verbose"><code>-v, --verbose &lt;VERBOSE&gt;</code></a></li>
<li><a href="reference/cli.html#-o---output-format-output_format"><code>-o, --output-format &lt;OUTPUT_FORMAT&gt;</code></a></li>
<li><a href="reference/cli.html#--no-local-paths"><code>--no-local-paths</code></a></li>
<li><a href="reference/cli.html#-t---target-target"><code>-t, --target &lt;TARGET&gt;</code></a></li>
<li><a href="reference/cli.html#-i---installer-installer"><code>-i, --installer &lt;INSTALLER&gt;</code></a></li>
<li><a href="reference/cli.html#-c---ci-ci"><code>-c, --ci &lt;CI&gt;</code></a></li>
<li><a href="reference/cli.html#--tag-tag"><code>--tag &lt;TAG&gt;</code></a></li>
<li><a href="reference/cli.html#--force-tag"><code>--force-tag</code></a></li>
<li><a href="reference/cli.html#--allow-dirty"><code>--allow-dirty</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-build">dist build</a>
<ul>
<li><a href="reference/cli.html#usage-1">Usage</a></li>
<li><a href="reference/cli.html#options-1">Options</a>
<ul>
<li><a href="reference/cli.html#-a---artifacts-artifacts"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></li>
<li><a href="reference/cli.html#-p---print-print"><code>-p, --print &lt;PRINT&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-1">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-init">dist init</a>
<ul>
<li><a href="reference/cli.html#usage-2">Usage</a></li>
<li><a href="reference/cli.html#options-2">Options</a>
<ul>
<li><a href="reference/cli.html#-y---yes"><code>-y, --yes</code></a></li>
<li><a href="reference/cli.html#--skip-generate"><code>--skip-generate</code></a></li>
<li><a href="reference/cli.html#--with-json-config-with_json_config"><code>--with-json-config &lt;WITH_JSON_CONFIG&gt;</code></a></li>
<li><a href="reference/cli.html#--hosting-hosting"><code>--hosting &lt;HOSTING&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-1"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-2">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-migrate">dist migrate</a>
<ul>
<li><a href="reference/cli.html#usage-3">Usage</a></li>
<li><a href="reference/cli.html#options-3">Options</a>
<ul>
<li><a href="reference/cli.html#-h---help-2"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-3">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-generate">dist generate</a>
<ul>
<li><a href="reference/cli.html#usage-4">Usage</a></li>
<li><a href="reference/cli.html#options-4">Options</a>
<ul>
<li><a href="reference/cli.html#--mode-mode"><code>--mode &lt;MODE&gt;</code></a></li>
<li><a href="reference/cli.html#--check"><code>--check</code></a></li>
<li><a href="reference/cli.html#-h---help-3"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-4">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-linkage">dist linkage</a>
<ul>
<li><a href="reference/cli.html#usage-5">Usage</a></li>
<li><a href="reference/cli.html#options-5">Options</a>
<ul>
<li><a href="reference/cli.html#--print-output"><code>--print-output</code></a></li>
<li><a href="reference/cli.html#--print-json"><code>--print-json</code></a></li>
<li><a href="reference/cli.html#--from-json-from_json"><code>--from-json &lt;FROM_JSON&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-4"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-5">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-manifest">dist manifest</a>
<ul>
<li><a href="reference/cli.html#usage-6">Usage</a></li>
<li><a href="reference/cli.html#options-6">Options</a>
<ul>
<li><a href="reference/cli.html#-a---artifacts-artifacts-1"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></li>
<li><a href="reference/cli.html#-p---print-print-1"><code>-p, --print &lt;PRINT&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-5"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-6">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-plan">dist plan</a>
<ul>
<li><a href="reference/cli.html#usage-7">Usage</a></li>
<li><a href="reference/cli.html#options-7">Options</a>
<ul>
<li><a href="reference/cli.html#-h---help-6"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-7">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-host">dist host</a>
<ul>
<li><a href="reference/cli.html#usage-8">Usage</a></li>
<li><a href="reference/cli.html#options-8">Options</a>
<ul>
<li><a href="reference/cli.html#--steps-steps"><code>--steps &lt;STEPS&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-7"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-8">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-selfupdate">dist selfupdate</a>
<ul>
<li><a href="reference/cli.html#usage-9">Usage</a></li>
<li><a href="reference/cli.html#options-9">Options</a>
<ul>
<li><a href="reference/cli.html#--version-version"><code>--version &lt;VERSION&gt;</code></a></li>
<li><a href="reference/cli.html#--prerelease"><code>--prerelease</code></a></li>
<li><a href="reference/cli.html#-y---yes-1"><code>-y, --yes</code></a></li>
<li><a href="reference/cli.html#--skip-init"><code>--skip-init</code></a></li>
<li><a href="reference/cli.html#--skip-generate-1"><code>--skip-generate</code></a></li>
<li><a href="reference/cli.html#--with-json-config-with_json_config-1"><code>--with-json-config &lt;WITH_JSON_CONFIG&gt;</code></a></li>
<li><a href="reference/cli.html#--hosting-hosting-1"><code>--hosting &lt;HOSTING&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-8"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-9">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#dist-help">dist help</a>
<ul>
<li><a href="reference/cli.html#usage-10">Usage</a></li>
<li><a href="reference/cli.html#commands-1">Commands</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>This manual can be regenerated with <code>dist help-markdown</code></p>
</blockquote>
<p>Professional packaging and distribution for ambitious developers.</p>
<p>See 'init', 'build' and 'plan' for the 3 most important subcommands.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre><code class="language-text">dist [OPTIONS]
</code></pre>
<p>dist <COMMAND></p>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<ul>
<li><a href="reference/cli.html#cargo-dist-build">build</a>: Build artifacts</li>
<li><a href="reference/cli.html#cargo-dist-init">init</a>: Setup or update dist</li>
<li><a href="reference/cli.html#cargo-dist-migrate">migrate</a>: Migrate to the latest configuration variant</li>
<li><a href="reference/cli.html#cargo-dist-generate">generate</a>: Generate one or more pieces of configuration</li>
<li><a href="reference/cli.html#cargo-dist-linkage">linkage</a>: Report on the dynamic libraries used by the built artifacts</li>
<li><a href="reference/cli.html#cargo-dist-manifest">manifest</a>: Generate the final build manifest without running any builds</li>
<li><a href="reference/cli.html#cargo-dist-plan">plan</a>: Get a plan of what to build (and check project status)</li>
<li><a href="reference/cli.html#cargo-dist-host">host</a>: Host artifacts</li>
<li><a href="reference/cli.html#cargo-dist-selfupdate">selfupdate</a>: Performs a self-update, if a new version is available, and then 'init'</li>
<li><a href="reference/cli.html#cargo-dist-help">help</a>: Print this message or the help of the given subcommand(s)</li>
</ul>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<h3 id="global-options"><a class="header" href="#global-options">GLOBAL OPTIONS</a></h3>
<h4 id="-v---verbose-verbose"><a class="header" href="#-v---verbose-verbose"><code>-v, --verbose &lt;VERBOSE&gt;</code></a></h4>
<p>How verbose logging should be (log level)</p>
<p>[default: warn]<br />
[possible values: off, error, warn, info, debug, trace]</p>
<h4 id="-o---output-format-output_format"><a class="header" href="#-o---output-format-output_format"><code>-o, --output-format &lt;OUTPUT_FORMAT&gt;</code></a></h4>
<p>The format of the output</p>
<p>[default: human]<br />
[possible values: human, json]</p>
<h4 id="--no-local-paths"><a class="header" href="#--no-local-paths"><code>--no-local-paths</code></a></h4>
<p>Strip local paths from output (e.g. in the dist manifest json)</p>
<p>This is useful for generating a clean "full" manifest as follows:</p>
<p><code>dist manifest --artifacts=all --output-format=json --no-local-paths</code></p>
<h4 id="-t---target-target"><a class="header" href="#-t---target-target"><code>-t, --target &lt;TARGET&gt;</code></a></h4>
<p>Target triples we want to build</p>
<p>If left unspecified we will use the values in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>, except for <code>dist init</code> which will select some "good defaults" for you.</p>
<h4 id="-i---installer-installer"><a class="header" href="#-i---installer-installer"><code>-i, --installer &lt;INSTALLER&gt;</code></a></h4>
<p>Installers we want to build</p>
<p>If left unspecified we will use the values in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>. <code>dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>shell:      Generates a shell script that fetches/installs the right build</li>
<li>powershell: Generates a powershell script that fetches/installs the right build</li>
<li>npm:        Generates an npm project that fetches the right build to your node_modules</li>
<li>homebrew:   Generates a Homebrew formula</li>
<li>msi:        Generates an msi for each windows platform</li>
</ul>
<h4 id="-c---ci-ci"><a class="header" href="#-c---ci-ci"><code>-c, --ci &lt;CI&gt;</code></a></h4>
<p>CI we want to support</p>
<p>If left unspecified we will use the value in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>. <code>dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>github: Generate github CI that uploads to github releases</li>
</ul>
<h4 id="--tag-tag"><a class="header" href="#--tag-tag"><code>--tag &lt;TAG&gt;</code></a></h4>
<p>The (git) tag to use for the Announcement that each invocation of dist is performing.</p>
<p>This tag serves two purposes: defining which apps we are Announcing new Releases for (and therefore building binaries and installers for); and picking an id to use for certain URLs. For instance the git tag associated with a Github Release is part of the URL to fetch artifacts from that release, which needs to be known by some installers!</p>
<p>Unified Announcement: VERSION selects all packages with the given version (v1.0.0, 0.1.0-prerelease.1, releases/1.2.3, ...)</p>
<p>Singular Announcement: PACKAGE-VERSION or PACKAGE/VERSION selects only the given package (my-app-v1.0.0, my-app/1.0.0, release/my-app/v1.2.3-alpha, ...)</p>
<p>If you use the singular version then we will only Announce/Release that package's apps (and return an error if that is not in fact the package's current version). This is appropriate for workspaces that have more than one app.</p>
<p>If you use the unified version then we will assume you're Announcing/Releasing all packages in the workspace that have that version. This is appropriate for workspaces that only have one app, or for monorepos that version all their apps in lockstep.</p>
<p>If you do not specify this tag we will attempt to infer it by trying to Announce/Release every app in the workspace, succeeding only if they all have the same version. The tag selected will be "v{VERSION}".</p>
<p>In the future we may try to make this look at the current git tags or something?</p>
<h4 id="--force-tag"><a class="header" href="#--force-tag"><code>--force-tag</code></a></h4>
<p>Force package versions to match the tag</p>
<h4 id="--allow-dirty"><a class="header" href="#--allow-dirty"><code>--allow-dirty</code></a></h4>
<p>Allow generated files like CI scripts to be out of date</p>
<p><br><br><br></p>
<h2 id="dist-build"><a class="header" href="#dist-build">dist build</a></h2>
<p>Build artifacts</p>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre><code class="language-text">dist build [OPTIONS]
</code></pre>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<h4 id="-a---artifacts-artifacts"><a class="header" href="#-a---artifacts-artifacts"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></h4>
<p>Which subset of the Artifacts to build</p>
<p>Artifacts can be broken up into two major classes: "local" ones, which are made for each target system (archives, symbols, msi installers...); and "global" ones, which are made once per app (curl-sh installers, npm package, metadata...).</p>
<p>Having this distinction lets us run dist independently on multiple machines without collisions between the outputs.</p>
<p>If let unspecified, we will pick a fuzzier "host" mode that builds "as much as possible" for the local system. This mode is appropriate for local testing/debugging/demoing. If no --target flags are passed on the CLI then "host" mode will try to intelligently guess which targets to build for, which may include building targets that aren't defined in your metadata.dist config (since that config may exclude the current machine!).</p>
<p>The specifics of "host" mode are intentionally unspecified to enable us to provider better out-of-the-box UX for local usage. In CI environments you should always specify "global" or "local" to get consistent behaviour!</p>
<p>Possible values:</p>
<ul>
<li>local:  Build target-specific artifacts like archives and msi installers</li>
<li>global: Build unique artifacts like curl-sh installers and npm packages</li>
<li>host:   Fuzzily build "as much as possible" for the host system</li>
<li>all:    Build all the artifacts; useful for <code>dist manifest</code></li>
<li>lies:   Fake all the artifacts; useful for testing/mocking/staging</li>
</ul>
<p>[default: host]</p>
<h4 id="-p---print-print"><a class="header" href="#-p---print-print"><code>-p, --print &lt;PRINT&gt;</code></a></h4>
<p>What extra information to print, if anything. Currently supported:</p>
<ul>
<li>linkage: prints information on dynamic libraries used by build artifacts</li>
</ul>
<h4 id="-h---help"><a class="header" href="#-h---help"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-1"><a class="header" href="#global-options-1">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-init"><a class="header" href="#dist-init">dist init</a></h2>
<p>Setup or update dist</p>
<p>This will interactively guide you through the process of selecting configuration options and will also automatically run 'dist generate' afterwards as necessary. It will also handle updating your project to a new version of dist if you're running one.</p>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre><code class="language-text">dist init [OPTIONS]
</code></pre>
<h3 id="options-2"><a class="header" href="#options-2">Options</a></h3>
<h4 id="-y---yes"><a class="header" href="#-y---yes"><code>-y, --yes</code></a></h4>
<p>Automatically accept all recommended/default values</p>
<p>This is equivalent to just mashing ENTER over and over during the interactive prompts.</p>
<h4 id="--skip-generate"><a class="header" href="#--skip-generate"><code>--skip-generate</code></a></h4>
<p>Skip running 'dist generate' at the end</p>
<h4 id="--with-json-config-with_json_config"><a class="header" href="#--with-json-config-with_json_config"><code>--with-json-config &lt;WITH_JSON_CONFIG&gt;</code></a></h4>
<p>A path to a json file containing values to set in workspace.metadata.dist and package.metadata.dist, for building tools that edit these configs.</p>
<p>This is the same toml =&gt; json format that <code>cargo metadata</code> produces when reporting <code>workspace.metadata.dist</code>. There is some additional hierarchy for specifying which values go to which packages, but this is currently intentionally undocumented to give us some flexibility to change it.</p>
<h4 id="--hosting-hosting"><a class="header" href="#--hosting-hosting"><code>--hosting &lt;HOSTING&gt;</code></a></h4>
<p>releases hosting backends we want to support</p>
<p>If left unspecified we will use the value in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>. (If no such value exists we will use the one "native" to your CI provider) <code>dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>github: Host on Github Releases</li>
</ul>
<h4 id="-h---help-1"><a class="header" href="#-h---help-1"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-2"><a class="header" href="#global-options-2">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-migrate"><a class="header" href="#dist-migrate">dist migrate</a></h2>
<p>Migrate to the latest configuration variant</p>
<h3 id="usage-5"><a class="header" href="#usage-5">Usage</a></h3>
<pre><code class="language-text">dist migrate [OPTIONS]
</code></pre>
<h3 id="options-3"><a class="header" href="#options-3">Options</a></h3>
<h4 id="-h---help-2"><a class="header" href="#-h---help-2"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-3"><a class="header" href="#global-options-3">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-generate"><a class="header" href="#dist-generate">dist generate</a></h2>
<p>Generate one or more pieces of configuration</p>
<h3 id="usage-6"><a class="header" href="#usage-6">Usage</a></h3>
<pre><code class="language-text">dist generate [OPTIONS]
</code></pre>
<h3 id="options-4"><a class="header" href="#options-4">Options</a></h3>
<h4 id="--mode-mode"><a class="header" href="#--mode-mode"><code>--mode &lt;MODE&gt;</code></a></h4>
<p>Which type of configuration to generate</p>
<p>Possible values:</p>
<ul>
<li>ci:  Generate CI scripts for orchestrating dist</li>
<li>msi: Generate .wxs templates for msi installers</li>
</ul>
<h4 id="--check"><a class="header" href="#--check"><code>--check</code></a></h4>
<p>Check if the generated output differs from on-disk config without writing it</p>
<h4 id="-h---help-3"><a class="header" href="#-h---help-3"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-4"><a class="header" href="#global-options-4">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-linkage"><a class="header" href="#dist-linkage">dist linkage</a></h2>
<p>Report on the dynamic libraries used by the built artifacts</p>
<h3 id="usage-7"><a class="header" href="#usage-7">Usage</a></h3>
<pre><code class="language-text">dist linkage [OPTIONS]
</code></pre>
<h3 id="options-5"><a class="header" href="#options-5">Options</a></h3>
<h4 id="--print-output"><a class="header" href="#--print-output"><code>--print-output</code></a></h4>
<p>Print human-readable output</p>
<h4 id="--print-json"><a class="header" href="#--print-json"><code>--print-json</code></a></h4>
<p>Print output as JSON</p>
<h4 id="--from-json-from_json"><a class="header" href="#--from-json-from_json"><code>--from-json &lt;FROM_JSON&gt;</code></a></h4>
<p>Read linkage data from JSON rather than parsing from binaries</p>
<h4 id="-h---help-4"><a class="header" href="#-h---help-4"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-5"><a class="header" href="#global-options-5">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-manifest"><a class="header" href="#dist-manifest">dist manifest</a></h2>
<p>Generate the final build manifest without running any builds.</p>
<p>This command is designed to match the exact behaviour of 'dist build' when passed the same flags, which is nice for consistency but annoying for anyone who doesn't understand dist's design really well.</p>
<p>Notably it will default to only talking about artifacts for the host system, and will produce paths to the build dir that may not exist (since the build wasn't run).</p>
<p>'dist plan' is an alias for this command that picks nicer defaults by forcing a couple flags to have specific values. You probably want that.</p>
<h3 id="usage-8"><a class="header" href="#usage-8">Usage</a></h3>
<pre><code class="language-text">dist manifest [OPTIONS]
</code></pre>
<h3 id="options-6"><a class="header" href="#options-6">Options</a></h3>
<h4 id="-a---artifacts-artifacts-1"><a class="header" href="#-a---artifacts-artifacts-1"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></h4>
<p>Which subset of the Artifacts to build</p>
<p>Artifacts can be broken up into two major classes: "local" ones, which are made for each target system (archives, symbols, msi installers...); and "global" ones, which are made once per app (curl-sh installers, npm package, metadata...).</p>
<p>Having this distinction lets us run dist independently on multiple machines without collisions between the outputs.</p>
<p>If let unspecified, we will pick a fuzzier "host" mode that builds "as much as possible" for the local system. This mode is appropriate for local testing/debugging/demoing. If no --target flags are passed on the CLI then "host" mode will try to intelligently guess which targets to build for, which may include building targets that aren't defined in your metadata.dist config (since that config may exclude the current machine!).</p>
<p>The specifics of "host" mode are intentionally unspecified to enable us to provider better out-of-the-box UX for local usage. In CI environments you should always specify "global" or "local" to get consistent behaviour!</p>
<p>Possible values:</p>
<ul>
<li>local:  Build target-specific artifacts like archives and msi installers</li>
<li>global: Build unique artifacts like curl-sh installers and npm packages</li>
<li>host:   Fuzzily build "as much as possible" for the host system</li>
<li>all:    Build all the artifacts; useful for <code>dist manifest</code></li>
<li>lies:   Fake all the artifacts; useful for testing/mocking/staging</li>
</ul>
<p>[default: host]</p>
<h4 id="-p---print-print-1"><a class="header" href="#-p---print-print-1"><code>-p, --print &lt;PRINT&gt;</code></a></h4>
<p>What extra information to print, if anything. Currently supported:</p>
<ul>
<li>linkage: prints information on dynamic libraries used by build artifacts</li>
</ul>
<h4 id="-h---help-5"><a class="header" href="#-h---help-5"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-6"><a class="header" href="#global-options-6">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-plan"><a class="header" href="#dist-plan">dist plan</a></h2>
<p>Get a plan of what to build (and check project status)</p>
<p>If you want to know what running your dist CI will produce, this is the command for you! This is the exact command that CI will run to make its build plan and generate dist-manifest.json (although it adds --output-format=json so that it's machine-readable).</p>
<p>This is an alias for the lower-level 'manifest' command with the appropriate flags forced for asking for "everything"</p>
<p>dist manifest --artifacts=all --no-local-paths</p>
<h3 id="usage-9"><a class="header" href="#usage-9">Usage</a></h3>
<pre><code class="language-text">dist plan [OPTIONS]
</code></pre>
<h3 id="options-7"><a class="header" href="#options-7">Options</a></h3>
<h4 id="-h---help-6"><a class="header" href="#-h---help-6"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-7"><a class="header" href="#global-options-7">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-host"><a class="header" href="#dist-host">dist host</a></h2>
<p>Host artifacts</p>
<h3 id="usage-10"><a class="header" href="#usage-10">Usage</a></h3>
<pre><code class="language-text">dist host [OPTIONS]
</code></pre>
<h3 id="options-8"><a class="header" href="#options-8">Options</a></h3>
<h4 id="--steps-steps"><a class="header" href="#--steps-steps"><code>--steps &lt;STEPS&gt;</code></a></h4>
<p>The hosting steps to perform</p>
<p>Possible values:</p>
<ul>
<li>check:    Check that hosting is properly setup without doing other effects</li>
<li>create:   Create a location to host artifacts</li>
<li>upload:   Upload artifacts</li>
<li>release:  Release artifacts</li>
<li>announce: Announce artifacts</li>
</ul>
<h4 id="-h---help-7"><a class="header" href="#-h---help-7"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-8"><a class="header" href="#global-options-8">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-selfupdate"><a class="header" href="#dist-selfupdate">dist selfupdate</a></h2>
<p>Performs a self-update, if a new version is available, and then 'init'</p>
<h3 id="usage-11"><a class="header" href="#usage-11">Usage</a></h3>
<pre><code class="language-text">dist selfupdate [OPTIONS]
</code></pre>
<h3 id="options-9"><a class="header" href="#options-9">Options</a></h3>
<h4 id="--version-version"><a class="header" href="#--version-version"><code>--version &lt;VERSION&gt;</code></a></h4>
<p>Upgrade to a specific version, instead of "latest"</p>
<h4 id="--prerelease"><a class="header" href="#--prerelease"><code>--prerelease</code></a></h4>
<p>Allow upgrading to prereleases when picking "latest"</p>
<h4 id="-y---yes-1"><a class="header" href="#-y---yes-1"><code>-y, --yes</code></a></h4>
<p>Automatically accept all recommended/default values</p>
<p>This is equivalent to just mashing ENTER over and over during the interactive prompts.</p>
<h4 id="--skip-init"><a class="header" href="#--skip-init"><code>--skip-init</code></a></h4>
<p>Skip running 'dist init' after performing an upgrade</p>
<h4 id="--skip-generate-1"><a class="header" href="#--skip-generate-1"><code>--skip-generate</code></a></h4>
<p>Skip running 'dist generate' at the end</p>
<h4 id="--with-json-config-with_json_config-1"><a class="header" href="#--with-json-config-with_json_config-1"><code>--with-json-config &lt;WITH_JSON_CONFIG&gt;</code></a></h4>
<p>A path to a json file containing values to set in workspace.metadata.dist and package.metadata.dist, for building tools that edit these configs.</p>
<p>This is the same toml =&gt; json format that <code>cargo metadata</code> produces when reporting <code>workspace.metadata.dist</code>. There is some additional hierarchy for specifying which values go to which packages, but this is currently intentionally undocumented to give us some flexibility to change it.</p>
<h4 id="--hosting-hosting-1"><a class="header" href="#--hosting-hosting-1"><code>--hosting &lt;HOSTING&gt;</code></a></h4>
<p>releases hosting backends we want to support</p>
<p>If left unspecified we will use the value in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>. (If no such value exists we will use the one "native" to your CI provider) <code>dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>github: Host on Github Releases</li>
</ul>
<h4 id="-h---help-8"><a class="header" href="#-h---help-8"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-9"><a class="header" href="#global-options-9">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="dist-help"><a class="header" href="#dist-help">dist help</a></h2>
<p>Print this message or the help of the given subcommand(s)</p>
<h3 id="usage-12"><a class="header" href="#usage-12">Usage</a></h3>
<pre><code class="language-text">dist help [COMMAND]
</code></pre>
<h3 id="commands-1"><a class="header" href="#commands-1">Commands</a></h3>
<ul>
<li><a href="reference/cli.html#cargo-dist-build">build</a>: Build artifacts</li>
<li><a href="reference/cli.html#cargo-dist-init">init</a>: Setup or update dist</li>
<li><a href="reference/cli.html#cargo-dist-migrate">migrate</a>: Migrate to the latest configuration variant</li>
<li><a href="reference/cli.html#cargo-dist-generate">generate</a>: Generate one or more pieces of configuration</li>
<li><a href="reference/cli.html#cargo-dist-linkage">linkage</a>: Report on the dynamic libraries used by the built artifacts</li>
<li><a href="reference/cli.html#cargo-dist-manifest">manifest</a>: Generate the final build manifest without running any builds</li>
<li><a href="reference/cli.html#cargo-dist-plan">plan</a>: Get a plan of what to build (and check project status)</li>
<li><a href="reference/cli.html#cargo-dist-host">host</a>: Host artifacts</li>
<li><a href="reference/cli.html#cargo-dist-selfupdate">selfupdate</a>: Performs a self-update, if a new version is available, and then 'init'</li>
<li><a href="reference/cli.html#cargo-dist-help">help</a>: Print this message or the help of the given subcommand(s)</li>
</ul>
<p>stderr:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-schema"><a class="header" href="#json-schema">JSON Schema</a></h1>
<p>Many dist commands when run with <code>--output-format=json</code> will output to stdout a format we call "dist-manifest.json". This contains:</p>
<ul>
<li>Top-level facts about the Announcement (tag, announcement title, etc)</li>
<li>Info about the Apps being Released as part of the Announcement ("releases")</li>
<li>Info about the Artifacts included in the Announcement ("announcements")</li>
</ul>
<p>As a matter of forward-compat and back-compat, basically every field in the format should be treated as optional (which the schema reflects).</p>
<p>The latest schema can be found at:</p>
<p>https://github.com/axodotdev/cargo-dist/releases/latest/download/dist-manifest-schema.json</p>
<p>An example dist-manifest can be found at:</p>
<p>https://github.com/axodotdev/axolotlsay/releases/latest/download/dist-manifest.json</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
